        -:    0:Source:memcached.c
        -:    0:Graph:memcached.gcno
        -:    0:Data:memcached.gcda
        -:    0:Runs:183
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:/*
        -:    3: *  memcached - memory caching daemon
        -:    4: *
        -:    5: *       http://www.memcached.org/
        -:    6: *
        -:    7: *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.
        -:    8: *
        -:    9: *  Use and distribution licensed under the BSD license.  See
        -:   10: *  the LICENSE file for full text.
        -:   11: *
        -:   12: *  Authors:
        -:   13: *      Anatoly Vorobey <mellon@pobox.com>
        -:   14: *      Brad Fitzpatrick <brad@danga.com>
        -:   15: */
        -:   16:#include "memcached.h"
        -:   17:#include <sys/stat.h>
        -:   18:#include <sys/socket.h>
        -:   19:#include <sys/un.h>
        -:   20:#include <signal.h>
        -:   21:#include <sys/param.h>
        -:   22:#include <sys/resource.h>
        -:   23:#include <sys/uio.h>
        -:   24:#include <ctype.h>
        -:   25:#include <stdarg.h>
        -:   26:
        -:   27:/* some POSIX systems need the following definition
        -:   28: * to get mlockall flags out of sys/mman.h.  */
        -:   29:#ifndef _P1003_1B_VISIBLE
        -:   30:#define _P1003_1B_VISIBLE
        -:   31:#endif
        -:   32:/* need this to get IOV_MAX on some platforms. */
        -:   33:#ifndef __need_IOV_MAX
        -:   34:#define __need_IOV_MAX
        -:   35:#endif
        -:   36:#include <pwd.h>
        -:   37:#include <sys/mman.h>
        -:   38:#include <fcntl.h>
        -:   39:#include <netinet/tcp.h>
        -:   40:#include <arpa/inet.h>
        -:   41:#include <errno.h>
        -:   42:#include <stdlib.h>
        -:   43:#include <stdio.h>
        -:   44:#include <string.h>
        -:   45:#include <time.h>
        -:   46:#include <assert.h>
        -:   47:#include <limits.h>
        -:   48:#include <sysexits.h>
        -:   49:#include <stddef.h>
        -:   50:
        -:   51:/* FreeBSD 4.x doesn't have IOV_MAX exposed. */
        -:   52:#ifndef IOV_MAX
        -:   53:#if defined(__FreeBSD__) || defined(__APPLE__) || defined(__GNU__)
        -:   54:# define IOV_MAX 1024
        -:   55:/* GNU/Hurd don't set MAXPATHLEN
        -:   56: * http://www.gnu.org/software/hurd/hurd/porting/guidelines.html#PATH_MAX_tt_MAX_PATH_tt_MAXPATHL */
        -:   57:#ifndef MAXPATHLEN
        -:   58:#define MAXPATHLEN 4096
        -:   59:#endif
        -:   60:#endif
        -:   61:#endif
        -:   62:
        -:   63:/*
        -:   64: * forward declarations
        -:   65: */
        -:   66:static void drive_machine(conn *c);
        -:   67:static int new_socket(struct addrinfo *ai);
        -:   68:static int try_read_command(conn *c);
        -:   69:
        -:   70:enum try_read_result {
        -:   71:    READ_DATA_RECEIVED,
        -:   72:    READ_NO_DATA_RECEIVED,
        -:   73:    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */
        -:   74:    READ_MEMORY_ERROR      /** failed to allocate more memory */
        -:   75:};
        -:   76:
        -:   77:static enum try_read_result try_read_network(conn *c);
        -:   78:static enum try_read_result try_read_udp(conn *c);
        -:   79:
        -:   80:static void conn_set_state(conn *c, enum conn_states state);
        -:   81:static int start_conn_timeout_thread();
        -:   82:
        -:   83:/* stats */
        -:   84:static void stats_init(void);
        -:   85:static void server_stats(ADD_STAT add_stats, conn *c);
        -:   86:static void process_stat_settings(ADD_STAT add_stats, void *c);
        -:   87:static void conn_to_str(const conn *c, char *buf);
        -:   88:
        -:   89:
        -:   90:/* defaults */
        -:   91:static void settings_init(void);
        -:   92:
        -:   93:/* event handling, network IO */
        -:   94:static void event_handler(const int fd, const short which, void *arg);
        -:   95:static void conn_close(conn *c);
        -:   96:static void conn_init(void);
        -:   97:static bool update_event(conn *c, const int new_flags);
        -:   98:static void complete_nread(conn *c);
        -:   99:static void process_command(conn *c, char *command);
        -:  100:static void write_and_free(conn *c, char *buf, int bytes);
        -:  101:static int ensure_iov_space(conn *c);
        -:  102:static int add_iov(conn *c, const void *buf, int len);
        -:  103:static int add_chunked_item_iovs(conn *c, item *it, int len);
        -:  104:static int add_msghdr(conn *c);
        -:  105:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -:  106:                            const char *errstr, int swallow);
        -:  107:
        -:  108:static void conn_free(conn *c);
        -:  109:
        -:  110:/** exported globals **/
        -:  111:struct stats stats;
        -:  112:struct stats_state stats_state;
        -:  113:struct settings settings;
        -:  114:time_t process_started;     /* when the process was started */
        -:  115:conn **conns;
        -:  116:
        -:  117:struct slab_rebalance slab_rebal;
        -:  118:volatile int slab_rebalance_signal;
        -:  119:
        -:  120:/** file scope variables **/
        -:  121:static conn *listen_conn = NULL;
        -:  122:static int max_fds;
        -:  123:static struct event_base *main_base;
        -:  124:
        -:  125:enum transmit_result {
        -:  126:    TRANSMIT_COMPLETE,   /** All done writing. */
        -:  127:    TRANSMIT_INCOMPLETE, /** More data remaining to write. */
        -:  128:    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */
        -:  129:    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */
        -:  130:};
        -:  131:
        -:  132:static enum transmit_result transmit(conn *c);
        -:  133:
        -:  134:/* This reduces the latency without adding lots of extra wiring to be able to
        -:  135: * notify the listener thread of when to listen again.
        -:  136: * Also, the clock timer could be broken out into its own thread and we
        -:  137: * can block the listener via a condition.
        -:  138: */
        -:  139:static volatile bool allow_new_conns = true;
        -:  140:static struct event maxconnsevent;
    #####:  141:static void maxconns_handler(const int fd, const short which, void *arg) {
    #####:  142:    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};
        -:  143:
    #####:  144:    if (fd == -42 || allow_new_conns == false) {
        -:  145:        /* reschedule in 10ms if we need to keep polling */
    #####:  146:        evtimer_set(&maxconnsevent, maxconns_handler, 0);
    #####:  147:        event_base_set(main_base, &maxconnsevent);
    #####:  148:        evtimer_add(&maxconnsevent, &t);
        -:  149:    } else {
    #####:  150:        evtimer_del(&maxconnsevent);
    #####:  151:        accept_new_conns(true);
        -:  152:    }
    #####:  153:}
        -:  154:
        -:  155:#define REALTIME_MAXDELTA 60*60*24*30
        -:  156:
        -:  157:/*
        -:  158: * given time value that's either unix time or delta from current unix time, return
        -:  159: * unix time. Use the fact that delta can't exceed one month (and real time value can't
        -:  160: * be that low).
        -:  161: */
   154706:  162:static rel_time_t realtime(const time_t exptime) {
        -:  163:    /* no. of seconds in 30 days - largest possible delta exptime */
        -:  164:
   154706:  165:    if (exptime == 0) return 0; /* 0 means never expire */
        -:  166:
   52589*:  167:    if (exptime > REALTIME_MAXDELTA) {
        -:  168:        /* if item expiration is at/before the server started, give it an
        -:  169:           expiration time of 1 second after the server started.
        -:  170:           (because 0 means don't expire).  without this, we'd
        -:  171:           underflow and wrap around to some large value way in the
        -:  172:           future, effectively making items expiring in the past
        -:  173:           really expiring never */
   26096*:  174:        if (exptime <= process_started)
        -:  175:            return (rel_time_t)1;
       4*:  176:        return (rel_time_t)(exptime - process_started);
        -:  177:    } else {
   26497*:  178:        return (rel_time_t)(exptime + current_time);
        -:  179:    }
        -:  180:}
        -:  181:
       89:  182:static void stats_init(void) {
       89:  183:    memset(&stats, 0, sizeof(struct stats));
       89:  184:    memset(&stats_state, 0, sizeof(struct stats_state));
       89:  185:    stats_state.accepting_conns = true; /* assuming we start in this state. */
        -:  186:
        -:  187:    /* make the time we started always be 2 seconds before we really
        -:  188:       did, so time(0) - time.started is never zero.  if so, things
        -:  189:       like 'settings.oldest_live' which act as booleans as well as
        -:  190:       values are now false in boolean context... */
       89:  191:    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
       89:  192:    stats_prefix_init();
       89:  193:}
        -:  194:
        3:  195:static void stats_reset(void) {
        3:  196:    STATS_LOCK();
        3:  197:    memset(&stats, 0, sizeof(struct stats));
        3:  198:    stats_prefix_clear();
        3:  199:    STATS_UNLOCK();
        3:  200:    threadlocal_stats_reset();
        3:  201:    item_stats_reset();
        3:  202:}
        -:  203:
      183:  204:static void settings_init(void) {
      183:  205:    settings.use_cas = true;
      183:  206:    settings.access = 0700;
      183:  207:    settings.port = 11211;
      183:  208:    settings.udpport = 11211;
        -:  209:    /* By default this string should be NULL for getaddrinfo() */
      183:  210:    settings.inter = NULL;
      183:  211:    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
      183:  212:    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
      183:  213:    settings.verbose = 0;
      183:  214:    settings.oldest_live = 0;
      183:  215:    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */
      183:  216:    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
      183:  217:    settings.socketpath = NULL;       /* by default, not using a unix socket */
      183:  218:    settings.factor = 1.25;
      183:  219:    settings.chunk_size = 48;         /* space for a modest key and value */
      183:  220:    settings.num_threads = 4;         /* N workers */
      183:  221:    settings.num_threads_per_udp = 0;
      183:  222:    settings.prefix_delimiter = ':';
      183:  223:    settings.detail_enabled = 0;
      183:  224:    settings.reqs_per_event = 20;
      183:  225:    settings.backlog = 1024;
      183:  226:    settings.binding_protocol = negotiating_prot;
      183:  227:    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
      183:  228:    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */
      183:  229:    settings.slab_chunk_size_max = settings.slab_page_size;
      183:  230:    settings.sasl = false;
      183:  231:    settings.maxconns_fast = false;
      183:  232:    settings.lru_crawler = false;
      183:  233:    settings.lru_crawler_sleep = 100;
      183:  234:    settings.lru_crawler_tocrawl = 0;
      183:  235:    settings.lru_maintainer_thread = false;
      183:  236:    settings.hot_lru_pct = 32;
      183:  237:    settings.warm_lru_pct = 32;
      183:  238:    settings.expirezero_does_not_evict = false;
      183:  239:    settings.idle_timeout = 0; /* disabled */
      183:  240:    settings.hashpower_init = 0;
      183:  241:    settings.slab_reassign = false;
      183:  242:    settings.slab_automove = 0;
      183:  243:    settings.shutdown_command = false;
      183:  244:    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;
      183:  245:    settings.flush_enabled = true;
      183:  246:    settings.dump_enabled = true;
      183:  247:    settings.crawls_persleep = 1000;
      183:  248:    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;
      183:  249:    settings.logger_buf_size = LOGGER_BUF_SIZE;
      183:  250:}
        -:  251:
        -:  252:/*
        -:  253: * Adds a message header to a connection.
        -:  254: *
        -:  255: * Returns 0 on success, -1 on out-of-memory.
        -:  256: */
   385089:  257:static int add_msghdr(conn *c)
        -:  258:{
   385089:  259:    struct msghdr *msg;
        -:  260:
  385089*:  261:    assert(c != NULL);
        -:  262:
   385089:  263:    if (c->msgsize == c->msgused) {
    #####:  264:        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
    #####:  265:        if (! msg) {
    #####:  266:            STATS_LOCK();
    #####:  267:            stats.malloc_fails++;
    #####:  268:            STATS_UNLOCK();
    #####:  269:            return -1;
        -:  270:        }
    #####:  271:        c->msglist = msg;
    #####:  272:        c->msgsize *= 2;
        -:  273:    }
        -:  274:
   385089:  275:    msg = c->msglist + c->msgused;
        -:  276:
        -:  277:    /* this wipes msg_iovlen, msg_control, msg_controllen, and
        -:  278:       msg_flags, the last 3 of which aren't defined on solaris: */
   385089:  279:    memset(msg, 0, sizeof(struct msghdr));
        -:  280:
   385089:  281:    msg->msg_iov = &c->iov[c->iovused];
        -:  282:
   385089:  283:    if (IS_UDP(c->transport) && c->request_addr_size > 0) {
       29:  284:        msg->msg_name = &c->request_addr;
       29:  285:        msg->msg_namelen = c->request_addr_size;
        -:  286:    }
        -:  287:
   385089:  288:    c->msgbytes = 0;
   385089:  289:    c->msgused++;
        -:  290:
   385089:  291:    if (IS_UDP(c->transport)) {
        -:  292:        /* Leave room for the UDP header, which we'll fill in later. */
       29:  293:        return add_iov(c, NULL, UDP_HEADER_SIZE);
        -:  294:    }
        -:  295:
        -:  296:    return 0;
        -:  297:}
        -:  298:
        -:  299:extern pthread_mutex_t conn_lock;
        -:  300:
        -:  301:/* Connection timeout thread bits */
        -:  302:static pthread_t conn_timeout_tid;
        -:  303:
        -:  304:#define CONNS_PER_SLICE 100
        -:  305:#define TIMEOUT_MSG_SIZE (1 + sizeof(int))
        1:  306:static void *conn_timeout_thread(void *arg) {
        1:  307:    int i;
        1:  308:    conn *c;
        1:  309:    char buf[TIMEOUT_MSG_SIZE];
        1:  310:    rel_time_t oldest_last_cmd;
        1:  311:    int sleep_time;
        1:  312:    useconds_t timeslice = 1000000 / (max_fds / CONNS_PER_SLICE);
        -:  313:
        4:  314:    while(1) {
        2:  315:        if (settings.verbose > 2)
    #####:  316:            fprintf(stderr, "idle timeout thread at top of connection list\n");
        -:  317:
        2:  318:        oldest_last_cmd = current_time;
        -:  319:
     2050:  320:        for (i = 0; i < max_fds; i++) {
     2048:  321:            if ((i % CONNS_PER_SLICE) == 0) {
       22:  322:                if (settings.verbose > 2)
    #####:  323:                    fprintf(stderr, "idle timeout thread sleeping for %ulus\n",
        -:  324:                        timeslice);
       22:  325:                usleep(timeslice);
        -:  326:            }
        -:  327:
     2048:  328:            if (!conns[i])
     2026:  329:                continue;
        -:  330:
       22:  331:            c = conns[i];
        -:  332:
       22:  333:            if (!IS_TCP(c->transport))
       16:  334:                continue;
        -:  335:
        6:  336:            if (c->state != conn_new_cmd && c->state != conn_read)
        5:  337:                continue;
        -:  338:
        1:  339:            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
        1:  340:                buf[0] = 't';
        1:  341:                memcpy(&buf[1], &i, sizeof(int));
        1:  342:                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)
        -:  343:                    != TIMEOUT_MSG_SIZE)
    #####:  344:                    perror("Failed to write timeout to notify pipe");
        -:  345:            } else {
    #####:  346:                if (c->last_cmd_time < oldest_last_cmd)
        -:  347:                    oldest_last_cmd = c->last_cmd_time;
        -:  348:            }
        -:  349:        }
        -:  350:
        -:  351:        /* This is the soonest we could have another connection time out */
        2:  352:        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;
        2:  353:        if (sleep_time <= 0)
        -:  354:            sleep_time = 1;
        -:  355:
        2:  356:        if (settings.verbose > 2)
    #####:  357:            fprintf(stderr,
        -:  358:                    "idle timeout thread finished pass, sleeping for %ds\n",
        -:  359:                    sleep_time);
        2:  360:        usleep((useconds_t) sleep_time * 1000000);
        -:  361:    }
        -:  362:
        -:  363:    return NULL;
        -:  364:}
        -:  365:
        1:  366:static int start_conn_timeout_thread() {
        1:  367:    int ret;
        -:  368:
        1:  369:    if (settings.idle_timeout == 0)
        -:  370:        return -1;
        -:  371:
        1:  372:    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        -:  373:        conn_timeout_thread, NULL)) != 0) {
    #####:  374:        fprintf(stderr, "Can't create idle connection timeout thread: %s\n",
        -:  375:            strerror(ret));
    #####:  376:        return -1;
        -:  377:    }
        -:  378:
        -:  379:    return 0;
        -:  380:}
        -:  381:
        -:  382:/*
        -:  383: * Initializes the connections array. We don't actually allocate connection
        -:  384: * structures until they're needed, so as to avoid wasting memory when the
        -:  385: * maximum connection count is much higher than the actual number of
        -:  386: * connections.
        -:  387: *
        -:  388: * This does end up wasting a few pointers' worth of memory for FDs that are
        -:  389: * used for things other than connections, but that's worth it in exchange for
        -:  390: * being able to directly index the conns array by FD.
        -:  391: */
       89:  392:static void conn_init(void) {
        -:  393:    /* We're unlikely to see an FD much higher than maxconns. */
       89:  394:    int next_fd = dup(1);
       89:  395:    int headroom = 10;      /* account for extra unexpected open FDs */
       89:  396:    struct rlimit rl;
        -:  397:
       89:  398:    max_fds = settings.maxconns + headroom + next_fd;
        -:  399:
        -:  400:    /* But if possible, get the actual highest FD we can possibly ever see. */
       89:  401:    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
       89:  402:        max_fds = rl.rlim_max;
        -:  403:    } else {
    #####:  404:        fprintf(stderr, "Failed to query maximum file descriptor; "
        -:  405:                        "falling back to maxconns\n");
        -:  406:    }
        -:  407:
       89:  408:    close(next_fd);
        -:  409:
       89:  410:    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
    #####:  411:        fprintf(stderr, "Failed to allocate connection structures\n");
        -:  412:        /* This is unrecoverable so bail out early. */
    #####:  413:        exit(1);
        -:  414:    }
       89:  415:}
        -:  416:
      23*:  417:static const char *prot_text(enum protocol prot) {
      23*:  418:    char *rv = "unknown";
      23*:  419:    switch(prot) {
       3*:  420:        case ascii_prot:
       3*:  421:            rv = "ascii";
       3*:  422:            break;
       2*:  423:        case binary_prot:
       2*:  424:            rv = "binary";
       2*:  425:            break;
      18*:  426:        case negotiating_prot:
      18*:  427:            rv = "auto-negotiate";
      18*:  428:            break;
        -:  429:    }
      23*:  430:    return rv;
        -:  431:}
        -:  432:
        1:  433:void conn_close_idle(conn *c) {
        1:  434:    if (settings.idle_timeout > 0 &&
        1:  435:        (current_time - c->last_cmd_time) > settings.idle_timeout) {
        1:  436:        if (c->state != conn_new_cmd && c->state != conn_read) {
    #####:  437:            if (settings.verbose > 1)
    #####:  438:                fprintf(stderr,
        -:  439:                    "fd %d wants to timeout, but isn't in read state", c->sfd);
    #####:  440:            return;
        -:  441:        }
        -:  442:
        1:  443:        if (settings.verbose > 1)
    #####:  444:            fprintf(stderr, "Closing idle fd %d\n", c->sfd);
        -:  445:
        1:  446:        c->thread->stats.idle_kicks++;
        -:  447:
        1:  448:        conn_set_state(c, conn_closing);
        1:  449:        drive_machine(c);
        -:  450:    }
        -:  451:}
        -:  452:
        -:  453:/* bring conn back from a sidethread. could have had its event base moved. */
    #####:  454:void conn_worker_readd(conn *c) {
    #####:  455:    c->ev_flags = EV_READ | EV_PERSIST;
    #####:  456:    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    #####:  457:    event_base_set(c->thread->base, &c->event);
    #####:  458:    c->state = conn_new_cmd;
        -:  459:
    #####:  460:    if (event_add(&c->event, 0) == -1) {
    #####:  461:        perror("event_add");
        -:  462:    }
    #####:  463:}
        -:  464:
      914:  465:conn *conn_new(const int sfd, enum conn_states init_state,
        -:  466:                const int event_flags,
        -:  467:                const int read_buffer_size, enum network_transport transport,
        -:  468:                struct event_base *base) {
      914:  469:    conn *c;
        -:  470:
     914*:  471:    assert(sfd >= 0 && sfd < max_fds);
      914:  472:    c = conns[sfd];
        -:  473:
      914:  474:    if (NULL == c) {
      904:  475:        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
    #####:  476:            STATS_LOCK();
    #####:  477:            stats.malloc_fails++;
    #####:  478:            STATS_UNLOCK();
    #####:  479:            fprintf(stderr, "Failed to allocate connection object\n");
    #####:  480:            return NULL;
        -:  481:        }
      904:  482:        MEMCACHED_CONN_CREATE(c);
        -:  483:
      904:  484:        c->rbuf = c->wbuf = 0;
      904:  485:        c->ilist = 0;
      904:  486:        c->suffixlist = 0;
      904:  487:        c->iov = 0;
      904:  488:        c->msglist = 0;
      904:  489:        c->hdrbuf = 0;
        -:  490:
      904:  491:        c->rsize = read_buffer_size;
      904:  492:        c->wsize = DATA_BUFFER_SIZE;
      904:  493:        c->isize = ITEM_LIST_INITIAL;
      904:  494:        c->suffixsize = SUFFIX_LIST_INITIAL;
      904:  495:        c->iovsize = IOV_LIST_INITIAL;
      904:  496:        c->msgsize = MSG_LIST_INITIAL;
      904:  497:        c->hdrsize = 0;
        -:  498:
      904:  499:        c->rbuf = (char *)malloc((size_t)c->rsize);
      904:  500:        c->wbuf = (char *)malloc((size_t)c->wsize);
      904:  501:        c->ilist = (item **)malloc(sizeof(item *) * c->isize);
      904:  502:        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);
      904:  503:        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);
      904:  504:        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);
        -:  505:
      904:  506:        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
      904:  507:                c->msglist == 0 || c->suffixlist == 0) {
    #####:  508:            conn_free(c);
    #####:  509:            STATS_LOCK();
    #####:  510:            stats.malloc_fails++;
    #####:  511:            STATS_UNLOCK();
    #####:  512:            fprintf(stderr, "Failed to allocate buffers for connection\n");
    #####:  513:            return NULL;
        -:  514:        }
        -:  515:
      904:  516:        STATS_LOCK();
      904:  517:        stats_state.conn_structs++;
      904:  518:        STATS_UNLOCK();
        -:  519:
      904:  520:        c->sfd = sfd;
      904:  521:        conns[sfd] = c;
        -:  522:    }
        -:  523:
      914:  524:    c->transport = transport;
      914:  525:    c->protocol = settings.binding_protocol;
        -:  526:
        -:  527:    /* unix socket mode doesn't need this, so zeroed out.  but why
        -:  528:     * is this done for every command?  presumably for UDP
        -:  529:     * mode.  */
      914:  530:    if (!settings.socketpath) {
      909:  531:        c->request_addr_size = sizeof(c->request_addr);
        -:  532:    } else {
        5:  533:        c->request_addr_size = 0;
        -:  534:    }
        -:  535:
      914:  536:    if (transport == tcp_transport && init_state == conn_new_cmd) {
      106:  537:        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
        -:  538:                        &c->request_addr_size)) {
    #####:  539:            perror("getpeername");
    #####:  540:            memset(&c->request_addr, 0, sizeof(c->request_addr));
        -:  541:        }
        -:  542:    }
        -:  543:
      914:  544:    if (settings.verbose > 1) {
       33:  545:        if (init_state == conn_listening) {
       12:  546:            fprintf(stderr, "<%d server listening (%s)\n", sfd,
        -:  547:                prot_text(c->protocol));
       27:  548:        } else if (IS_UDP(transport)) {
       24:  549:            fprintf(stderr, "<%d server listening (udp)\n", sfd);
        3:  550:        } else if (c->protocol == negotiating_prot) {
        1:  551:            fprintf(stderr, "<%d new auto-negotiating client connection\n",
        -:  552:                    sfd);
        2:  553:        } else if (c->protocol == ascii_prot) {
        1:  554:            fprintf(stderr, "<%d new ascii client connection.\n", sfd);
        1:  555:        } else if (c->protocol == binary_prot) {
        1:  556:            fprintf(stderr, "<%d new binary client connection.\n", sfd);
        -:  557:        } else {
    #####:  558:            fprintf(stderr, "<%d new unknown (%d) client connection\n",
        -:  559:                sfd, c->protocol);
    #####:  560:            assert(false);
        -:  561:        }
        -:  562:    }
        -:  563:
      914:  564:    c->state = init_state;
      914:  565:    c->rlbytes = 0;
      914:  566:    c->cmd = -1;
      914:  567:    c->rbytes = c->wbytes = 0;
      914:  568:    c->wcurr = c->wbuf;
      914:  569:    c->rcurr = c->rbuf;
      914:  570:    c->ritem = 0;
      914:  571:    c->icurr = c->ilist;
      914:  572:    c->suffixcurr = c->suffixlist;
      914:  573:    c->ileft = 0;
      914:  574:    c->suffixleft = 0;
      914:  575:    c->iovused = 0;
      914:  576:    c->msgcurr = 0;
      914:  577:    c->msgused = 0;
      914:  578:    c->authenticated = false;
      914:  579:    c->last_cmd_time = current_time; /* initialize for idle kicker */
        -:  580:
      914:  581:    c->write_and_go = init_state;
      914:  582:    c->write_and_free = 0;
      914:  583:    c->item = 0;
        -:  584:
      914:  585:    c->noreply = false;
        -:  586:
      914:  587:    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
      914:  588:    event_base_set(base, &c->event);
      914:  589:    c->ev_flags = event_flags;
        -:  590:
      914:  591:    if (event_add(&c->event, 0) == -1) {
    #####:  592:        perror("event_add");
    #####:  593:        return NULL;
        -:  594:    }
        -:  595:
      914:  596:    STATS_LOCK();
      914:  597:    stats_state.curr_conns++;
      914:  598:    stats.total_conns++;
      914:  599:    STATS_UNLOCK();
        -:  600:
      914:  601:    MEMCACHED_CONN_ALLOCATE(c->sfd);
        -:  602:
      914:  603:    return c;
        -:  604:}
        -:  605:
   169266:  606:static void conn_release_items(conn *c) {
  169266*:  607:    assert(c != NULL);
        -:  608:
   169266:  609:    if (c->item) {
      791:  610:        item_remove(c->item);
      791:  611:        c->item = 0;
        -:  612:    }
        -:  613:
   200713:  614:    while (c->ileft > 0) {
    31447:  615:        item *it = *(c->icurr);
   31447*:  616:        assert((it->it_flags & ITEM_SLABBED) == 0);
    31447:  617:        item_remove(it);
    31447:  618:        c->icurr++;
    31447:  619:        c->ileft--;
        -:  620:    }
        -:  621:
   169266:  622:    if (c->suffixleft != 0) {
       33:  623:        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
       17:  624:            cache_free(c->thread->suffix_cache, *(c->suffixcurr));
        -:  625:        }
        -:  626:    }
        -:  627:
   169266:  628:    c->icurr = c->ilist;
   169266:  629:    c->suffixcurr = c->suffixlist;
   169266:  630:}
        -:  631:
       97:  632:static void conn_cleanup(conn *c) {
      97*:  633:    assert(c != NULL);
        -:  634:
       97:  635:    conn_release_items(c);
        -:  636:
       97:  637:    if (c->write_and_free) {
        2:  638:        free(c->write_and_free);
        2:  639:        c->write_and_free = 0;
        -:  640:    }
        -:  641:
       97:  642:    if (c->sasl_conn) {
    #####:  643:        assert(settings.sasl);
    #####:  644:        sasl_dispose(&c->sasl_conn);
    #####:  645:        c->sasl_conn = NULL;
        -:  646:    }
        -:  647:
       97:  648:    if (IS_UDP(c->transport)) {
    #####:  649:        conn_set_state(c, conn_read);
        -:  650:    }
       97:  651:}
        -:  652:
        -:  653:/*
        -:  654: * Frees a connection.
        -:  655: */
    #####:  656:void conn_free(conn *c) {
    #####:  657:    if (c) {
    #####:  658:        assert(c != NULL);
    #####:  659:        assert(c->sfd >= 0 && c->sfd < max_fds);
        -:  660:
    #####:  661:        MEMCACHED_CONN_DESTROY(c);
    #####:  662:        conns[c->sfd] = NULL;
    #####:  663:        if (c->hdrbuf)
    #####:  664:            free(c->hdrbuf);
    #####:  665:        if (c->msglist)
    #####:  666:            free(c->msglist);
    #####:  667:        if (c->rbuf)
    #####:  668:            free(c->rbuf);
    #####:  669:        if (c->wbuf)
    #####:  670:            free(c->wbuf);
    #####:  671:        if (c->ilist)
    #####:  672:            free(c->ilist);
    #####:  673:        if (c->suffixlist)
    #####:  674:            free(c->suffixlist);
    #####:  675:        if (c->iov)
    #####:  676:            free(c->iov);
    #####:  677:        free(c);
        -:  678:    }
    #####:  679:}
        -:  680:
       97:  681:static void conn_close(conn *c) {
      97*:  682:    assert(c != NULL);
        -:  683:
        -:  684:    /* delete the event, the socket and the conn */
       97:  685:    event_del(&c->event);
        -:  686:
       97:  687:    if (settings.verbose > 1)
        3:  688:        fprintf(stderr, "<%d connection closed.\n", c->sfd);
        -:  689:
       97:  690:    conn_cleanup(c);
        -:  691:
       97:  692:    MEMCACHED_CONN_RELEASE(c->sfd);
       97:  693:    conn_set_state(c, conn_closed);
       97:  694:    close(c->sfd);
        -:  695:
       97:  696:    pthread_mutex_lock(&conn_lock);
       97:  697:    allow_new_conns = true;
       97:  698:    pthread_mutex_unlock(&conn_lock);
        -:  699:
       97:  700:    STATS_LOCK();
       97:  701:    stats_state.curr_conns--;
       97:  702:    STATS_UNLOCK();
        -:  703:
       97:  704:    return;
        -:  705:}
        -:  706:
        -:  707:/*
        -:  708: * Shrinks a connection's buffers if they're too big.  This prevents
        -:  709: * periodic large "get" requests from permanently chewing lots of server
        -:  710: * memory.
        -:  711: *
        -:  712: * This should only be called in between requests since it can wipe output
        -:  713: * buffers!
        -:  714: */
   277231:  715:static void conn_shrink(conn *c) {
  277231*:  716:    assert(c != NULL);
        -:  717:
   277231:  718:    if (IS_UDP(c->transport))
        -:  719:        return;
        -:  720:
   277214:  721:    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
    12697:  722:        char *newbuf;
        -:  723:
    12697:  724:        if (c->rcurr != c->rbuf)
    12697:  725:            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);
        -:  726:
    12697:  727:        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);
        -:  728:
    12697:  729:        if (newbuf) {
    12697:  730:            c->rbuf = newbuf;
    12697:  731:            c->rsize = DATA_BUFFER_SIZE;
        -:  732:        }
        -:  733:        /* TODO check other branch... */
    12697:  734:        c->rcurr = c->rbuf;
        -:  735:    }
        -:  736:
   277214:  737:    if (c->isize > ITEM_LIST_HIGHWAT) {
    #####:  738:        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
    #####:  739:        if (newbuf) {
    #####:  740:            c->ilist = newbuf;
    #####:  741:            c->isize = ITEM_LIST_INITIAL;
        -:  742:        }
        -:  743:    /* TODO check error condition? */
        -:  744:    }
        -:  745:
   277214:  746:    if (c->msgsize > MSG_LIST_HIGHWAT) {
    #####:  747:        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
    #####:  748:        if (newbuf) {
    #####:  749:            c->msglist = newbuf;
    #####:  750:            c->msgsize = MSG_LIST_INITIAL;
        -:  751:        }
        -:  752:    /* TODO check error condition? */
        -:  753:    }
        -:  754:
   277214:  755:    if (c->iovsize > IOV_LIST_HIGHWAT) {
    #####:  756:        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
    #####:  757:        if (newbuf) {
    #####:  758:            c->iov = newbuf;
    #####:  759:            c->iovsize = IOV_LIST_INITIAL;
        -:  760:        }
        -:  761:    /* TODO check return value */
        -:  762:    }
        -:  763:}
        -:  764:
        -:  765:/**
        -:  766: * Convert a state name to a human readable form.
        -:  767: */
      15*:  768:static const char *state_text(enum conn_states state) {
      15*:  769:    const char* const statenames[] = { "conn_listening",
        -:  770:                                       "conn_new_cmd",
        -:  771:                                       "conn_waiting",
        -:  772:                                       "conn_read",
        -:  773:                                       "conn_parse_cmd",
        -:  774:                                       "conn_write",
        -:  775:                                       "conn_nread",
        -:  776:                                       "conn_swallow",
        -:  777:                                       "conn_closing",
        -:  778:                                       "conn_mwrite",
        -:  779:                                       "conn_closed",
        -:  780:                                       "conn_watch" };
      15*:  781:    return statenames[state];
        -:  782:}
        -:  783:
        -:  784:/*
        -:  785: * Sets a connection's current state in the state machine. Any special
        -:  786: * processing that needs to happen on certain state transitions can
        -:  787: * happen here.
        -:  788: */
  1283123:  789:static void conn_set_state(conn *c, enum conn_states state) {
 1283123*:  790:    assert(c != NULL);
 1283123*:  791:    assert(state >= conn_listening && state < conn_max_state);
        -:  792:
  1283123:  793:    if (state != c->state) {
  1262793:  794:        if (settings.verbose > 2) {
    #####:  795:            fprintf(stderr, "%d: going from %s to %s\n",
        -:  796:                    c->sfd, state_text(c->state),
        -:  797:                    state_text(state));
        -:  798:        }
        -:  799:
  1262793:  800:        if (state == conn_write || state == conn_mwrite) {
  1262793:  801:            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
        -:  802:        }
  1262793:  803:        c->state = state;
        -:  804:    }
  1283123:  805:}
        -:  806:
        -:  807:/*
        -:  808: * Ensures that there is room for another struct iovec in a connection's
        -:  809: * iov list.
        -:  810: *
        -:  811: * Returns 0 on success, -1 on out-of-memory.
        -:  812: */
   483551:  813:static int ensure_iov_space(conn *c) {
  483551*:  814:    assert(c != NULL);
        -:  815:
   483551:  816:    if (c->iovused >= c->iovsize) {
    #####:  817:        int i, iovnum;
    #####:  818:        struct iovec *new_iov = (struct iovec *)realloc(c->iov,
    #####:  819:                                (c->iovsize * 2) * sizeof(struct iovec));
    #####:  820:        if (! new_iov) {
    #####:  821:            STATS_LOCK();
    #####:  822:            stats.malloc_fails++;
    #####:  823:            STATS_UNLOCK();
    #####:  824:            return -1;
        -:  825:        }
    #####:  826:        c->iov = new_iov;
    #####:  827:        c->iovsize *= 2;
        -:  828:
        -:  829:        /* Point all the msghdr structures at the new list. */
    #####:  830:        for (i = 0, iovnum = 0; i < c->msgused; i++) {
    #####:  831:            c->msglist[i].msg_iov = &c->iov[iovnum];
    #####:  832:            iovnum += c->msglist[i].msg_iovlen;
        -:  833:        }
        -:  834:    }
        -:  835:
        -:  836:    return 0;
        -:  837:}
        -:  838:
        -:  839:
        -:  840:/*
        -:  841: * Adds data to the list of pending data that will be written out to a
        -:  842: * connection.
        -:  843: *
        -:  844: * Returns 0 on success, -1 on out-of-memory.
        -:  845: */
        -:  846:
   421858:  847:static int add_iov(conn *c, const void *buf, int len) {
   421858:  848:    struct msghdr *m;
   421858:  849:    int leftover;
   421858:  850:    bool limit_to_mtu;
        -:  851:
  421858*:  852:    assert(c != NULL);
        -:  853:
   483551:  854:    do {
   483551:  855:        m = &c->msglist[c->msgused - 1];
        -:  856:
        -:  857:        /*
        -:  858:         * Limit UDP packets, and the first payloads of TCP replies, to
        -:  859:         * UDP_MAX_PAYLOAD_SIZE bytes.
        -:  860:         */
   483551:  861:        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);
        -:  862:
        -:  863:        /* We may need to start a new msghdr if this one is full. */
   483551:  864:        if (m->msg_iovlen == IOV_MAX ||
   362558:  865:            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {
    31076:  866:            add_msghdr(c);
    31076:  867:            m = &c->msglist[c->msgused - 1];
        -:  868:        }
        -:  869:
   483551:  870:        if (ensure_iov_space(c) != 0)
        -:  871:            return -1;
        -:  872:
        -:  873:        /* If the fragment is too big to fit in the datagram, split it up */
   483551:  874:        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
    61693:  875:            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
    61693:  876:            len -= leftover;
        -:  877:        } else {
        -:  878:            leftover = 0;
        -:  879:        }
        -:  880:
   483551:  881:        m = &c->msglist[c->msgused - 1];
   483551:  882:        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
   483551:  883:        m->msg_iov[m->msg_iovlen].iov_len = len;
        -:  884:
   483551:  885:        c->msgbytes += len;
   483551:  886:        c->iovused++;
   483551:  887:        m->msg_iovlen++;
        -:  888:
   483551:  889:        buf = ((char *)buf) + len;
   483551:  890:        len = leftover;
   483551:  891:    } while (leftover > 0);
        -:  892:
        -:  893:    return 0;
        -:  894:}
        -:  895:
    18682:  896:static int add_chunked_item_iovs(conn *c, item *it, int len) {
   18682*:  897:    assert(it->it_flags & ITEM_CHUNKED);
    18682:  898:    item_chunk *ch = (item_chunk *) ITEM_data(it);
    97012:  899:    while (ch) {
    78330:  900:        int todo = (len > ch->used) ? ch->used : len;
    78330:  901:        if (add_iov(c, ch->data, todo) != 0) {
        -:  902:            return -1;
        -:  903:        }
    78330:  904:        ch = ch->next;
    78330:  905:        len -= todo;
        -:  906:    }
        -:  907:    return 0;
        -:  908:}
        -:  909:
        -:  910:/*
        -:  911: * Constructs a set of UDP headers and attaches them to the outgoing messages.
        -:  912: */
       39:  913:static int build_udp_headers(conn *c) {
       39:  914:    int i;
       39:  915:    unsigned char *hdr;
        -:  916:
      39*:  917:    assert(c != NULL);
        -:  918:
       39:  919:    if (c->msgused > c->hdrsize) {
        3:  920:        void *new_hdrbuf;
        3:  921:        if (c->hdrbuf) {
    #####:  922:            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);
        -:  923:        } else {
        3:  924:            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);
        -:  925:        }
        -:  926:
        3:  927:        if (! new_hdrbuf) {
    #####:  928:            STATS_LOCK();
    #####:  929:            stats.malloc_fails++;
    #####:  930:            STATS_UNLOCK();
    #####:  931:            return -1;
        -:  932:        }
        3:  933:        c->hdrbuf = (unsigned char *)new_hdrbuf;
        3:  934:        c->hdrsize = c->msgused * 2;
        -:  935:    }
        -:  936:
       39:  937:    hdr = c->hdrbuf;
       78:  938:    for (i = 0; i < c->msgused; i++) {
       39:  939:        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;
       39:  940:        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;
       39:  941:        *hdr++ = c->request_id / 256;
       39:  942:        *hdr++ = c->request_id % 256;
       39:  943:        *hdr++ = i / 256;
       39:  944:        *hdr++ = i % 256;
       39:  945:        *hdr++ = c->msgused / 256;
       39:  946:        *hdr++ = c->msgused % 256;
       39:  947:        *hdr++ = 0;
       39:  948:        *hdr++ = 0;
      39*:  949:        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);
        -:  950:    }
        -:  951:
        -:  952:    return 0;
        -:  953:}
        -:  954:
        -:  955:
    85083:  956:static void out_string(conn *c, const char *str) {
    85083:  957:    size_t len;
        -:  958:
   85083*:  959:    assert(c != NULL);
        -:  960:
    85083:  961:    if (c->noreply) {
    65163:  962:        if (settings.verbose > 1)
    #####:  963:            fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
    65163:  964:        c->noreply = false;
    65163:  965:        conn_set_state(c, conn_new_cmd);
    65163:  966:        return;
        -:  967:    }
        -:  968:
    19920:  969:    if (settings.verbose > 1)
    #####:  970:        fprintf(stderr, ">%d %s\n", c->sfd, str);
        -:  971:
        -:  972:    /* Nuke a partial output... */
    19920:  973:    c->msgcurr = 0;
    19920:  974:    c->msgused = 0;
    19920:  975:    c->iovused = 0;
    19920:  976:    add_msghdr(c);
        -:  977:
    19920:  978:    len = strlen(str);
    19920:  979:    if ((len + 2) > c->wsize) {
        -:  980:        /* ought to be always enough. just fail for simplicity */
    #####:  981:        str = "SERVER_ERROR output line too long";
    #####:  982:        len = strlen(str);
        -:  983:    }
        -:  984:
    19920:  985:    memcpy(c->wbuf, str, len);
    19920:  986:    memcpy(c->wbuf + len, "\r\n", 2);
    19920:  987:    c->wbytes = len + 2;
    19920:  988:    c->wcurr = c->wbuf;
        -:  989:
    19920:  990:    conn_set_state(c, conn_write);
    19920:  991:    c->write_and_go = conn_new_cmd;
    19920:  992:    return;
        -:  993:}
        -:  994:
        -:  995:/*
        -:  996: * Outputs a protocol-specific "out of memory" error. For ASCII clients,
        -:  997: * this is equivalent to out_string().
        -:  998: */
    52191:  999:static void out_of_memory(conn *c, char *ascii_error) {
    52191: 1000:    const static char error_prefix[] = "SERVER_ERROR ";
    52191: 1001:    const static int error_prefix_len = sizeof(error_prefix) - 1;
        -: 1002:
    52191: 1003:    if (c->protocol == binary_prot) {
        -: 1004:        /* Strip off the generic error prefix; it's irrelevant in binary */
    52182: 1005:        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
    52182: 1006:            ascii_error += error_prefix_len;
        -: 1007:        }
    52182: 1008:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
        -: 1009:    } else {
        9: 1010:        out_string(c, ascii_error);
        -: 1011:    }
    52191: 1012:}
        -: 1013:
        -: 1014:/*
        -: 1015: * we get here after reading the value in set/add/replace commands. The command
        -: 1016: * has been stored in c->cmd, and the item is ready in c->item.
        -: 1017: */
    82079: 1018:static void complete_nread_ascii(conn *c) {
   82079*: 1019:    assert(c != NULL);
        -: 1020:
    82079: 1021:    item *it = c->item;
    82079: 1022:    int comm = c->cmd;
    82079: 1023:    enum store_item_type ret;
    82079: 1024:    bool is_valid = false;
        -: 1025:
    82079: 1026:    pthread_mutex_lock(&c->thread->stats.mutex);
    82079: 1027:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    82079: 1028:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1029:
    82079: 1030:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    76459: 1031:        if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) == 0) {
        -: 1032:            is_valid = true;
        -: 1033:        }
        -: 1034:    } else {
     5620: 1035:        char buf[2];
        -: 1036:        /* should point to the final item chunk */
     5620: 1037:        item_chunk *ch = (item_chunk *) c->ritem;
    5620*: 1038:        assert(ch->used != 0);
        -: 1039:        /* :( We need to look at the last two bytes. This could span two
        -: 1040:         * chunks.
        -: 1041:         */
     5620: 1042:        if (ch->used > 1) {
     5620: 1043:            buf[0] = ch->data[ch->used - 2];
     5620: 1044:            buf[1] = ch->data[ch->used - 1];
        -: 1045:        } else {
    #####: 1046:            assert(ch->prev);
    #####: 1047:            assert(ch->used == 1);
    #####: 1048:            buf[0] = ch->prev->data[ch->prev->used - 1];
    #####: 1049:            buf[1] = ch->data[ch->used - 1];
        -: 1050:        }
     5620: 1051:        if (strncmp(buf, "\r\n", 2) == 0) {
     5620: 1052:            is_valid = true;
        -: 1053:        } else {
    #####: 1054:            assert(1 == 0);
        -: 1055:        }
        -: 1056:    }
        -: 1057:
    5620*: 1058:    if (!is_valid) {
    #####: 1059:        out_string(c, "CLIENT_ERROR bad data chunk");
        -: 1060:    } else {
    82079: 1061:      ret = store_item(it, comm, c);
        -: 1062:
        -: 1063:#ifdef ENABLE_DTRACE
        -: 1064:      uint64_t cas = ITEM_get_cas(it);
        -: 1065:      switch (c->cmd) {
        -: 1066:      case NREAD_ADD:
        -: 1067:          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1068:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1069:          break;
        -: 1070:      case NREAD_REPLACE:
        -: 1071:          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1072:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1073:          break;
        -: 1074:      case NREAD_APPEND:
        -: 1075:          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1076:                                   (ret == 1) ? it->nbytes : -1, cas);
        -: 1077:          break;
        -: 1078:      case NREAD_PREPEND:
        -: 1079:          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1080:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1081:          break;
        -: 1082:      case NREAD_SET:
        -: 1083:          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1084:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1085:          break;
        -: 1086:      case NREAD_CAS:
        -: 1087:          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
        -: 1088:                                cas);
        -: 1089:          break;
        -: 1090:      }
        -: 1091:#endif
        -: 1092:
    82079: 1093:      switch (ret) {
    82068: 1094:      case STORED:
    82068: 1095:          out_string(c, "STORED");
    82068: 1096:          break;
        5: 1097:      case EXISTS:
        5: 1098:          out_string(c, "EXISTS");
        5: 1099:          break;
        2: 1100:      case NOT_FOUND:
        2: 1101:          out_string(c, "NOT_FOUND");
        2: 1102:          break;
        4: 1103:      case NOT_STORED:
        4: 1104:          out_string(c, "NOT_STORED");
        4: 1105:          break;
    #####: 1106:      default:
    #####: 1107:          out_string(c, "SERVER_ERROR Unhandled storage type.");
        -: 1108:      }
        -: 1109:
        -: 1110:    }
        -: 1111:
    82079: 1112:    item_remove(c->item);       /* release the c->item reference */
    82078: 1113:    c->item = 0;
    82078: 1114:}
        -: 1115:
        -: 1116:/**
        -: 1117: * get a pointer to the start of the request struct for the current command
        -: 1118: */
    72741: 1119:static void* binary_get_request(conn *c) {
    72741: 1120:    char *ret = c->rcurr;
    72741: 1121:    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +
    72741: 1122:            c->binary_header.request.extlen);
        -: 1123:
   72741*: 1124:    assert(ret >= c->rbuf);
    72741: 1125:    return ret;
        -: 1126:}
        -: 1127:
        -: 1128:/**
        -: 1129: * get a pointer to the key in this request
        -: 1130: */
   73646*: 1131:static char* binary_get_key(conn *c) {
   73646*: 1132:    return c->rcurr - (c->binary_header.request.keylen);
        -: 1133:}
        -: 1134:
    56954: 1135:static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
    56954: 1136:    protocol_binary_response_header* header;
        -: 1137:
   56954*: 1138:    assert(c);
        -: 1139:
    56954: 1140:    c->msgcurr = 0;
    56954: 1141:    c->msgused = 0;
    56954: 1142:    c->iovused = 0;
    56954: 1143:    if (add_msghdr(c) != 0) {
        -: 1144:        /* This should never run out of memory because iov and msg lists
        -: 1145:         * have minimum sizes big enough to hold an error response.
        -: 1146:         */
    #####: 1147:        out_of_memory(c, "SERVER_ERROR out of memory adding binary header");
    #####: 1148:        return;
        -: 1149:    }
        -: 1150:
    56954: 1151:    header = (protocol_binary_response_header *)c->wbuf;
        -: 1152:
    56954: 1153:    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
    56954: 1154:    header->response.opcode = c->binary_header.request.opcode;
    56954: 1155:    header->response.keylen = (uint16_t)htons(key_len);
        -: 1156:
    56954: 1157:    header->response.extlen = (uint8_t)hdr_len;
    56954: 1158:    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
    56954: 1159:    header->response.status = (uint16_t)htons(err);
        -: 1160:
    56954: 1161:    header->response.bodylen = htonl(body_len);
    56954: 1162:    header->response.opaque = c->opaque;
    56954: 1163:    header->response.cas = htonll(c->cas);
        -: 1164:
    56954: 1165:    if (settings.verbose > 1) {
    #####: 1166:        int ii;
    #####: 1167:        fprintf(stderr, ">%d Writing bin response:", c->sfd);
    #####: 1168:        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
    #####: 1169:            if (ii % 4 == 0) {
    #####: 1170:                fprintf(stderr, "\n>%d  ", c->sfd);
        -: 1171:            }
    #####: 1172:            fprintf(stderr, " 0x%02x", header->bytes[ii]);
        -: 1173:        }
    #####: 1174:        fprintf(stderr, "\n");
        -: 1175:    }
        -: 1176:
    56954: 1177:    add_iov(c, c->wbuf, sizeof(header->response));
        -: 1178:}
        -: 1179:
        -: 1180:/**
        -: 1181: * Writes a binary error response. If errstr is supplied, it is used as the
        -: 1182: * error text; otherwise a generic description of the error status code is
        -: 1183: * included.
        -: 1184: */
    55675: 1185:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -: 1186:                            const char *errstr, int swallow) {
    55675: 1187:    size_t len;
        -: 1188:
    55675: 1189:    if (!errstr) {
     3493: 1190:        switch (err) {
        -: 1191:        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
        -: 1192:            errstr = "Out of memory";
        -: 1193:            break;
     3266: 1194:        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
     3266: 1195:            errstr = "Unknown command";
     3266: 1196:            break;
      141: 1197:        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
      141: 1198:            errstr = "Not found";
      141: 1199:            break;
        1: 1200:        case PROTOCOL_BINARY_RESPONSE_EINVAL:
        1: 1201:            errstr = "Invalid arguments";
        1: 1202:            break;
       21: 1203:        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
       21: 1204:            errstr = "Data exists for key.";
       21: 1205:            break;
        1: 1206:        case PROTOCOL_BINARY_RESPONSE_E2BIG:
        1: 1207:            errstr = "Too large.";
        1: 1208:            break;
        2: 1209:        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
        2: 1210:            errstr = "Non-numeric server-side value for incr or decr";
        2: 1211:            break;
       61: 1212:        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
       61: 1213:            errstr = "Not stored.";
       61: 1214:            break;
    #####: 1215:        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
    #####: 1216:            errstr = "Auth failure.";
    #####: 1217:            break;
        -: 1218:        default:
    #####: 1219:            assert(false);
        -: 1220:            errstr = "UNHANDLED ERROR";
        -: 1221:            fprintf(stderr, ">%d UNHANDLED ERROR: %d\n", c->sfd, err);
        -: 1222:        }
    52182: 1223:    }
        -: 1224:
    55675: 1225:    if (settings.verbose > 1) {
    #####: 1226:        fprintf(stderr, ">%d Writing an error: %s\n", c->sfd, errstr);
        -: 1227:    }
        -: 1228:
    55675: 1229:    len = strlen(errstr);
    55675: 1230:    add_bin_header(c, err, 0, 0, len);
    55675: 1231:    if (len > 0) {
    55675: 1232:        add_iov(c, errstr, len);
        -: 1233:    }
    55675: 1234:    conn_set_state(c, conn_mwrite);
    55675: 1235:    if(swallow > 0) {
        1: 1236:        c->sbytes = swallow;
        1: 1237:        c->write_and_go = conn_swallow;
        -: 1238:    } else {
    55674: 1239:        c->write_and_go = conn_new_cmd;
        -: 1240:    }
    55675: 1241:}
        -: 1242:
        -: 1243:/* Form and send a response to a command over the binary protocol */
    20443: 1244:static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    20443: 1245:    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        -: 1246:        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
      463: 1247:        add_bin_header(c, 0, hlen, keylen, dlen);
      463: 1248:        if(dlen > 0) {
       87: 1249:            add_iov(c, d, dlen);
        -: 1250:        }
      463: 1251:        conn_set_state(c, conn_mwrite);
      463: 1252:        c->write_and_go = conn_new_cmd;
        -: 1253:    } else {
    19980: 1254:        conn_set_state(c, conn_new_cmd);
        -: 1255:    }
    20443: 1256:}
        -: 1257:
      126: 1258:static void complete_incr_bin(conn *c) {
      126: 1259:    item *it;
      126: 1260:    char *key;
      126: 1261:    size_t nkey;
        -: 1262:    /* Weird magic in add_delta forces me to pad here */
      126: 1263:    char tmpbuf[INCR_MAX_STORAGE_LEN];
      126: 1264:    uint64_t cas = 0;
        -: 1265:
      126: 1266:    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;
      126: 1267:    protocol_binary_request_incr* req = binary_get_request(c);
        -: 1268:
      126: 1269:    assert(c != NULL);
     126*: 1270:    assert(c->wsize >= sizeof(*rsp));
        -: 1271:
        -: 1272:    /* fix byteorder in the request */
      126: 1273:    req->message.body.delta = ntohll(req->message.body.delta);
      126: 1274:    req->message.body.initial = ntohll(req->message.body.initial);
      126: 1275:    req->message.body.expiration = ntohl(req->message.body.expiration);
      126: 1276:    key = binary_get_key(c);
      126: 1277:    nkey = c->binary_header.request.keylen;
        -: 1278:
      126: 1279:    if (settings.verbose > 1) {
    #####: 1280:        int i;
    #####: 1281:        fprintf(stderr, "incr ");
        -: 1282:
    #####: 1283:        for (i = 0; i < nkey; i++) {
    #####: 1284:            fprintf(stderr, "%c", key[i]);
        -: 1285:        }
     126*: 1286:        fprintf(stderr, " %lld, %llu, %d\n",
    #####: 1287:                (long long)req->message.body.delta,
    #####: 1288:                (long long)req->message.body.initial,
        -: 1289:                req->message.body.expiration);
        -: 1290:    }
        -: 1291:
      126: 1292:    if (c->binary_header.request.cas != 0) {
    #####: 1293:        cas = c->binary_header.request.cas;
        -: 1294:    }
      126: 1295:    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,
      126: 1296:                     req->message.body.delta, tmpbuf,
        -: 1297:                     &cas)) {
       57: 1298:    case OK:
       57: 1299:        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
       57: 1300:        if (cas) {
       57: 1301:            c->cas = cas;
        -: 1302:        }
       57: 1303:        write_bin_response(c, &rsp->message.body, 0, 0,
        -: 1304:                           sizeof(rsp->message.body.value));
       57: 1305:        break;
        2: 1306:    case NON_NUMERIC:
        2: 1307:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);
        2: 1308:        break;
    #####: 1309:    case EOM:
    #####: 1310:        out_of_memory(c, "SERVER_ERROR Out of memory incrementing value");
    #####: 1311:        break;
       67: 1312:    case DELTA_ITEM_NOT_FOUND:
       67: 1313:        if (req->message.body.expiration != 0xffffffff) {
        -: 1314:            /* Save some room for the response */
       67: 1315:            rsp->message.body.value = htonll(req->message.body.initial);
        -: 1316:
       67: 1317:            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, "%llu",
       67: 1318:                (unsigned long long)req->message.body.initial);
       67: 1319:            int res = strlen(tmpbuf);
       67: 1320:            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
        -: 1321:                            res + 2);
        -: 1322:
       67: 1323:            if (it != NULL) {
       67: 1324:                memcpy(ITEM_data(it), tmpbuf, res);
       67: 1325:                memcpy(ITEM_data(it) + res, "\r\n", 2);
        -: 1326:
       67: 1327:                if (store_item(it, NREAD_ADD, c)) {
       67: 1328:                    c->cas = ITEM_get_cas(it);
       67: 1329:                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
        -: 1330:                } else {
    #####: 1331:                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
        -: 1332:                                    NULL, 0);
        -: 1333:                }
       67: 1334:                item_remove(it);         /* release our reference */
        -: 1335:            } else {
    #####: 1336:                out_of_memory(c,
        -: 1337:                        "SERVER_ERROR Out of memory allocating new item");
        -: 1338:            }
        -: 1339:        } else {
    #####: 1340:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1341:            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
    #####: 1342:                c->thread->stats.incr_misses++;
        -: 1343:            } else {
    #####: 1344:                c->thread->stats.decr_misses++;
        -: 1345:            }
    #####: 1346:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1347:
    #####: 1348:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1349:        }
        -: 1350:        break;
    #####: 1351:    case DELTA_ITEM_CAS_MISMATCH:
    #####: 1352:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1353:        break;
        -: 1354:    }
      126: 1355:}
        -: 1356:
    20330: 1357:static void complete_update_bin(conn *c) {
    20330: 1358:    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
    20330: 1359:    enum store_item_type ret = NOT_STORED;
   20330*: 1360:    assert(c != NULL);
        -: 1361:
    20330: 1362:    item *it = c->item;
        -: 1363:
    20330: 1364:    pthread_mutex_lock(&c->thread->stats.mutex);
    20330: 1365:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    20330: 1366:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1367:
        -: 1368:    /* We don't actually receive the trailing two characters in the bin
        -: 1369:     * protocol, so we're going to just set them here */
    20330: 1370:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    20129: 1371:        *(ITEM_data(it) + it->nbytes - 2) = '\r';
    20129: 1372:        *(ITEM_data(it) + it->nbytes - 1) = '\n';
        -: 1373:    } else {
     201*: 1374:        assert(c->ritem);
      201: 1375:        item_chunk *ch = (item_chunk *) c->ritem;
      201: 1376:        if (ch->size == ch->used)
        1: 1377:            ch = ch->next;
      201: 1378:        if (ch->size - ch->used > 1) {
      200: 1379:            ch->data[ch->used + 1] = '\r';
      200: 1380:            ch->data[ch->used + 2] = '\n';
      200: 1381:            ch->used += 2;
        -: 1382:        } else {
        1: 1383:            ch->data[ch->used + 1] = '\r';
        1: 1384:            ch->next->data[0] = '\n';
        1: 1385:            ch->used++;
        1: 1386:            ch->next->used++;
       1*: 1387:            assert(ch->size == ch->used);
        -: 1388:        }
        -: 1389:    }
        -: 1390:
    20330: 1391:    ret = store_item(it, c->cmd, c);
        -: 1392:
        -: 1393:#ifdef ENABLE_DTRACE
        -: 1394:    uint64_t cas = ITEM_get_cas(it);
        -: 1395:    switch (c->cmd) {
        -: 1396:    case NREAD_ADD:
        -: 1397:        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1398:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1399:        break;
        -: 1400:    case NREAD_REPLACE:
        -: 1401:        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1402:                                  (ret == STORED) ? it->nbytes : -1, cas);
        -: 1403:        break;
        -: 1404:    case NREAD_APPEND:
        -: 1405:        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1406:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1407:        break;
        -: 1408:    case NREAD_PREPEND:
        -: 1409:        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1410:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1411:        break;
        -: 1412:    case NREAD_SET:
        -: 1413:        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1414:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1415:        break;
        -: 1416:    }
        -: 1417:#endif
        -: 1418:
    20330: 1419:    switch (ret) {
    20208: 1420:    case STORED:
        -: 1421:        /* Stored */
    20208: 1422:        write_bin_response(c, NULL, 0, 0, 0);
    20208: 1423:        break;
        2: 1424:    case EXISTS:
        2: 1425:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        2: 1426:        break;
        1: 1427:    case NOT_FOUND:
        1: 1428:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        1: 1429:        break;
      119: 1430:    case NOT_STORED:
        -: 1431:    case TOO_LARGE:
        -: 1432:    case NO_MEMORY:
      119: 1433:        if (c->cmd == NREAD_ADD) {
        -: 1434:            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
      100: 1435:        } else if(c->cmd == NREAD_REPLACE) {
        -: 1436:            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        -: 1437:        } else {
       61: 1438:            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        -: 1439:        }
      119: 1440:        write_bin_error(c, eno, NULL, 0);
        -: 1441:    }
        -: 1442:
    20330: 1443:    item_remove(c->item);       /* release the c->item reference */
    20330: 1444:    c->item = 0;
    20330: 1445:}
        -: 1446:
      947: 1447:static void process_bin_get_or_touch(conn *c) {
      947: 1448:    item *it;
        -: 1449:
      947: 1450:    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
      947: 1451:    char* key = binary_get_key(c);
      947: 1452:    size_t nkey = c->binary_header.request.keylen;
      947: 1453:    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
      947: 1454:                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
        -: 1455:                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
      947: 1456:    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
        -: 1457:                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
      947: 1458:    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
        -: 1459:
      947: 1460:    if (settings.verbose > 1) {
    #####: 1461:        fprintf(stderr, "<%d %s ", c->sfd, should_touch ? "TOUCH" : "GET");
    #####: 1462:        if (fwrite(key, 1, nkey, stderr)) {}
    #####: 1463:        fputc('\n', stderr);
        -: 1464:    }
        -: 1465:
      947: 1466:    if (should_touch) {
      100: 1467:        protocol_binary_request_touch *t = binary_get_request(c);
      100: 1468:        time_t exptime = ntohl(t->message.body.expiration);
        -: 1469:
      200: 1470:        it = item_touch(key, nkey, realtime(exptime), c);
        -: 1471:    } else {
      847: 1472:        it = item_get(key, nkey, c);
        -: 1473:    }
        -: 1474:
      947: 1475:    if (it) {
        -: 1476:        /* the length has two unnecessary bytes ("\r\n") */
      790: 1477:        uint16_t keylen = 0;
      790: 1478:        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);
        -: 1479:
      790: 1480:        item_update(it);
      790: 1481:        pthread_mutex_lock(&c->thread->stats.mutex);
      790: 1482:        if (should_touch) {
       27: 1483:            c->thread->stats.touch_cmds++;
       27: 1484:            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 1485:        } else {
      763: 1486:            c->thread->stats.get_cmds++;
      763: 1487:            c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;
        -: 1488:        }
      790: 1489:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1490:
      790: 1491:        if (should_touch) {
        -: 1492:            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
        -: 1493:                                    it->nbytes, ITEM_get_cas(it));
        -: 1494:        } else {
        -: 1495:            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
      790: 1496:                                  it->nbytes, ITEM_get_cas(it));
        -: 1497:        }
        -: 1498:
      790: 1499:        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
        2: 1500:            bodylen -= it->nbytes - 2;
      788: 1501:        } else if (should_return_key) {
       28: 1502:            bodylen += nkey;
       28: 1503:            keylen = nkey;
        -: 1504:        }
        -: 1505:
      790: 1506:        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
      790: 1507:        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));
        -: 1508:
        -: 1509:        // add the flags
      790: 1510:        rsp->message.body.flags = htonl(strtoul(ITEM_suffix(it), NULL, 10));
      790: 1511:        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));
        -: 1512:
      790: 1513:        if (should_return_key) {
       28: 1514:            add_iov(c, ITEM_key(it), nkey);
        -: 1515:        }
        -: 1516:
      790: 1517:        if (should_return_value) {
        -: 1518:            /* Add the data minus the CRLF */
      788: 1519:            if ((it->it_flags & ITEM_CHUNKED) == 0) {
      587: 1520:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1521:            } else {
      201: 1522:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1523:            }
        -: 1524:        }
        -: 1525:
      790: 1526:        conn_set_state(c, conn_mwrite);
      790: 1527:        c->write_and_go = conn_new_cmd;
        -: 1528:        /* Remember this command so we can garbage collect it later */
      790: 1529:        c->item = it;
        -: 1530:    } else {
      157: 1531:        pthread_mutex_lock(&c->thread->stats.mutex);
      157: 1532:        if (should_touch) {
       73: 1533:            c->thread->stats.touch_cmds++;
       73: 1534:            c->thread->stats.touch_misses++;
        -: 1535:        } else {
       84: 1536:            c->thread->stats.get_cmds++;
       84: 1537:            c->thread->stats.get_misses++;
        -: 1538:        }
      157: 1539:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1540:
      157: 1541:        if (should_touch) {
        -: 1542:            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        -: 1543:        } else {
      157: 1544:            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 1545:        }
        -: 1546:
      157: 1547:        if (c->noreply) {
       60: 1548:            conn_set_state(c, conn_new_cmd);
        -: 1549:        } else {
       97: 1550:            if (should_return_key) {
       26: 1551:                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
       26: 1552:                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1553:                        0, nkey, nkey);
       26: 1554:                memcpy(ofs, key, nkey);
       26: 1555:                add_iov(c, ofs, nkey);
       26: 1556:                conn_set_state(c, conn_mwrite);
       26: 1557:                c->write_and_go = conn_new_cmd;
        -: 1558:            } else {
       71: 1559:                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1560:                                NULL, 0);
        -: 1561:            }
        -: 1562:        }
        -: 1563:    }
        -: 1564:
      947: 1565:    if (settings.detail_enabled) {
      554: 1566:        stats_prefix_record_get(key, nkey, NULL != it);
        -: 1567:    }
      947: 1568:}
        -: 1569:
     1366: 1570:static void append_bin_stats(const char *key, const uint16_t klen,
        -: 1571:                             const char *val, const uint32_t vlen,
        -: 1572:                             conn *c) {
     1366: 1573:    char *buf = c->stats.buffer + c->stats.offset;
     1366: 1574:    uint32_t bodylen = klen + vlen;
     1366: 1575:    protocol_binary_response_header header = {
        -: 1576:        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        -: 1577:        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
     1366: 1578:        .response.keylen = (uint16_t)htons(klen),
        -: 1579:        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
     1366: 1580:        .response.bodylen = htonl(bodylen),
     1366: 1581:        .response.opaque = c->opaque
        -: 1582:    };
        -: 1583:
     1366: 1584:    memcpy(buf, header.bytes, sizeof(header.response));
     1366: 1585:    buf += sizeof(header.response);
        -: 1586:
     1366: 1587:    if (klen > 0) {
     1341: 1588:        memcpy(buf, key, klen);
     1341: 1589:        buf += klen;
        -: 1590:
     1341: 1591:        if (vlen > 0) {
     1341: 1592:            memcpy(buf, val, vlen);
        -: 1593:        }
        -: 1594:    }
        -: 1595:
     1366: 1596:    c->stats.offset += sizeof(header.response) + bodylen;
     1366: 1597:}
        -: 1598:
   167329: 1599:static void append_ascii_stats(const char *key, const uint16_t klen,
        -: 1600:                               const char *val, const uint32_t vlen,
        -: 1601:                               conn *c) {
   167329: 1602:    char *pos = c->stats.buffer + c->stats.offset;
   167329: 1603:    uint32_t nbytes = 0;
   167329: 1604:    int remaining = c->stats.size - c->stats.offset;
   167329: 1605:    int room = remaining - 1;
        -: 1606:
   167329: 1607:    if (klen == 0 && vlen == 0) {
     2802: 1608:        nbytes = snprintf(pos, room, "END\r\n");
   164527: 1609:    } else if (vlen == 0) {
    #####: 1610:        nbytes = snprintf(pos, room, "STAT %s\r\n", key);
        -: 1611:    } else {
   164527: 1612:        nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
        -: 1613:    }
        -: 1614:
   167329: 1615:    c->stats.offset += nbytes;
   167329: 1616:}
        -: 1617:
   168695: 1618:static bool grow_stats_buf(conn *c, size_t needed) {
   168695: 1619:    size_t nsize = c->stats.size;
   168695: 1620:    size_t available = nsize - c->stats.offset;
   168695: 1621:    bool rv = true;
        -: 1622:
        -: 1623:    /* Special case: No buffer -- need to allocate fresh */
   168695: 1624:    if (c->stats.buffer == NULL) {
     2827: 1625:        nsize = 1024;
     2827: 1626:        available = c->stats.size = c->stats.offset = 0;
        -: 1627:    }
        -: 1628:
   171547: 1629:    while (needed > available) {
    2852*: 1630:        assert(nsize > 0);
     2852: 1631:        nsize = nsize << 1;
     2852: 1632:        available = nsize - c->stats.offset;
        -: 1633:    }
        -: 1634:
   168695: 1635:    if (nsize != c->stats.size) {
     2852: 1636:        char *ptr = realloc(c->stats.buffer, nsize);
     2852: 1637:        if (ptr) {
     2852: 1638:            c->stats.buffer = ptr;
     2852: 1639:            c->stats.size = nsize;
        -: 1640:        } else {
    #####: 1641:            STATS_LOCK();
    #####: 1642:            stats.malloc_fails++;
    #####: 1643:            STATS_UNLOCK();
    #####: 1644:            rv = false;
        -: 1645:        }
        -: 1646:    }
        -: 1647:
   168695: 1648:    return rv;
        -: 1649:}
        -: 1650:
   168695: 1651:static void append_stats(const char *key, const uint16_t klen,
        -: 1652:                  const char *val, const uint32_t vlen,
        -: 1653:                  const void *cookie)
        -: 1654:{
        -: 1655:    /* value without a key is invalid */
   168695: 1656:    if (klen == 0 && vlen > 0) {
        -: 1657:        return ;
        -: 1658:    }
        -: 1659:
   168695: 1660:    conn *c = (conn*)cookie;
        -: 1661:
   168695: 1662:    if (c->protocol == binary_prot) {
     1366: 1663:        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
     1366: 1664:        if (!grow_stats_buf(c, needed)) {
        -: 1665:            return ;
        -: 1666:        }
     1366: 1667:        append_bin_stats(key, klen, val, vlen, c);
        -: 1668:    } else {
   167329: 1669:        size_t needed = vlen + klen + 10; // 10 == "STAT = \r\n"
   167329: 1670:        if (!grow_stats_buf(c, needed)) {
        -: 1671:            return ;
        -: 1672:        }
   167329: 1673:        append_ascii_stats(key, klen, val, vlen, c);
        -: 1674:    }
        -: 1675:
  168695*: 1676:    assert(c->stats.offset <= c->stats.size);
        -: 1677:}
        -: 1678:
       25: 1679:static void process_bin_stat(conn *c) {
       25: 1680:    char *subcommand = binary_get_key(c);
       25: 1681:    size_t nkey = c->binary_header.request.keylen;
        -: 1682:
       25: 1683:    if (settings.verbose > 1) {
    #####: 1684:        int ii;
    #####: 1685:        fprintf(stderr, "<%d STATS ", c->sfd);
    #####: 1686:        for (ii = 0; ii < nkey; ++ii) {
    #####: 1687:            fprintf(stderr, "%c", subcommand[ii]);
        -: 1688:        }
    #####: 1689:        fprintf(stderr, "\n");
        -: 1690:    }
        -: 1691:
       25: 1692:    if (nkey == 0) {
        -: 1693:        /* request all statistics */
       22: 1694:        server_stats(&append_stats, c);
       22: 1695:        (void)get_stats(NULL, 0, &append_stats, c);
        3: 1696:    } else if (strncmp(subcommand, "reset", 5) == 0) {
    #####: 1697:        stats_reset();
        3: 1698:    } else if (strncmp(subcommand, "settings", 8) == 0) {
        1: 1699:        process_stat_settings(&append_stats, c);
        2: 1700:    } else if (strncmp(subcommand, "detail", 6) == 0) {
        2: 1701:        char *subcmd_pos = subcommand + 6;
        2: 1702:        if (strncmp(subcmd_pos, " dump", 5) == 0) {
        1: 1703:            int len;
        1: 1704:            char *dump_buf = stats_prefix_dump(&len);
        1: 1705:            if (dump_buf == NULL || len <= 0) {
    #####: 1706:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
    #####: 1707:                return ;
        -: 1708:            } else {
        1: 1709:                append_stats("detailed", strlen("detailed"), dump_buf, len, c);
        1: 1710:                free(dump_buf);
        -: 1711:            }
        1: 1712:        } else if (strncmp(subcmd_pos, " on", 3) == 0) {
        1: 1713:            settings.detail_enabled = 1;
    #####: 1714:        } else if (strncmp(subcmd_pos, " off", 4) == 0) {
    #####: 1715:            settings.detail_enabled = 0;
        -: 1716:        } else {
    #####: 1717:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 1718:            return;
        -: 1719:        }
        -: 1720:    } else {
    #####: 1721:        if (get_stats(subcommand, nkey, &append_stats, c)) {
    #####: 1722:            if (c->stats.buffer == NULL) {
    #####: 1723:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
        -: 1724:            } else {
    #####: 1725:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 1726:                c->stats.buffer = NULL;
        -: 1727:            }
        -: 1728:        } else {
    #####: 1729:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1730:        }
        -: 1731:
    #####: 1732:        return;
        -: 1733:    }
        -: 1734:
        -: 1735:    /* Append termination package and start the transfer */
       25: 1736:    append_stats(NULL, 0, NULL, 0, c);
       25: 1737:    if (c->stats.buffer == NULL) {
    #####: 1738:        out_of_memory(c, "SERVER_ERROR Out of memory preparing to send stats");
        -: 1739:    } else {
       25: 1740:        write_and_free(c, c->stats.buffer, c->stats.offset);
       25: 1741:        c->stats.buffer = NULL;
        -: 1742:    }
        -: 1743:}
        -: 1744:
    73684: 1745:static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {
   73684*: 1746:    assert(c);
    73684: 1747:    c->substate = next_substate;
    73684: 1748:    c->rlbytes = c->keylen + extra;
        -: 1749:
        -: 1750:    /* Ok... do we have room for the extras and the key in the input buffer? */
    73684: 1751:    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;
    73684: 1752:    if (c->rlbytes > c->rsize - offset) {
       90: 1753:        size_t nsize = c->rsize;
       90: 1754:        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);
        -: 1755:
       90: 1756:        while (size > nsize) {
    #####: 1757:            nsize *= 2;
        -: 1758:        }
        -: 1759:
       90: 1760:        if (nsize != c->rsize) {
    #####: 1761:            if (settings.verbose > 1) {
    #####: 1762:                fprintf(stderr, "%d: Need to grow buffer from %lu to %lu\n",
        -: 1763:                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);
        -: 1764:            }
    #####: 1765:            char *newm = realloc(c->rbuf, nsize);
    #####: 1766:            if (newm == NULL) {
    #####: 1767:                STATS_LOCK();
    #####: 1768:                stats.malloc_fails++;
    #####: 1769:                STATS_UNLOCK();
    #####: 1770:                if (settings.verbose) {
    #####: 1771:                    fprintf(stderr, "%d: Failed to grow buffer.. closing connection\n",
        -: 1772:                            c->sfd);
        -: 1773:                }
    #####: 1774:                conn_set_state(c, conn_closing);
    #####: 1775:                return;
        -: 1776:            }
        -: 1777:
    #####: 1778:            c->rbuf= newm;
        -: 1779:            /* rcurr should point to the same offset in the packet */
    #####: 1780:            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);
    #####: 1781:            c->rsize = nsize;
        -: 1782:        }
       90: 1783:        if (c->rbuf != c->rcurr) {
       90: 1784:            memmove(c->rbuf, c->rcurr, c->rbytes);
       90: 1785:            c->rcurr = c->rbuf;
       90: 1786:            if (settings.verbose > 1) {
    #####: 1787:                fprintf(stderr, "%d: Repack input buffer\n", c->sfd);
        -: 1788:            }
        -: 1789:        }
        -: 1790:    }
        -: 1791:
        -: 1792:    /* preserve the header in the buffer.. */
    73684: 1793:    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);
    73684: 1794:    conn_set_state(c, conn_nread);
        -: 1795:}
        -: 1796:
        -: 1797:/* Just write an error message and disconnect the client */
        1: 1798:static void handle_binary_protocol_error(conn *c) {
        1: 1799:    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
        1: 1800:    if (settings.verbose) {
       1*: 1801:        fprintf(stderr, "Protocol error (opcode %02x), close connection %d\n",
    #####: 1802:                c->binary_header.request.opcode, c->sfd);
        -: 1803:    }
        1: 1804:    c->write_and_go = conn_closing;
        1: 1805:}
        -: 1806:
    #####: 1807:static void init_sasl_conn(conn *c) {
    #####: 1808:    assert(c);
        -: 1809:    /* should something else be returned? */
    #####: 1810:    if (!settings.sasl)
        -: 1811:        return;
        -: 1812:
    #####: 1813:    c->authenticated = false;
        -: 1814:
    #####: 1815:    if (!c->sasl_conn) {
    #####: 1816:        int result=sasl_server_new("memcached",
        -: 1817:                                   NULL,
        -: 1818:                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
        -: 1819:                                   NULL, NULL,
        -: 1820:                                   NULL, 0, &c->sasl_conn);
    #####: 1821:        if (result != SASL_OK) {
    #####: 1822:            if (settings.verbose) {
    #####: 1823:                fprintf(stderr, "Failed to initialize SASL conn.\n");
        -: 1824:            }
    #####: 1825:            c->sasl_conn = NULL;
        -: 1826:        }
        -: 1827:    }
        -: 1828:}
        -: 1829:
    #####: 1830:static void bin_list_sasl_mechs(conn *c) {
        -: 1831:    // Guard against a disabled SASL.
    #####: 1832:    if (!settings.sasl) {
    #####: 1833:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 1834:                        c->binary_header.request.bodylen
    #####: 1835:                        - c->binary_header.request.keylen);
    #####: 1836:        return;
        -: 1837:    }
        -: 1838:
    #####: 1839:    init_sasl_conn(c);
    #####: 1840:    const char *result_string = NULL;
    #####: 1841:    unsigned int string_length = 0;
    #####: 1842:    int result=sasl_listmech(c->sasl_conn, NULL,
        -: 1843:                             "",   /* What to prepend the string with */
        -: 1844:                             " ",  /* What to separate mechanisms with */
        -: 1845:                             "",   /* What to append to the string */
        -: 1846:                             &result_string, &string_length,
        -: 1847:                             NULL);
    #####: 1848:    if (result != SASL_OK) {
        -: 1849:        /* Perhaps there's a better error for this... */
    #####: 1850:        if (settings.verbose) {
    #####: 1851:            fprintf(stderr, "Failed to list SASL mechanisms.\n");
        -: 1852:        }
    #####: 1853:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 1854:        return;
        -: 1855:    }
        -: 1856:    write_bin_response(c, (char*)result_string, 0, 0, string_length);
        -: 1857:}
        -: 1858:
    #####: 1859:static void process_bin_sasl_auth(conn *c) {
        -: 1860:    // Guard for handling disabled SASL on the server.
    #####: 1861:    if (!settings.sasl) {
    #####: 1862:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 1863:                        c->binary_header.request.bodylen
    #####: 1864:                        - c->binary_header.request.keylen);
    #####: 1865:        return;
        -: 1866:    }
        -: 1867:
    #####: 1868:    assert(c->binary_header.request.extlen == 0);
        -: 1869:
    #####: 1870:    int nkey = c->binary_header.request.keylen;
    #####: 1871:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 1872:
    #####: 1873:    if (nkey > MAX_SASL_MECH_LEN) {
    #####: 1874:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 1875:        c->write_and_go = conn_swallow;
    #####: 1876:        return;
        -: 1877:    }
        -: 1878:
    #####: 1879:    char *key = binary_get_key(c);
    #####: 1880:    assert(key);
        -: 1881:
    #####: 1882:    item *it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 1883:
        -: 1884:    /* Can't use a chunked item for SASL authentication. */
    #####: 1885:    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
    #####: 1886:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
    #####: 1887:        c->write_and_go = conn_swallow;
    #####: 1888:        return;
        -: 1889:    }
        -: 1890:
    #####: 1891:    c->item = it;
    #####: 1892:    c->ritem = ITEM_data(it);
    #####: 1893:    c->rlbytes = vlen;
    #####: 1894:    conn_set_state(c, conn_nread);
    #####: 1895:    c->substate = bin_reading_sasl_auth_data;
        -: 1896:}
        -: 1897:
    #####: 1898:static void process_bin_complete_sasl_auth(conn *c) {
    #####: 1899:    assert(settings.sasl);
    #####: 1900:    const char *out = NULL;
    #####: 1901:    unsigned int outlen = 0;
        -: 1902:
    #####: 1903:    assert(c->item);
    #####: 1904:    init_sasl_conn(c);
        -: 1905:
    #####: 1906:    int nkey = c->binary_header.request.keylen;
    #####: 1907:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 1908:
    #####: 1909:    if (nkey > ((item*) c->item)->nkey) {
    #####: 1910:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 1911:        c->write_and_go = conn_swallow;
    #####: 1912:        item_unlink(c->item);
    #####: 1913:        return;
        -: 1914:    }
        -: 1915:
    #####: 1916:    char mech[nkey+1];
    #####: 1917:    memcpy(mech, ITEM_key((item*)c->item), nkey);
    #####: 1918:    mech[nkey] = 0x00;
        -: 1919:
    #####: 1920:    if (settings.verbose)
    #####: 1921:        fprintf(stderr, "mech:  ``%s'' with %d bytes of data\n", mech, vlen);
        -: 1922:
    #####: 1923:    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);
        -: 1924:
    #####: 1925:    if (vlen > ((item*) c->item)->nbytes) {
    #####: 1926:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 1927:        c->write_and_go = conn_swallow;
    #####: 1928:        item_unlink(c->item);
    #####: 1929:        return;
        -: 1930:    }
        -: 1931:
    #####: 1932:    int result=-1;
        -: 1933:
    #####: 1934:    switch (c->cmd) {
        -: 1935:    case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 1936:        result = sasl_server_start(c->sasl_conn, mech,
        -: 1937:                                   challenge, vlen,
        -: 1938:                                   &out, &outlen);
        -: 1939:        break;
        -: 1940:    case PROTOCOL_BINARY_CMD_SASL_STEP:
        -: 1941:        result = sasl_server_step(c->sasl_conn,
        -: 1942:                                  challenge, vlen,
        -: 1943:                                  &out, &outlen);
        -: 1944:        break;
        -: 1945:    default:
    #####: 1946:        assert(false); /* CMD should be one of the above */
        -: 1947:        /* This code is pretty much impossible, but makes the compiler
        -: 1948:           happier */
        -: 1949:        if (settings.verbose) {
        -: 1950:            fprintf(stderr, "Unhandled command %d with challenge %s\n",
        -: 1951:                    c->cmd, challenge);
        -: 1952:        }
        -: 1953:        break;
        -: 1954:    }
        -: 1955:
    #####: 1956:    item_unlink(c->item);
        -: 1957:
    #####: 1958:    if (settings.verbose) {
    #####: 1959:        fprintf(stderr, "sasl result code:  %d\n", result);
        -: 1960:    }
        -: 1961:
    #####: 1962:    switch(result) {
        -: 1963:    case SASL_OK:
        -: 1964:        c->authenticated = true;
        -: 1965:        write_bin_response(c, "Authenticated", 0, 0, strlen("Authenticated"));
        -: 1966:        pthread_mutex_lock(&c->thread->stats.mutex);
        -: 1967:        c->thread->stats.auth_cmds++;
        -: 1968:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1969:        break;
        -: 1970:    case SASL_CONTINUE:
        -: 1971:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);
        -: 1972:        if(outlen > 0) {
        -: 1973:            add_iov(c, out, outlen);
        -: 1974:        }
        -: 1975:        conn_set_state(c, conn_mwrite);
        -: 1976:        c->write_and_go = conn_new_cmd;
        -: 1977:        break;
        -: 1978:    default:
    #####: 1979:        if (settings.verbose)
    #####: 1980:            fprintf(stderr, "Unknown sasl response:  %d\n", result);
    #####: 1981:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 1982:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1983:        c->thread->stats.auth_cmds++;
    #####: 1984:        c->thread->stats.auth_errors++;
    #####: 1985:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1986:    }
        -: 1987:}
        -: 1988:
        -: 1989:static bool authenticated(conn *c) {
        -: 1990:    assert(settings.sasl);
        -: 1991:    bool rv = false;
        -: 1992:
        -: 1993:    switch (c->cmd) {
        -: 1994:    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
        -: 1995:    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
        -: 1996:    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
        -: 1997:    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        -: 1998:        rv = true;
        -: 1999:        break;
        -: 2000:    default:
        -: 2001:        rv = c->authenticated;
        -: 2002:    }
        -: 2003:
        -: 2004:    if (settings.verbose > 1) {
        -: 2005:        fprintf(stderr, "authenticated() in cmd 0x%02x is %s\n",
        -: 2006:                c->cmd, rv ? "true" : "false");
        -: 2007:    }
        -: 2008:
        -: 2009:    return rv;
        -: 2010:}
        -: 2011:
    77019: 2012:static void dispatch_bin_command(conn *c) {
    77019: 2013:    int protocol_error = 0;
        -: 2014:
    77019: 2015:    uint8_t extlen = c->binary_header.request.extlen;
    77019: 2016:    uint16_t keylen = c->binary_header.request.keylen;
    77019: 2017:    uint32_t bodylen = c->binary_header.request.bodylen;
        -: 2018:
    77019: 2019:    if (keylen > bodylen || keylen + extlen > bodylen) {
    #####: 2020:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
    #####: 2021:        c->write_and_go = conn_closing;
    #####: 2022:        return;
        -: 2023:    }
        -: 2024:
   77019*: 2025:    if (settings.sasl && !authenticated(c)) {
    #####: 2026:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2027:        c->write_and_go = conn_closing;
    #####: 2028:        return;
        -: 2029:    }
        -: 2030:
    77019: 2031:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
    77019: 2032:    c->noreply = true;
        -: 2033:
        -: 2034:    /* binprot supports 16bit keys, but internals are still 8bit */
    77019: 2035:    if (keylen > KEY_MAX_LENGTH) {
        1: 2036:        handle_binary_protocol_error(c);
        1: 2037:        return;
        -: 2038:    }
        -: 2039:
    77018: 2040:    switch (c->cmd) {
    19875: 2041:    case PROTOCOL_BINARY_CMD_SETQ:
    19875: 2042:        c->cmd = PROTOCOL_BINARY_CMD_SET;
    19875: 2043:        break;
    52201: 2044:    case PROTOCOL_BINARY_CMD_ADDQ:
    52201: 2045:        c->cmd = PROTOCOL_BINARY_CMD_ADD;
    52201: 2046:        break;
       31: 2047:    case PROTOCOL_BINARY_CMD_REPLACEQ:
       31: 2048:        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;
       31: 2049:        break;
       18: 2050:    case PROTOCOL_BINARY_CMD_DELETEQ:
       18: 2051:        c->cmd = PROTOCOL_BINARY_CMD_DELETE;
       18: 2052:        break;
       29: 2053:    case PROTOCOL_BINARY_CMD_INCREMENTQ:
       29: 2054:        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;
       29: 2055:        break;
       28: 2056:    case PROTOCOL_BINARY_CMD_DECREMENTQ:
       28: 2057:        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;
       28: 2058:        break;
        3: 2059:    case PROTOCOL_BINARY_CMD_QUITQ:
        3: 2060:        c->cmd = PROTOCOL_BINARY_CMD_QUIT;
        3: 2061:        break;
       18: 2062:    case PROTOCOL_BINARY_CMD_FLUSHQ:
       18: 2063:        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;
       18: 2064:        break;
       13: 2065:    case PROTOCOL_BINARY_CMD_APPENDQ:
       13: 2066:        c->cmd = PROTOCOL_BINARY_CMD_APPEND;
       13: 2067:        break;
       17: 2068:    case PROTOCOL_BINARY_CMD_PREPENDQ:
       17: 2069:        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;
       17: 2070:        break;
       18: 2071:    case PROTOCOL_BINARY_CMD_GETQ:
       18: 2072:        c->cmd = PROTOCOL_BINARY_CMD_GET;
       18: 2073:        break;
       18: 2074:    case PROTOCOL_BINARY_CMD_GETKQ:
       18: 2075:        c->cmd = PROTOCOL_BINARY_CMD_GETK;
       18: 2076:        break;
       18: 2077:    case PROTOCOL_BINARY_CMD_GATQ:
       18: 2078:        c->cmd = PROTOCOL_BINARY_CMD_GAT;
       18: 2079:        break;
       14: 2080:    case PROTOCOL_BINARY_CMD_GATKQ:
       14: 2081:        c->cmd = PROTOCOL_BINARY_CMD_GATK;
       14: 2082:        break;
     4717: 2083:    default:
     4717: 2084:        c->noreply = false;
        -: 2085:    }
        -: 2086:
    77018: 2087:    switch (c->cmd) {
       20: 2088:        case PROTOCOL_BINARY_CMD_VERSION:
       20: 2089:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
       20: 2090:                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
        -: 2091:            } else {
        -: 2092:                protocol_error = 1;
        -: 2093:            }
        -: 2094:            break;
       38: 2095:        case PROTOCOL_BINARY_CMD_FLUSH:
       38: 2096:            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {
       38: 2097:                bin_read_key(c, bin_read_flush_exptime, extlen);
        -: 2098:            } else {
        -: 2099:                protocol_error = 1;
        -: 2100:            }
        -: 2101:            break;
       44: 2102:        case PROTOCOL_BINARY_CMD_NOOP:
       44: 2103:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
       44: 2104:                write_bin_response(c, NULL, 0, 0, 0);
        -: 2105:            } else {
        -: 2106:                protocol_error = 1;
        -: 2107:            }
        -: 2108:            break;
    72442: 2109:        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */
        -: 2110:        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */
        -: 2111:        case PROTOCOL_BINARY_CMD_REPLACE:
    72442: 2112:            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {
    72442: 2113:                bin_read_key(c, bin_reading_set_header, 8);
        -: 2114:            } else {
        -: 2115:                protocol_error = 1;
        -: 2116:            }
        -: 2117:            break;
      847: 2118:        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */
        -: 2119:        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */
        -: 2120:        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */
        -: 2121:        case PROTOCOL_BINARY_CMD_GETK:
      847: 2122:            if (extlen == 0 && bodylen == keylen && keylen > 0) {
      847: 2123:                bin_read_key(c, bin_reading_get_key, 0);
        -: 2124:            } else {
        -: 2125:                protocol_error = 1;
        -: 2126:            }
        -: 2127:            break;
       35: 2128:        case PROTOCOL_BINARY_CMD_DELETE:
       35: 2129:            if (keylen > 0 && extlen == 0 && bodylen == keylen) {
       35: 2130:                bin_read_key(c, bin_reading_del_header, extlen);
        -: 2131:            } else {
        -: 2132:                protocol_error = 1;
        -: 2133:            }
        -: 2134:            break;
      126: 2135:        case PROTOCOL_BINARY_CMD_INCREMENT:
        -: 2136:        case PROTOCOL_BINARY_CMD_DECREMENT:
      126: 2137:            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {
      126: 2138:                bin_read_key(c, bin_reading_incr_header, 20);
        -: 2139:            } else {
        -: 2140:                protocol_error = 1;
        -: 2141:            }
        -: 2142:            break;
       71: 2143:        case PROTOCOL_BINARY_CMD_APPEND:
        -: 2144:        case PROTOCOL_BINARY_CMD_PREPEND:
       71: 2145:            if (keylen > 0 && extlen == 0) {
       71: 2146:                bin_read_key(c, bin_reading_set_header, 0);
        -: 2147:            } else {
        -: 2148:                protocol_error = 1;
        -: 2149:            }
        -: 2150:            break;
       25: 2151:        case PROTOCOL_BINARY_CMD_STAT:
       25: 2152:            if (extlen == 0) {
       25: 2153:                bin_read_key(c, bin_reading_stat, 0);
        -: 2154:            } else {
        -: 2155:                protocol_error = 1;
        -: 2156:            }
        -: 2157:            break;
        4: 2158:        case PROTOCOL_BINARY_CMD_QUIT:
        4: 2159:            if (keylen == 0 && extlen == 0 && bodylen == 0) {
        4: 2160:                write_bin_response(c, NULL, 0, 0, 0);
        4: 2161:                c->write_and_go = conn_closing;
        4: 2162:                if (c->noreply) {
        3: 2163:                    conn_set_state(c, conn_closing);
        -: 2164:                }
        -: 2165:            } else {
        -: 2166:                protocol_error = 1;
        -: 2167:            }
        -: 2168:            break;
    #####: 2169:        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:
    #####: 2170:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2171:                bin_list_sasl_mechs(c);
        -: 2172:            } else {
        -: 2173:                protocol_error = 1;
        -: 2174:            }
        -: 2175:            break;
    #####: 2176:        case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 2177:        case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2178:            if (extlen == 0 && keylen != 0) {
    #####: 2179:                bin_read_key(c, bin_reading_sasl_auth, 0);
        -: 2180:            } else {
        -: 2181:                protocol_error = 1;
        -: 2182:            }
        -: 2183:            break;
      100: 2184:        case PROTOCOL_BINARY_CMD_TOUCH:
        -: 2185:        case PROTOCOL_BINARY_CMD_GAT:
        -: 2186:        case PROTOCOL_BINARY_CMD_GATQ:
        -: 2187:        case PROTOCOL_BINARY_CMD_GATK:
        -: 2188:        case PROTOCOL_BINARY_CMD_GATKQ:
      100: 2189:            if (extlen == 4 && keylen != 0) {
      100: 2190:                bin_read_key(c, bin_reading_touch_key, 4);
        -: 2191:            } else {
        -: 2192:                protocol_error = 1;
        -: 2193:            }
        -: 2194:            break;
     3266: 2195:        default:
     3266: 2196:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
        -: 2197:                            bodylen);
        -: 2198:    }
        -: 2199:
   77017*: 2200:    if (protocol_error)
    #####: 2201:        handle_binary_protocol_error(c);
        -: 2202:}
        -: 2203:
    72442: 2204:static void process_bin_update(conn *c) {
    72442: 2205:    char *key;
    72442: 2206:    int nkey;
    72442: 2207:    int vlen;
    72442: 2208:    item *it;
    72442: 2209:    protocol_binary_request_set* req = binary_get_request(c);
        -: 2210:
   72442*: 2211:    assert(c != NULL);
        -: 2212:
    72442: 2213:    key = binary_get_key(c);
    72442: 2214:    nkey = c->binary_header.request.keylen;
        -: 2215:
        -: 2216:    /* fix byteorder in the request */
    72442: 2217:    req->message.body.flags = ntohl(req->message.body.flags);
    72442: 2218:    req->message.body.expiration = ntohl(req->message.body.expiration);
        -: 2219:
    72442: 2220:    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);
        -: 2221:
    72442: 2222:    if (settings.verbose > 1) {
    #####: 2223:        int ii;
    #####: 2224:        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
    #####: 2225:            fprintf(stderr, "<%d ADD ", c->sfd);
    #####: 2226:        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2227:            fprintf(stderr, "<%d SET ", c->sfd);
        -: 2228:        } else {
    #####: 2229:            fprintf(stderr, "<%d REPLACE ", c->sfd);
        -: 2230:        }
    #####: 2231:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2232:            fprintf(stderr, "%c", key[ii]);
        -: 2233:        }
        -: 2234:
    #####: 2235:        fprintf(stderr, " Value len is %d", vlen);
    #####: 2236:        fprintf(stderr, "\n");
        -: 2237:    }
        -: 2238:
    72442: 2239:    if (settings.detail_enabled) {
    19888: 2240:        stats_prefix_record_set(key, nkey);
        -: 2241:    }
        -: 2242:
    72442: 2243:    it = item_alloc(key, nkey, req->message.body.flags,
    72442: 2244:            realtime(req->message.body.expiration), vlen+2);
        -: 2245:
    72442: 2246:    if (it == 0) {
    52183: 2247:        enum store_item_type status;
    52183: 2248:        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {
        1: 2249:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        1: 2250:            status = TOO_LARGE;
        -: 2251:        } else {
    52182: 2252:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2253:            /* This error generating method eats the swallow value. Add here. */
    52182: 2254:            c->sbytes = vlen;
    52182: 2255:            status = NO_MEMORY;
        -: 2256:        }
        -: 2257:        /* FIXME: losing c->cmd since it's translated below. refactor? */
   52183*: 2258:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 2259:                NULL, status, 0, key, nkey, it->exptime, ITEM_clsid(it));
        -: 2260:
        -: 2261:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 2262:         * Unacceptable for SET. Anywhere else too? */
    52183: 2263:        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
        1: 2264:            it = item_get(key, nkey, c);
        1: 2265:            if (it) {
        1: 2266:                item_unlink(it);
        1: 2267:                item_remove(it);
        -: 2268:            }
        -: 2269:        }
        -: 2270:
        -: 2271:        /* swallow the data line */
    52183: 2272:        c->write_and_go = conn_swallow;
    52183: 2273:        return;
        -: 2274:    }
        -: 2275:
    20259: 2276:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2277:
    20259: 2278:    switch (c->cmd) {
       74: 2279:        case PROTOCOL_BINARY_CMD_ADD:
       74: 2280:            c->cmd = NREAD_ADD;
       74: 2281:            break;
    20124: 2282:        case PROTOCOL_BINARY_CMD_SET:
    20124: 2283:            c->cmd = NREAD_SET;
    20124: 2284:            break;
       61: 2285:        case PROTOCOL_BINARY_CMD_REPLACE:
       61: 2286:            c->cmd = NREAD_REPLACE;
       61: 2287:            break;
        -: 2288:        default:
    #####: 2289:            assert(0);
        -: 2290:    }
        -: 2291:
    20259: 2292:    if (ITEM_get_cas(it) != 0) {
        5: 2293:        c->cmd = NREAD_CAS;
        -: 2294:    }
        -: 2295:
    20259: 2296:    c->item = it;
    20259: 2297:    c->ritem = ITEM_data(it);
    20259: 2298:    c->rlbytes = vlen;
    20259: 2299:    conn_set_state(c, conn_nread);
    20259: 2300:    c->substate = bin_read_set_value;
        -: 2301:}
        -: 2302:
       71: 2303:static void process_bin_append_prepend(conn *c) {
       71: 2304:    char *key;
       71: 2305:    int nkey;
       71: 2306:    int vlen;
       71: 2307:    item *it;
        -: 2308:
      71*: 2309:    assert(c != NULL);
        -: 2310:
       71: 2311:    key = binary_get_key(c);
       71: 2312:    nkey = c->binary_header.request.keylen;
       71: 2313:    vlen = c->binary_header.request.bodylen - nkey;
        -: 2314:
       71: 2315:    if (settings.verbose > 1) {
    #####: 2316:        fprintf(stderr, "Value len is %d\n", vlen);
        -: 2317:    }
        -: 2318:
       71: 2319:    if (settings.detail_enabled) {
        4: 2320:        stats_prefix_record_set(key, nkey);
        -: 2321:    }
        -: 2322:
       71: 2323:    it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2324:
       71: 2325:    if (it == 0) {
    #####: 2326:        if (! item_size_ok(nkey, 0, vlen + 2)) {
    #####: 2327:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        -: 2328:        } else {
    #####: 2329:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2330:            /* OOM calls eat the swallow value. Add here. */
    #####: 2331:            c->sbytes = vlen;
        -: 2332:        }
        -: 2333:        /* swallow the data line */
    #####: 2334:        c->write_and_go = conn_swallow;
    #####: 2335:        return;
        -: 2336:    }
        -: 2337:
       71: 2338:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2339:
       71: 2340:    switch (c->cmd) {
       36: 2341:        case PROTOCOL_BINARY_CMD_APPEND:
       36: 2342:            c->cmd = NREAD_APPEND;
       36: 2343:            break;
       35: 2344:        case PROTOCOL_BINARY_CMD_PREPEND:
       35: 2345:            c->cmd = NREAD_PREPEND;
       35: 2346:            break;
        -: 2347:        default:
    #####: 2348:            assert(0);
        -: 2349:    }
        -: 2350:
       71: 2351:    c->item = it;
       71: 2352:    c->ritem = ITEM_data(it);
       71: 2353:    c->rlbytes = vlen;
       71: 2354:    conn_set_state(c, conn_nread);
       71: 2355:    c->substate = bin_read_set_value;
        -: 2356:}
        -: 2357:
       38: 2358:static void process_bin_flush(conn *c) {
       38: 2359:    time_t exptime = 0;
       38: 2360:    protocol_binary_request_flush* req = binary_get_request(c);
       38: 2361:    rel_time_t new_oldest = 0;
        -: 2362:
       38: 2363:    if (!settings.flush_enabled) {
        -: 2364:      // flush_all is not allowed but we log it on stats
    #####: 2365:      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2366:      return;
        -: 2367:    }
        -: 2368:
       38: 2369:    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
        4: 2370:        exptime = ntohl(req->message.body.expiration);
        -: 2371:    }
        -: 2372:
        4: 2373:    if (exptime > 0) {
        2: 2374:        new_oldest = realtime(exptime);
        -: 2375:    } else {
       36: 2376:        new_oldest = current_time;
        -: 2377:    }
       38: 2378:    if (settings.use_cas) {
       38: 2379:        settings.oldest_live = new_oldest - 1;
       38: 2380:        if (settings.oldest_live <= current_time)
       36: 2381:            settings.oldest_cas = get_cas_id();
        -: 2382:    } else {
    #####: 2383:        settings.oldest_live = new_oldest;
        -: 2384:    }
        -: 2385:
       38: 2386:    pthread_mutex_lock(&c->thread->stats.mutex);
       38: 2387:    c->thread->stats.flush_cmds++;
       38: 2388:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2389:
       38: 2390:    write_bin_response(c, NULL, 0, 0, 0);
        -: 2391:}
        -: 2392:
       35: 2393:static void process_bin_delete(conn *c) {
       35: 2394:    item *it;
        -: 2395:
       35: 2396:    protocol_binary_request_delete* req = binary_get_request(c);
        -: 2397:
       35: 2398:    char* key = binary_get_key(c);
       35: 2399:    size_t nkey = c->binary_header.request.keylen;
        -: 2400:
       35: 2401:    assert(c != NULL);
        -: 2402:
       35: 2403:    if (settings.verbose > 1) {
    #####: 2404:        int ii;
    #####: 2405:        fprintf(stderr, "Deleting ");
    #####: 2406:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2407:            fprintf(stderr, "%c", key[ii]);
        -: 2408:        }
    #####: 2409:        fprintf(stderr, "\n");
        -: 2410:    }
        -: 2411:
       35: 2412:    if (settings.detail_enabled) {
        2: 2413:        stats_prefix_record_delete(key, nkey);
        -: 2414:    }
        -: 2415:
       35: 2416:    it = item_get(key, nkey, c);
       35: 2417:    if (it) {
        5: 2418:        uint64_t cas = ntohll(req->message.header.request.cas);
       5*: 2419:        if (cas == 0 || cas == ITEM_get_cas(it)) {
        5: 2420:            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        5: 2421:            pthread_mutex_lock(&c->thread->stats.mutex);
        5: 2422:            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
        5: 2423:            pthread_mutex_unlock(&c->thread->stats.mutex);
        5: 2424:            item_unlink(it);
        5: 2425:            write_bin_response(c, NULL, 0, 0, 0);
        -: 2426:        } else {
    #####: 2427:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        -: 2428:        }
        5: 2429:        item_remove(it);      /* release our reference */
        -: 2430:    } else {
       30: 2431:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
       30: 2432:        pthread_mutex_lock(&c->thread->stats.mutex);
       30: 2433:        c->thread->stats.delete_misses++;
       30: 2434:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2435:    }
       35: 2436:}
        -: 2437:
    94014: 2438:static void complete_nread_binary(conn *c) {
   94014*: 2439:    assert(c != NULL);
   94014*: 2440:    assert(c->cmd >= 0);
        -: 2441:
    94014: 2442:    switch(c->substate) {
    72513: 2443:    case bin_reading_set_header:
    72513: 2444:        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||
        -: 2445:                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {
       71: 2446:            process_bin_append_prepend(c);
        -: 2447:        } else {
    72442: 2448:            process_bin_update(c);
        -: 2449:        }
        -: 2450:        break;
    20330: 2451:    case bin_read_set_value:
    20330: 2452:        complete_update_bin(c);
    20330: 2453:        break;
      947: 2454:    case bin_reading_get_key:
        -: 2455:    case bin_reading_touch_key:
      947: 2456:        process_bin_get_or_touch(c);
      947: 2457:        break;
       25: 2458:    case bin_reading_stat:
       25: 2459:        process_bin_stat(c);
       25: 2460:        break;
       35: 2461:    case bin_reading_del_header:
       35: 2462:        process_bin_delete(c);
       35: 2463:        break;
      126: 2464:    case bin_reading_incr_header:
      126: 2465:        complete_incr_bin(c);
      126: 2466:        break;
       38: 2467:    case bin_read_flush_exptime:
       38: 2468:        process_bin_flush(c);
       38: 2469:        break;
    #####: 2470:    case bin_reading_sasl_auth:
    #####: 2471:        process_bin_sasl_auth(c);
    #####: 2472:        break;
    #####: 2473:    case bin_reading_sasl_auth_data:
    #####: 2474:        process_bin_complete_sasl_auth(c);
    #####: 2475:        break;
    #####: 2476:    default:
    #####: 2477:        fprintf(stderr, "Not handling substate %d\n", c->substate);
    #####: 2478:        assert(0);
        -: 2479:    }
    94014: 2480:}
        -: 2481:
   277230: 2482:static void reset_cmd_handler(conn *c) {
   277230: 2483:    c->cmd = -1;
   277230: 2484:    c->substate = bin_no_state;
   277230: 2485:    if(c->item != NULL) {
    #####: 2486:        item_remove(c->item);
    #####: 2487:        c->item = NULL;
        -: 2488:    }
   277230: 2489:    conn_shrink(c);
   277230: 2490:    if (c->rbytes > 0) {
   124708: 2491:        conn_set_state(c, conn_parse_cmd);
        -: 2492:    } else {
   152522: 2493:        conn_set_state(c, conn_waiting);
        -: 2494:    }
   277230: 2495:}
        -: 2496:
   176092: 2497:static void complete_nread(conn *c) {
  176092*: 2498:    assert(c != NULL);
  176092*: 2499:    assert(c->protocol == ascii_prot
        -: 2500:           || c->protocol == binary_prot);
        -: 2501:
   176092: 2502:    if (c->protocol == ascii_prot) {
    82078: 2503:        complete_nread_ascii(c);
    94014: 2504:    } else if (c->protocol == binary_prot) {
    94014: 2505:        complete_nread_binary(c);
        -: 2506:    }
   176092: 2507:}
        -: 2508:
        -: 2509:/* Destination must always be chunked */
        -: 2510:/* This should be part of item.c */
    27032: 2511:static void _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    27032: 2512:    item_chunk *dch = (item_chunk *) ITEM_data(d_it);
        -: 2513:    /* Advance dch until we find free space */
    50096: 2514:    while (dch->size == dch->used) {
    23064: 2515:        dch = dch->next;
        -: 2516:    }
        -: 2517:
    27032: 2518:    if (s_it->it_flags & ITEM_CHUNKED) {
    13516: 2519:        int remain = len;
    13516: 2520:        item_chunk *sch = (item_chunk *) ITEM_data(s_it);
    13516: 2521:        int copied = 0;
        -: 2522:        /* Fills dch's to capacity, not straight copy sch in case data is
        -: 2523:         * being added or removed (ie append/prepend)
        -: 2524:         */
    96236: 2525:        while (sch && dch && remain) {
   82720*: 2526:            assert(dch->used <= dch->size);
    82720: 2527:            int todo = (dch->size - dch->used < sch->used - copied)
        -: 2528:                ? dch->size - dch->used : sch->used - copied;
    82720: 2529:            if (remain < todo)
        -: 2530:                todo = remain;
    82720: 2531:            memcpy(dch->data + dch->used, sch->data + copied, todo);
    82720: 2532:            dch->used += todo;
    82720: 2533:            copied += todo;
    82720: 2534:            remain -= todo;
   82720*: 2535:            assert(dch->used <= dch->size);
    82720: 2536:            if (dch->size == dch->used) {
    46134: 2537:                dch = dch->next;
        -: 2538:            }
   82720*: 2539:            assert(copied <= sch->used);
    82720: 2540:            if (copied == sch->used) {
    52885: 2541:                copied = 0;
    52885: 2542:                sch = sch->next;
        -: 2543:            }
        -: 2544:        }
        -: 2545:        /* assert that the destination had enough space for the source */
   13516*: 2546:        assert(remain == 0);
        -: 2547:    } else {
        -: 2548:        int done = 0;
        -: 2549:        /* Fill dch's via a non-chunked item. */
    27039: 2550:        while (len > done && dch) {
    13523: 2551:            int todo = (dch->size - dch->used < len - done)
        -: 2552:                ? dch->size - dch->used : len - done;
   13523*: 2553:            assert(dch->size - dch->used != 0);
    13523: 2554:            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
    13523: 2555:            done += todo;
    13523: 2556:            dch->used += todo;
   13523*: 2557:            assert(dch->used <= dch->size);
    13523: 2558:            if (dch->size == dch->used)
        8: 2559:                dch = dch->next;
        -: 2560:        }
   13516*: 2561:        assert(len == done);
        -: 2562:    }
    27032: 2563:}
        -: 2564:
    16014: 2565:static void _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    16014: 2566:    if (comm == NREAD_APPEND) {
     8007: 2567:        if (new_it->it_flags & ITEM_CHUNKED) {
     6758: 2568:            _store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2);
     6758: 2569:            _store_item_copy_chunks(new_it, add_it, add_it->nbytes);
        -: 2570:        } else {
     1249: 2571:            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
     1249: 2572:            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        -: 2573:        }
        -: 2574:    } else {
        -: 2575:        /* NREAD_PREPEND */
     8007: 2576:        if (new_it->it_flags & ITEM_CHUNKED) {
     6758: 2577:            _store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2);
     6758: 2578:            _store_item_copy_chunks(new_it, old_it, old_it->nbytes);
        -: 2579:        } else {
     1249: 2580:            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
     1249: 2581:            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        -: 2582:        }
        -: 2583:    }
    16014: 2584:}
        -: 2585:
        -: 2586:/*
        -: 2587: * Stores an item in the cache according to the semantics of one of the set
        -: 2588: * commands. In threaded mode, this is protected by the cache lock.
        -: 2589: *
        -: 2590: * Returns the state of storage.
        -: 2591: */
   102475: 2592:enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
   102475: 2593:    char *key = ITEM_key(it);
   102475: 2594:    item *old_it = do_item_get(key, it->nkey, hv, c);
   102475: 2595:    enum store_item_type stored = NOT_STORED;
        -: 2596:
   102475: 2597:    item *new_it = NULL;
   102475: 2598:    uint32_t flags;
        -: 2599:
   102475: 2600:    if (old_it != NULL && comm == NREAD_ADD) {
        -: 2601:        /* add only adds a nonexistent item, but promote to head of LRU */
       22: 2602:        do_item_update(old_it);
   102453: 2603:    } else if (!old_it && (comm == NREAD_REPLACE
    66714: 2604:        || comm == NREAD_APPEND || comm == NREAD_PREPEND))
        -: 2605:    {
        -: 2606:        /* replace only replaces an existing value; don't store */
   102352: 2607:    } else if (comm == NREAD_CAS) {
        -: 2608:        /* validate cas operation */
       17: 2609:        if(old_it == NULL) {
        -: 2610:            // LRU expired
        3: 2611:            stored = NOT_FOUND;
        3: 2612:            pthread_mutex_lock(&c->thread->stats.mutex);
        3: 2613:            c->thread->stats.cas_misses++;
        3: 2614:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2615:        }
       14: 2616:        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {
        -: 2617:            // cas validates
        -: 2618:            // it and old_it may belong to different classes.
        -: 2619:            // I'm updating the stats for the one that's getting pushed out
        7: 2620:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 2621:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
        7: 2622:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2623:
        7: 2624:            item_replace(old_it, it, hv);
        7: 2625:            stored = STORED;
        -: 2626:        } else {
        7: 2627:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 2628:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
        7: 2629:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2630:
        7: 2631:            if(settings.verbose > 1) {
    #####: 2632:                fprintf(stderr, "CAS:  failure: expected %llu, got %llu\n",
    #####: 2633:                        (unsigned long long)ITEM_get_cas(old_it),
    #####: 2634:                        (unsigned long long)ITEM_get_cas(it));
        -: 2635:            }
        -: 2636:            stored = EXISTS;
        -: 2637:        }
        -: 2638:    } else {
   102335: 2639:        int failed_alloc = 0;
        -: 2640:        /*
        -: 2641:         * Append - combine new and old record into single one. Here it's
        -: 2642:         * atomic and thread-safe.
        -: 2643:         */
   102335: 2644:        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {
        -: 2645:            /*
        -: 2646:             * Validate CAS
        -: 2647:             */
    16014: 2648:            if (ITEM_get_cas(it) != 0) {
        -: 2649:                // CAS much be equal
    #####: 2650:                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {
        -: 2651:                    stored = EXISTS;
        -: 2652:                }
        -: 2653:            }
        -: 2654:
        -: 2655:            if (stored == NOT_STORED) {
        -: 2656:                /* we have it and old_it here - alloc memory to hold both */
        -: 2657:                /* flags was already lost - so recover them from ITEM_suffix(it) */
        -: 2658:
    16014: 2659:                flags = (uint32_t) strtoul(ITEM_suffix(old_it), (char **) NULL, 10);
        -: 2660:
    16014: 2661:                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);
        -: 2662:
    16014: 2663:                if (new_it == NULL) {
        -: 2664:                    failed_alloc = 1;
        -: 2665:                    stored = NOT_STORED;
        -: 2666:                } else {
        -: 2667:                    /* copy data from it and old_it to new_it */
    16014: 2668:                    _store_item_copy_data(comm, old_it, new_it, it);
        -: 2669:
    16014: 2670:                    it = new_it;
        -: 2671:                }
        -: 2672:            }
        -: 2673:        }
        -: 2674:
   102335: 2675:        if (stored == NOT_STORED && failed_alloc == 0) {
   102335: 2676:            if (old_it != NULL)
    35725: 2677:                item_replace(old_it, it, hv);
        -: 2678:            else
    66610: 2679:                do_item_link(it, hv);
        -: 2680:
   102335: 2681:            c->cas = ITEM_get_cas(it);
        -: 2682:
   102335: 2683:            stored = STORED;
        -: 2684:        }
        -: 2685:    }
        -: 2686:
   102475: 2687:    if (old_it != NULL)
    35761: 2688:        do_item_remove(old_it);         /* release our reference */
   102475: 2689:    if (new_it != NULL)
    16014: 2690:        do_item_remove(new_it);
        -: 2691:
   102475: 2692:    if (stored == STORED) {
   102342: 2693:        c->cas = ITEM_get_cas(it);
        -: 2694:    }
  102475*: 2695:    LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
        -: 2696:            stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it));
        -: 2697:
   102475: 2698:    return stored;
        -: 2699:}
        -: 2700:
        -: 2701:typedef struct token_s {
        -: 2702:    char *value;
        -: 2703:    size_t length;
        -: 2704:} token_t;
        -: 2705:
        -: 2706:#define COMMAND_TOKEN 0
        -: 2707:#define SUBCOMMAND_TOKEN 1
        -: 2708:#define KEY_TOKEN 1
        -: 2709:
        -: 2710:#define MAX_TOKENS 8
        -: 2711:
        -: 2712:/*
        -: 2713: * Tokenize the command string by replacing whitespace with '\0' and update
        -: 2714: * the token array tokens with pointer to start of each token and length.
        -: 2715: * Returns total number of tokens.  The last valid token is the terminal
        -: 2716: * token (value points to the first unprocessed character of the string and
        -: 2717: * length zero).
        -: 2718: *
        -: 2719: * Usage example:
        -: 2720: *
        -: 2721: *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {
        -: 2722: *      for(int ix = 0; tokens[ix].length != 0; ix++) {
        -: 2723: *          ...
        -: 2724: *      }
        -: 2725: *      ncommand = tokens[ix].value - command;
        -: 2726: *      command  = tokens[ix].value;
        -: 2727: *   }
        -: 2728: */
   200237: 2729:static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
   200237: 2730:    char *s, *e;
   200237: 2731:    size_t ntokens = 0;
   200237: 2732:    size_t len = strlen(command);
   200237: 2733:    unsigned int i = 0;
        -: 2734:
  200237*: 2735:    assert(command != NULL && tokens != NULL && max_tokens > 1);
        -: 2736:
        -: 2737:    s = e = command;
 21327746: 2738:    for (i = 0; i < len; i++) {
 21127629: 2739:        if (*e == ' ') {
   509999: 2740:            if (s != e) {
   509988: 2741:                tokens[ntokens].value = s;
   509988: 2742:                tokens[ntokens].length = e - s;
   509988: 2743:                ntokens++;
   509988: 2744:                *e = '\0';
   509988: 2745:                if (ntokens == max_tokens - 1) {
      120: 2746:                    e++;
      120: 2747:                    s = e; /* so we don't add an extra token */
      120: 2748:                    break;
        -: 2749:                }
        -: 2750:            }
   509879: 2751:            s = e + 1;
        -: 2752:        }
 21127509: 2753:        e++;
        -: 2754:    }
        -: 2755:
   200237: 2756:    if (s != e) {
   200114: 2757:        tokens[ntokens].value = s;
   200114: 2758:        tokens[ntokens].length = e - s;
   200114: 2759:        ntokens++;
        -: 2760:    }
        -: 2761:
        -: 2762:    /*
        -: 2763:     * If we scanned the whole string, the terminal value pointer is null,
        -: 2764:     * otherwise it is the first unprocessed character.
        -: 2765:     */
   200237: 2766:    tokens[ntokens].value =  *e == '\0' ? NULL : e;
   200237: 2767:    tokens[ntokens].length = 0;
   200237: 2768:    ntokens++;
        -: 2769:
   200237: 2770:    return ntokens;
        -: 2771:}
        -: 2772:
        -: 2773:/* set up a connection to write a buffer then free it, used for stats */
     2837: 2774:static void write_and_free(conn *c, char *buf, int bytes) {
     2837: 2775:    if (buf) {
     2837: 2776:        c->write_and_free = buf;
     2837: 2777:        c->wcurr = buf;
     2837: 2778:        c->wbytes = bytes;
     2837: 2779:        conn_set_state(c, conn_write);
     2837: 2780:        c->write_and_go = conn_new_cmd;
        -: 2781:    } else {
    #####: 2782:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 2783:    }
     2837: 2784:}
        -: 2785:
        -: 2786:static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
        -: 2787:{
        -: 2788:    int noreply_index = ntokens - 2;
        -: 2789:
        -: 2790:    /*
        -: 2791:      NOTE: this function is not the first place where we are going to
        -: 2792:      send the reply.  We could send it instead from process_command()
        -: 2793:      if the request line has wrong number of tokens.  However parsing
        -: 2794:      malformed line for "noreply" option is not reliable anyway, so
        -: 2795:      it can't be helped.
        -: 2796:    */
        -: 2797:    if (tokens[noreply_index].value
        -: 2798:        && strcmp(tokens[noreply_index].value, "noreply") == 0) {
        -: 2799:        c->noreply = true;
        -: 2800:    }
        -: 2801:    return c->noreply;
        -: 2802:}
        -: 2803:
   164470: 2804:void append_stat(const char *name, ADD_STAT add_stats, conn *c,
        -: 2805:                 const char *fmt, ...) {
   164470: 2806:    char val_str[STAT_VAL_LEN];
   164470: 2807:    int vlen;
   164470: 2808:    va_list ap;
        -: 2809:
  164470*: 2810:    assert(name);
  164470*: 2811:    assert(add_stats);
  164470*: 2812:    assert(c);
  164470*: 2813:    assert(fmt);
        -: 2814:
   164470: 2815:    va_start(ap, fmt);
   164470: 2816:    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
   164470: 2817:    va_end(ap);
        -: 2818:
   164470: 2819:    add_stats(name, strlen(name), val_str, vlen, c);
   164470: 2820:}
        -: 2821:
       10: 2822:inline static void process_stats_detail(conn *c, const char *command) {
      10*: 2823:    assert(c != NULL);
        -: 2824:
       10: 2825:    if (strcmp(command, "on") == 0) {
        1: 2826:        settings.detail_enabled = 1;
        1: 2827:        out_string(c, "OK");
        -: 2828:    }
        9: 2829:    else if (strcmp(command, "off") == 0) {
        1: 2830:        settings.detail_enabled = 0;
        1: 2831:        out_string(c, "OK");
        -: 2832:    }
        8: 2833:    else if (strcmp(command, "dump") == 0) {
        8: 2834:        int len;
        8: 2835:        char *stats = stats_prefix_dump(&len);
        8: 2836:        write_and_free(c, stats, len);
        -: 2837:    }
        -: 2838:    else {
    #####: 2839:        out_string(c, "CLIENT_ERROR usage: stats detail on|off|dump");
        -: 2840:    }
       10: 2841:}
        -: 2842:
        -: 2843:/* return server specific stats only */
     2770: 2844:static void server_stats(ADD_STAT add_stats, conn *c) {
     2770: 2845:    pid_t pid = getpid();
     2770: 2846:    rel_time_t now = current_time;
        -: 2847:
     2770: 2848:    struct thread_stats thread_stats;
     2770: 2849:    threadlocal_stats_aggregate(&thread_stats);
     2770: 2850:    struct slab_stats slab_stats;
     2770: 2851:    slab_stats_aggregate(&thread_stats, &slab_stats);
        -: 2852:
        -: 2853:#ifndef WIN32
     2770: 2854:    struct rusage usage;
     2770: 2855:    getrusage(RUSAGE_SELF, &usage);
        -: 2856:#endif /* !WIN32 */
        -: 2857:
     2770: 2858:    STATS_LOCK();
        -: 2859:
     2770: 2860:    APPEND_STAT("pid", "%lu", (long)pid);
     2770: 2861:    APPEND_STAT("uptime", "%u", now - ITEM_UPDATE_INTERVAL);
     2770: 2862:    APPEND_STAT("time", "%ld", now + (long)process_started);
     2770: 2863:    APPEND_STAT("version", "%s", VERSION);
     2770: 2864:    APPEND_STAT("libevent", "%s", event_get_version());
     2770: 2865:    APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));
        -: 2866:
        -: 2867:#ifndef WIN32
     2770: 2868:    append_stat("rusage_user", add_stats, c, "%ld.%06ld",
     2770: 2869:                (long)usage.ru_utime.tv_sec,
     2770: 2870:                (long)usage.ru_utime.tv_usec);
     2770: 2871:    append_stat("rusage_system", add_stats, c, "%ld.%06ld",
     2770: 2872:                (long)usage.ru_stime.tv_sec,
     2770: 2873:                (long)usage.ru_stime.tv_usec);
        -: 2874:#endif /* !WIN32 */
        -: 2875:
     2770: 2876:    APPEND_STAT("curr_connections", "%llu", (unsigned long long)stats_state.curr_conns - 1);
     2770: 2877:    APPEND_STAT("total_connections", "%llu", (unsigned long long)stats.total_conns);
     2770: 2878:    if (settings.maxconns_fast) {
        2: 2879:        APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
        -: 2880:    }
     2770: 2881:    APPEND_STAT("connection_structures", "%u", stats_state.conn_structs);
     2770: 2882:    APPEND_STAT("reserved_fds", "%u", stats_state.reserved_fds);
     2770: 2883:    APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
     2770: 2884:    APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
     2770: 2885:    APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
     2770: 2886:    APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
     2770: 2887:    APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
     2770: 2888:    APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
     2770: 2889:    APPEND_STAT("get_expired", "%llu", (unsigned long long)thread_stats.get_expired);
     2770: 2890:    APPEND_STAT("get_flushed", "%llu", (unsigned long long)thread_stats.get_flushed);
     2770: 2891:    APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
     2770: 2892:    APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
     2770: 2893:    APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
     2770: 2894:    APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
     2770: 2895:    APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
     2770: 2896:    APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
     2770: 2897:    APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
     2770: 2898:    APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
     2770: 2899:    APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
     2770: 2900:    APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
     2770: 2901:    APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
     2770: 2902:    APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
     2770: 2903:    APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
     2770: 2904:    if (settings.idle_timeout) {
        9: 2905:        APPEND_STAT("idle_kicks", "%llu", (unsigned long long)thread_stats.idle_kicks);
        -: 2906:    }
     2770: 2907:    APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
     2770: 2908:    APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
     2770: 2909:    APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
     2770: 2910:    APPEND_STAT("accepting_conns", "%u", stats_state.accepting_conns);
     2770: 2911:    APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
     2770: 2912:    APPEND_STAT("time_in_listen_disabled_us", "%llu", stats.time_in_listen_disabled_us);
     2770: 2913:    APPEND_STAT("threads", "%d", settings.num_threads);
     2770: 2914:    APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
     2770: 2915:    APPEND_STAT("hash_power_level", "%u", stats_state.hash_power_level);
     2770: 2916:    APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats_state.hash_bytes);
     2770: 2917:    APPEND_STAT("hash_is_expanding", "%u", stats_state.hash_is_expanding);
     2770: 2918:    if (settings.slab_reassign) {
       16: 2919:        APPEND_STAT("slab_reassign_rescues", "%llu", stats.slab_reassign_rescues);
       16: 2920:        APPEND_STAT("slab_reassign_chunk_rescues", "%llu", stats.slab_reassign_chunk_rescues);
       16: 2921:        APPEND_STAT("slab_reassign_evictions_nomem", "%llu", stats.slab_reassign_evictions_nomem);
       16: 2922:        APPEND_STAT("slab_reassign_inline_reclaim", "%llu", stats.slab_reassign_inline_reclaim);
       16: 2923:        APPEND_STAT("slab_reassign_busy_items", "%llu", stats.slab_reassign_busy_items);
       16: 2924:        APPEND_STAT("slab_reassign_running", "%u", stats_state.slab_reassign_running);
       16: 2925:        APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
        -: 2926:    }
     2770: 2927:    if (settings.lru_crawler) {
       20: 2928:        APPEND_STAT("lru_crawler_running", "%u", stats_state.lru_crawler_running);
       20: 2929:        APPEND_STAT("lru_crawler_starts", "%u", stats.lru_crawler_starts);
        -: 2930:    }
     2770: 2931:    if (settings.lru_maintainer_thread) {
       17: 2932:        APPEND_STAT("lru_maintainer_juggles", "%llu", (unsigned long long)stats.lru_maintainer_juggles);
        -: 2933:    }
     2770: 2934:    APPEND_STAT("malloc_fails", "%llu",
     2770: 2935:                (unsigned long long)stats.malloc_fails);
     2770: 2936:    APPEND_STAT("log_worker_dropped", "%llu", (unsigned long long)stats.log_worker_dropped);
     2770: 2937:    APPEND_STAT("log_worker_written", "%llu", (unsigned long long)stats.log_worker_written);
     2770: 2938:    APPEND_STAT("log_watcher_skipped", "%llu", (unsigned long long)stats.log_watcher_skipped);
     2770: 2939:    APPEND_STAT("log_watcher_sent", "%llu", (unsigned long long)stats.log_watcher_sent);
     2770: 2940:    STATS_UNLOCK();
     2770: 2941:}
        -: 2942:
       17: 2943:static void process_stat_settings(ADD_STAT add_stats, void *c) {
      17*: 2944:    assert(add_stats);
       17: 2945:    APPEND_STAT("maxbytes", "%llu", (unsigned long long)settings.maxbytes);
       17: 2946:    APPEND_STAT("maxconns", "%d", settings.maxconns);
       17: 2947:    APPEND_STAT("tcpport", "%d", settings.port);
       17: 2948:    APPEND_STAT("udpport", "%d", settings.udpport);
       17: 2949:    APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
       17: 2950:    APPEND_STAT("verbosity", "%d", settings.verbose);
       17: 2951:    APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
       17: 2952:    APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
       17: 2953:    APPEND_STAT("domain_socket", "%s",
       17: 2954:                settings.socketpath ? settings.socketpath : "NULL");
       17: 2955:    APPEND_STAT("umask", "%o", settings.access);
       17: 2956:    APPEND_STAT("growth_factor", "%.2f", settings.factor);
       17: 2957:    APPEND_STAT("chunk_size", "%d", settings.chunk_size);
       17: 2958:    APPEND_STAT("num_threads", "%d", settings.num_threads);
       17: 2959:    APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
       17: 2960:    APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
       33: 2961:    APPEND_STAT("detail_enabled", "%s",
       17: 2962:                settings.detail_enabled ? "yes" : "no");
       17: 2963:    APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
       18: 2964:    APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
       17: 2965:    APPEND_STAT("tcp_backlog", "%d", settings.backlog);
       34: 2966:    APPEND_STAT("binding_protocol", "%s",
       17: 2967:                prot_text(settings.binding_protocol));
       34: 2968:    APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
       17: 2969:    APPEND_STAT("item_size_max", "%d", settings.item_size_max);
       32: 2970:    APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
       17: 2971:    APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
       31: 2972:    APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
       17: 2973:    APPEND_STAT("slab_automove", "%d", settings.slab_automove);
       17: 2974:    APPEND_STAT("slab_chunk_max", "%d", settings.slab_chunk_size_max);
       30: 2975:    APPEND_STAT("lru_crawler", "%s", settings.lru_crawler ? "yes" : "no");
       17: 2976:    APPEND_STAT("lru_crawler_sleep", "%d", settings.lru_crawler_sleep);
       17: 2977:    APPEND_STAT("lru_crawler_tocrawl", "%lu", (unsigned long)settings.lru_crawler_tocrawl);
       17: 2978:    APPEND_STAT("tail_repair_time", "%d", settings.tail_repair_time);
       17: 2979:    APPEND_STAT("flush_enabled", "%s", settings.flush_enabled ? "yes" : "no");
       17: 2980:    APPEND_STAT("dump_enabled", "%s", settings.dump_enabled ? "yes" : "no");
       17: 2981:    APPEND_STAT("hash_algorithm", "%s", settings.hash_algorithm);
       31: 2982:    APPEND_STAT("lru_maintainer_thread", "%s", settings.lru_maintainer_thread ? "yes" : "no");
       17: 2983:    APPEND_STAT("hot_lru_pct", "%d", settings.hot_lru_pct);
       17: 2984:    APPEND_STAT("warm_lru_pct", "%d", settings.warm_lru_pct);
       33: 2985:    APPEND_STAT("expirezero_does_not_evict", "%s", settings.expirezero_does_not_evict ? "yes" : "no");
       17: 2986:    APPEND_STAT("idle_timeout", "%d", settings.idle_timeout);
       17: 2987:    APPEND_STAT("watcher_logbuf_size", "%u", settings.logger_watcher_buf_size);
       17: 2988:    APPEND_STAT("worker_logbuf_size", "%u", settings.logger_buf_size);
       34: 2989:    APPEND_STAT("track_sizes", "%s", item_stats_sizes_status() ? "yes" : "no");
       17: 2990:}
        -: 2991:
       15: 2992:static void conn_to_str(const conn *c, char *buf) {
       15: 2993:    char addr_text[MAXPATHLEN];
        -: 2994:
       15: 2995:    if (!c) {
    #####: 2996:        strcpy(buf, "<null>");
       15: 2997:    } else if (c->state == conn_closed) {
    #####: 2998:        strcpy(buf, "<closed>");
        -: 2999:    } else {
       15: 3000:        const char *protoname = "?";
       15: 3001:        struct sockaddr_in6 local_addr;
       15: 3002:        struct sockaddr *addr = (void *)&c->request_addr;
       15: 3003:        int af;
       15: 3004:        unsigned short port = 0;
        -: 3005:
        -: 3006:        /* For listen ports and idle UDP ports, show listen address */
       15: 3007:        if (c->state == conn_listening ||
       12: 3008:                (IS_UDP(c->transport) &&
        -: 3009:                 c->state == conn_read)) {
       11: 3010:            socklen_t local_addr_len = sizeof(local_addr);
        -: 3011:
       11: 3012:            if (getsockname(c->sfd,
        -: 3013:                        (struct sockaddr *)&local_addr,
        -: 3014:                        &local_addr_len) == 0) {
       11: 3015:                addr = (struct sockaddr *)&local_addr;
        -: 3016:            }
        -: 3017:        }
        -: 3018:
       15: 3019:        af = addr->sa_family;
       15: 3020:        addr_text[0] = '\0';
        -: 3021:
       15: 3022:        switch (af) {
        7: 3023:            case AF_INET:
        7: 3024:                (void) inet_ntop(af,
        7: 3025:                        &((struct sockaddr_in *)addr)->sin_addr,
        -: 3026:                        addr_text,
        -: 3027:                        sizeof(addr_text) - 1);
        7: 3028:                port = ntohs(((struct sockaddr_in *)addr)->sin_port);
        7: 3029:                protoname = IS_UDP(c->transport) ? "udp" : "tcp";
        -: 3030:                break;
        -: 3031:
        5: 3032:            case AF_INET6:
        5: 3033:                addr_text[0] = '[';
        5: 3034:                addr_text[1] = '\0';
        5: 3035:                if (inet_ntop(af,
        5: 3036:                        &((struct sockaddr_in6 *)addr)->sin6_addr,
        -: 3037:                        addr_text + 1,
        -: 3038:                        sizeof(addr_text) - 2)) {
        5: 3039:                    strcat(addr_text, "]");
        -: 3040:                }
        5: 3041:                port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
        5: 3042:                protoname = IS_UDP(c->transport) ? "udp6" : "tcp6";
        -: 3043:                break;
        -: 3044:
        1: 3045:            case AF_UNIX:
        1: 3046:                strncpy(addr_text,
        1: 3047:                        ((struct sockaddr_un *)addr)->sun_path,
        -: 3048:                        sizeof(addr_text) - 1);
        1: 3049:                addr_text[sizeof(addr_text)-1] = '\0';
        1: 3050:                protoname = "unix";
        1: 3051:                break;
        -: 3052:        }
        -: 3053:
       15: 3054:        if (strlen(addr_text) < 2) {
        -: 3055:            /* Most likely this is a connected UNIX-domain client which
        -: 3056:             * has no peer socket address, but there's no portable way
        -: 3057:             * to tell for sure.
        -: 3058:             */
        2: 3059:            sprintf(addr_text, "<AF %d>", af);
        -: 3060:        }
        -: 3061:
       15: 3062:        if (port) {
       12: 3063:            sprintf(buf, "%s:%s:%u", protoname, addr_text, port);
        -: 3064:        } else {
       15: 3065:            sprintf(buf, "%s:%s", protoname, addr_text);
        -: 3066:        }
        -: 3067:    }
       15: 3068:}
        -: 3069:
        2: 3070:static void process_stats_conns(ADD_STAT add_stats, void *c) {
        2: 3071:    int i;
        2: 3072:    char key_str[STAT_KEY_LEN];
        2: 3073:    char val_str[STAT_VAL_LEN];
        2: 3074:    char conn_name[MAXPATHLEN + sizeof("unix:")];
        2: 3075:    int klen = 0, vlen = 0;
        -: 3076:
       2*: 3077:    assert(add_stats);
        -: 3078:
     2050: 3079:    for (i = 0; i < max_fds; i++) {
     2048: 3080:        if (conns[i]) {
        -: 3081:            /* This is safe to do unlocked because conns are never freed; the
        -: 3082:             * worst that'll happen will be a minor inconsistency in the
        -: 3083:             * output -- not worth the complexity of the locking that'd be
        -: 3084:             * required to prevent it.
        -: 3085:             */
       15: 3086:            if (conns[i]->state != conn_closed) {
       15: 3087:                conn_to_str(conns[i], conn_name);
        -: 3088:
       15: 3089:                APPEND_NUM_STAT(i, "addr", "%s", conn_name);
       15: 3090:                APPEND_NUM_STAT(i, "state", "%s",
       15: 3091:                        state_text(conns[i]->state));
       15: 3092:                APPEND_NUM_STAT(i, "secs_since_last_cmd", "%d",
     2048: 3093:                        current_time - conns[i]->last_cmd_time);
        -: 3094:            }
        -: 3095:        }
        -: 3096:    }
        2: 3097:}
        -: 3098:
     2818: 3099:static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
     2818: 3100:    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    2818*: 3101:    assert(c != NULL);
        -: 3102:
     2818: 3103:    if (ntokens < 2) {
    #####: 3104:        out_string(c, "CLIENT_ERROR bad command line");
    #####: 3105:        return;
        -: 3106:    }
        -: 3107:
     2818: 3108:    if (ntokens == 2) {
     2748: 3109:        server_stats(&append_stats, c);
     2748: 3110:        (void)get_stats(NULL, 0, &append_stats, c);
       70: 3111:    } else if (strcmp(subcommand, "reset") == 0) {
        3: 3112:        stats_reset();
        3: 3113:        out_string(c, "RESET");
        3: 3114:        return ;
       67: 3115:    } else if (strcmp(subcommand, "detail") == 0) {
        -: 3116:        /* NOTE: how to tackle detail with binary? */
       10: 3117:        if (ntokens < 4)
    #####: 3118:            process_stats_detail(c, "");  /* outputs the error message */
        -: 3119:        else
       10: 3120:            process_stats_detail(c, tokens[2].value);
        -: 3121:        /* Output already generated */
       10: 3122:        return ;
       57: 3123:    } else if (strcmp(subcommand, "settings") == 0) {
       16: 3124:        process_stat_settings(&append_stats, c);
       41: 3125:    } else if (strcmp(subcommand, "cachedump") == 0) {
        3: 3126:        char *buf;
        3: 3127:        unsigned int bytes, id, limit = 0;
        -: 3128:
        3: 3129:        if (!settings.dump_enabled) {
    #####: 3130:            out_string(c, "CLIENT_ERROR stats cachedump not allowed");
    #####: 3131:            return;
        -: 3132:        }
        -: 3133:
        3: 3134:        if (ntokens < 5) {
    #####: 3135:            out_string(c, "CLIENT_ERROR bad command line");
    #####: 3136:            return;
        -: 3137:        }
        -: 3138:
        6: 3139:        if (!safe_strtoul(tokens[2].value, &id) ||
        3: 3140:            !safe_strtoul(tokens[3].value, &limit)) {
    #####: 3141:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3142:            return;
        -: 3143:        }
        -: 3144:
        3: 3145:        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
        1: 3146:            out_string(c, "CLIENT_ERROR Illegal slab id");
        1: 3147:            return;
        -: 3148:        }
        -: 3149:
        2: 3150:        buf = item_cachedump(id, limit, &bytes);
        2: 3151:        write_and_free(c, buf, bytes);
        2: 3152:        return ;
       38: 3153:    } else if (strcmp(subcommand, "conns") == 0) {
        2: 3154:        process_stats_conns(&append_stats, c);
        -: 3155:    } else {
        -: 3156:        /* getting here means that the subcommand is either engine specific or
        -: 3157:           is invalid. query the engine and see. */
       36: 3158:        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
       36: 3159:            if (c->stats.buffer == NULL) {
    #####: 3160:                out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3161:            } else {
       36: 3162:                write_and_free(c, c->stats.buffer, c->stats.offset);
       36: 3163:                c->stats.buffer = NULL;
        -: 3164:            }
        -: 3165:        } else {
    #####: 3166:            out_string(c, "ERROR");
        -: 3167:        }
       36: 3168:        return ;
        -: 3169:    }
        -: 3170:
        -: 3171:    /* append terminator and start the transfer */
     2766: 3172:    append_stats(NULL, 0, NULL, 0, c);
        -: 3173:
     2766: 3174:    if (c->stats.buffer == NULL) {
    #####: 3175:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3176:    } else {
     2766: 3177:        write_and_free(c, c->stats.buffer, c->stats.offset);
     2766: 3178:        c->stats.buffer = NULL;
        -: 3179:    }
        -: 3180:}
        -: 3181:
        -: 3182:/* ntokens is overwritten here... shrug.. */
   112218: 3183:static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {
   112218: 3184:    char *key;
   112218: 3185:    size_t nkey;
   112218: 3186:    int i = 0;
   112218: 3187:    item *it;
   112218: 3188:    token_t *key_token = &tokens[KEY_TOKEN];
   112218: 3189:    char *suffix;
  112218*: 3190:    assert(c != NULL);
        -: 3191:
        -: 3192:    do {
   225397: 3193:        while(key_token->length != 0) {
        -: 3194:
   113060: 3195:            key = key_token->value;
   113060: 3196:            nkey = key_token->length;
        -: 3197:
   113060: 3198:            if(nkey > KEY_MAX_LENGTH) {
        1: 3199:                out_string(c, "CLIENT_ERROR bad command line format");
        2: 3200:                while (i-- > 0) {
        1: 3201:                    item_remove(*(c->ilist + i));
        -: 3202:                }
        -: 3203:                return;
        -: 3204:            }
        -: 3205:
   113059: 3206:            it = item_get(key, nkey, c);
   113059: 3207:            if (settings.detail_enabled) {
        3: 3208:                stats_prefix_record_get(key, nkey, NULL != it);
        -: 3209:            }
   113059: 3210:            if (it) {
    31448: 3211:                if (i >= c->isize) {
    #####: 3212:                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
    #####: 3213:                    if (new_list) {
    #####: 3214:                        c->isize *= 2;
    #####: 3215:                        c->ilist = new_list;
        -: 3216:                    } else {
    #####: 3217:                        STATS_LOCK();
    #####: 3218:                        stats.malloc_fails++;
    #####: 3219:                        STATS_UNLOCK();
    #####: 3220:                        item_remove(it);
    #####: 3221:                        break;
        -: 3222:                    }
        -: 3223:                }
        -: 3224:
        -: 3225:                /*
        -: 3226:                 * Construct the response. Each hit adds three elements to the
        -: 3227:                 * outgoing data list:
        -: 3228:                 *   "VALUE "
        -: 3229:                 *   key
        -: 3230:                 *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
        -: 3231:                 */
        -: 3232:
    31448: 3233:                if (return_cas)
        -: 3234:                {
        -: 3235:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
       17: 3236:                                        it->nbytes, ITEM_get_cas(it));
        -: 3237:                  /* Goofy mid-flight realloc. */
       17: 3238:                  if (i >= c->suffixsize) {
    #####: 3239:                    char **new_suffix_list = realloc(c->suffixlist,
    #####: 3240:                                           sizeof(char *) * c->suffixsize * 2);
    #####: 3241:                    if (new_suffix_list) {
    #####: 3242:                        c->suffixsize *= 2;
    #####: 3243:                        c->suffixlist  = new_suffix_list;
        -: 3244:                    } else {
    #####: 3245:                        STATS_LOCK();
    #####: 3246:                        stats.malloc_fails++;
    #####: 3247:                        STATS_UNLOCK();
    #####: 3248:                        item_remove(it);
    #####: 3249:                        break;
        -: 3250:                    }
        -: 3251:                  }
        -: 3252:
       17: 3253:                  suffix = cache_alloc(c->thread->suffix_cache);
       17: 3254:                  if (suffix == NULL) {
    #####: 3255:                      STATS_LOCK();
    #####: 3256:                      stats.malloc_fails++;
    #####: 3257:                      STATS_UNLOCK();
    #####: 3258:                      out_of_memory(c, "SERVER_ERROR out of memory making CAS suffix");
    #####: 3259:                      item_remove(it);
    #####: 3260:                      while (i-- > 0) {
    #####: 3261:                          item_remove(*(c->ilist + i));
        -: 3262:                      }
        -: 3263:                      return;
        -: 3264:                  }
       17: 3265:                  *(c->suffixlist + i) = suffix;
       17: 3266:                  int suffix_len = snprintf(suffix, SUFFIX_SIZE,
        -: 3267:                                            " %llu\r\n",
       17: 3268:                                            (unsigned long long)ITEM_get_cas(it));
       34: 3269:                  if (add_iov(c, "VALUE ", 6) != 0 ||
       34: 3270:                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||
       34: 3271:                      add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0 ||
       17: 3272:                      add_iov(c, suffix, suffix_len) != 0)
        -: 3273:                      {
    #####: 3274:                          item_remove(it);
    #####: 3275:                          break;
        -: 3276:                      }
       17: 3277:                  if ((it->it_flags & ITEM_CHUNKED) == 0) {
       17: 3278:                      add_iov(c, ITEM_data(it), it->nbytes);
    #####: 3279:                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
    #####: 3280:                      item_remove(it);
    #####: 3281:                      break;
        -: 3282:                  }
        -: 3283:                }
        -: 3284:                else
        -: 3285:                {
        -: 3286:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    31431: 3287:                                        it->nbytes, ITEM_get_cas(it));
    62862: 3288:                  if (add_iov(c, "VALUE ", 6) != 0 ||
    31431: 3289:                      add_iov(c, ITEM_key(it), it->nkey) != 0)
        -: 3290:                      {
    #####: 3291:                          item_remove(it);
    #####: 3292:                          break;
        -: 3293:                      }
    31431: 3294:                  if ((it->it_flags & ITEM_CHUNKED) == 0)
        -: 3295:                      {
    12950: 3296:                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)
        -: 3297:                          {
    #####: 3298:                              item_remove(it);
    #####: 3299:                              break;
        -: 3300:                          }
    36962: 3301:                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||
    18481: 3302:                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {
    #####: 3303:                          item_remove(it);
    #####: 3304:                          break;
        -: 3305:                      }
        -: 3306:                }
        -: 3307:
        -: 3308:
    31448: 3309:                if (settings.verbose > 1) {
    #####: 3310:                    int ii;
    #####: 3311:                    fprintf(stderr, ">%d sending key ", c->sfd);
    #####: 3312:                    for (ii = 0; ii < it->nkey; ++ii) {
    #####: 3313:                        fprintf(stderr, "%c", key[ii]);
        -: 3314:                    }
    #####: 3315:                    fprintf(stderr, "\n");
        -: 3316:                }
        -: 3317:
        -: 3318:                /* item_get() has incremented it->refcount for us */
    31448: 3319:                pthread_mutex_lock(&c->thread->stats.mutex);
    31448: 3320:                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;
    31448: 3321:                c->thread->stats.get_cmds++;
    31448: 3322:                pthread_mutex_unlock(&c->thread->stats.mutex);
    31448: 3323:                item_update(it);
    31448: 3324:                *(c->ilist + i) = it;
    31448: 3325:                i++;
        -: 3326:
        -: 3327:            } else {
    81611: 3328:                pthread_mutex_lock(&c->thread->stats.mutex);
    81611: 3329:                c->thread->stats.get_misses++;
    81611: 3330:                c->thread->stats.get_cmds++;
    81611: 3331:                pthread_mutex_unlock(&c->thread->stats.mutex);
   113059: 3332:                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 3333:            }
        -: 3334:
   113059: 3335:            key_token++;
        -: 3336:        }
        -: 3337:
        -: 3338:        /*
        -: 3339:         * If the command string hasn't been fully processed, get the next set
        -: 3340:         * of tokens.
        -: 3341:         */
   112337: 3342:        if(key_token->value != NULL) {
      120: 3343:            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
      120: 3344:            key_token = tokens;
        -: 3345:        }
        -: 3346:
   112337: 3347:    } while(key_token->value != NULL);
        -: 3348:
   112217: 3349:    c->icurr = c->ilist;
   112217: 3350:    c->ileft = i;
   112217: 3351:    if (return_cas) {
       18: 3352:        c->suffixcurr = c->suffixlist;
       18: 3353:        c->suffixleft = i;
        -: 3354:    }
        -: 3355:
   112217: 3356:    if (settings.verbose > 1)
    #####: 3357:        fprintf(stderr, ">%d END\n", c->sfd);
        -: 3358:
        -: 3359:    /*
        -: 3360:        If the loop was terminated because of out-of-memory, it is not
        -: 3361:        reliable to add END\r\n to the buffer, because it might not end
        -: 3362:        in \r\n. So we send SERVER_ERROR instead.
        -: 3363:    */
   112217: 3364:    if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
   112217: 3365:        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
    #####: 3366:        out_of_memory(c, "SERVER_ERROR out of memory writing get response");
        -: 3367:    }
        -: 3368:    else {
   112217: 3369:        conn_set_state(c, conn_mwrite);
   112217: 3370:        c->msgcurr = 0;
        -: 3371:    }
        -: 3372:}
        -: 3373:
    82099: 3374:static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
    82099: 3375:    char *key;
    82099: 3376:    size_t nkey;
    82099: 3377:    unsigned int flags;
    82099: 3378:    int32_t exptime_int = 0;
    82099: 3379:    time_t exptime;
    82099: 3380:    int vlen;
    82099: 3381:    uint64_t req_cas_id=0;
    82099: 3382:    item *it;
        -: 3383:
   82099*: 3384:    assert(c != NULL);
        -: 3385:
    82099: 3386:    set_noreply_maybe(c, tokens, ntokens);
        -: 3387:
    82099: 3388:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 3389:        out_string(c, "CLIENT_ERROR bad command line format");
      19*: 3390:        return;
        -: 3391:    }
        -: 3392:
    82099: 3393:    key = tokens[KEY_TOKEN].value;
    82099: 3394:    nkey = tokens[KEY_TOKEN].length;
        -: 3395:
   164196: 3396:    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
    82098: 3397:           && safe_strtol(tokens[3].value, &exptime_int)
    82097: 3398:           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
        3: 3399:        out_string(c, "CLIENT_ERROR bad command line format");
        3: 3400:        return;
        -: 3401:    }
        -: 3402:
        -: 3403:    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */
    82096: 3404:    exptime = exptime_int;
        -: 3405:
        -: 3406:    /* Negative exptimes can underflow and end up immortal. realtime() will
        -: 3407:       immediately expire values that are greater than REALTIME_MAXDELTA, but less
        -: 3408:       than process_started, so lets aim for that. */
    82096: 3409:    if (exptime < 0)
    #####: 3410:        exptime = REALTIME_MAXDELTA + 1;
        -: 3411:
        -: 3412:    // does cas value exist?
    82096: 3413:    if (handle_cas) {
       13: 3414:        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
        1: 3415:            out_string(c, "CLIENT_ERROR bad command line format");
        1: 3416:            return;
        -: 3417:        }
        -: 3418:    }
        -: 3419:
    82095: 3420:    if (vlen < 0 || vlen > (INT_MAX - 2)) {
        3: 3421:        out_string(c, "CLIENT_ERROR bad command line format");
        3: 3422:        return;
        -: 3423:    }
    82092: 3424:    vlen += 2;
        -: 3425:
    82092: 3426:    if (settings.detail_enabled) {
      101: 3427:        stats_prefix_record_set(key, nkey);
        -: 3428:    }
        -: 3429:
    82372: 3430:    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
        -: 3431:
    82092: 3432:    if (it == 0) {
       12: 3433:        enum store_item_type status;
       12: 3434:        if (! item_size_ok(nkey, flags, vlen)) {
        3: 3435:            out_string(c, "SERVER_ERROR object too large for cache");
        3: 3436:            status = TOO_LARGE;
        -: 3437:        } else {
        9: 3438:            out_of_memory(c, "SERVER_ERROR out of memory storing object");
        9: 3439:            status = NO_MEMORY;
        -: 3440:        }
      12*: 3441:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 3442:                NULL, status, comm, key, nkey, 0, 0);
        -: 3443:        /* swallow the data line */
       12: 3444:        c->write_and_go = conn_swallow;
       12: 3445:        c->sbytes = vlen;
        -: 3446:
        -: 3447:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 3448:         * Unacceptable for SET. Anywhere else too? */
       12: 3449:        if (comm == NREAD_SET) {
       12: 3450:            it = item_get(key, nkey, c);
       12: 3451:            if (it) {
        2: 3452:                item_unlink(it);
        2: 3453:                item_remove(it);
        -: 3454:            }
        -: 3455:        }
        -: 3456:
       12: 3457:        return;
        -: 3458:    }
    82080: 3459:    ITEM_set_cas(it, req_cas_id);
        -: 3460:
    82080: 3461:    c->item = it;
    82080: 3462:    c->ritem = ITEM_data(it);
    82080: 3463:    c->rlbytes = it->nbytes;
    82080: 3464:    c->cmd = comm;
    82080: 3465:    conn_set_state(c, conn_nread);
        -: 3466:}
        -: 3467:
        1: 3468:static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
        1: 3469:    char *key;
        1: 3470:    size_t nkey;
        1: 3471:    int32_t exptime_int = 0;
        1: 3472:    item *it;
        -: 3473:
       1*: 3474:    assert(c != NULL);
        -: 3475:
        1: 3476:    set_noreply_maybe(c, tokens, ntokens);
        -: 3477:
        1: 3478:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 3479:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3480:        return;
        -: 3481:    }
        -: 3482:
        1: 3483:    key = tokens[KEY_TOKEN].value;
        1: 3484:    nkey = tokens[KEY_TOKEN].length;
        -: 3485:
        1: 3486:    if (!safe_strtol(tokens[2].value, &exptime_int)) {
    #####: 3487:        out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 3488:        return;
        -: 3489:    }
        -: 3490:
        2: 3491:    it = item_touch(key, nkey, realtime(exptime_int), c);
        1: 3492:    if (it) {
        1: 3493:        item_update(it);
        1: 3494:        pthread_mutex_lock(&c->thread->stats.mutex);
        1: 3495:        c->thread->stats.touch_cmds++;
        1: 3496:        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        1: 3497:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3498:
        1: 3499:        out_string(c, "TOUCHED");
        1: 3500:        item_remove(it);
        -: 3501:    } else {
    #####: 3502:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 3503:        c->thread->stats.touch_cmds++;
    #####: 3504:        c->thread->stats.touch_misses++;
    #####: 3505:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3506:
    #####: 3507:        out_string(c, "NOT_FOUND");
        -: 3508:    }
        -: 3509:}
        -: 3510:
      272: 3511:static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
      272: 3512:    char temp[INCR_MAX_STORAGE_LEN];
      272: 3513:    uint64_t delta;
      272: 3514:    char *key;
      272: 3515:    size_t nkey;
        -: 3516:
     272*: 3517:    assert(c != NULL);
        -: 3518:
      272: 3519:    set_noreply_maybe(c, tokens, ntokens);
        -: 3520:
      272: 3521:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 3522:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3523:        return;
        -: 3524:    }
        -: 3525:
      272: 3526:    key = tokens[KEY_TOKEN].value;
      272: 3527:    nkey = tokens[KEY_TOKEN].length;
        -: 3528:
      272: 3529:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 3530:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 3531:        return;
        -: 3532:    }
        -: 3533:
      272: 3534:    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
      267: 3535:    case OK:
      267: 3536:        out_string(c, temp);
      267: 3537:        break;
        1: 3538:    case NON_NUMERIC:
        1: 3539:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
        1: 3540:        break;
    #####: 3541:    case EOM:
    #####: 3542:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 3543:        break;
        4: 3544:    case DELTA_ITEM_NOT_FOUND:
        4: 3545:        pthread_mutex_lock(&c->thread->stats.mutex);
        4: 3546:        if (incr) {
        1: 3547:            c->thread->stats.incr_misses++;
        -: 3548:        } else {
        3: 3549:            c->thread->stats.decr_misses++;
        -: 3550:        }
        4: 3551:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3552:
        4: 3553:        out_string(c, "NOT_FOUND");
        4: 3554:        break;
        -: 3555:    case DELTA_ITEM_CAS_MISMATCH:
        -: 3556:        break; /* Should never get here */
        -: 3557:    }
      272: 3558:}
        -: 3559:
        -: 3560:/*
        -: 3561: * adds a delta value to a numeric item.
        -: 3562: *
        -: 3563: * c     connection requesting the operation
        -: 3564: * it    item to adjust
        -: 3565: * incr  true to increment value, false to decrement
        -: 3566: * delta amount to adjust value by
        -: 3567: * buf   buffer for response string
        -: 3568: *
        -: 3569: * returns a response string to send back to the client.
        -: 3570: */
      398: 3571:enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
        -: 3572:                                    const bool incr, const int64_t delta,
        -: 3573:                                    char *buf, uint64_t *cas,
        -: 3574:                                    const uint32_t hv) {
      398: 3575:    char *ptr;
      398: 3576:    uint64_t value;
      398: 3577:    int res;
      398: 3578:    item *it;
        -: 3579:
      398: 3580:    it = do_item_get(key, nkey, hv, c);
      398: 3581:    if (!it) {
        -: 3582:        return DELTA_ITEM_NOT_FOUND;
        -: 3583:    }
        -: 3584:
        -: 3585:    /* Can't delta zero byte values. 2-byte are the "\r\n" */
        -: 3586:    /* Also can't delta for chunked items. Too large to be a number */
      327: 3587:    if (it->nbytes <= 2 || (it->it_flags & ITEM_CHUNKED) != 0) {
        -: 3588:        return NON_NUMERIC;
        -: 3589:    }
        -: 3590:
     327*: 3591:    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
    #####: 3592:        do_item_remove(it);
    #####: 3593:        return DELTA_ITEM_CAS_MISMATCH;
        -: 3594:    }
        -: 3595:
      327: 3596:    ptr = ITEM_data(it);
        -: 3597:
      327: 3598:    if (!safe_strtoull(ptr, &value)) {
        3: 3599:        do_item_remove(it);
        3: 3600:        return NON_NUMERIC;
        -: 3601:    }
        -: 3602:
      324: 3603:    if (incr) {
      291: 3604:        value += delta;
      291: 3605:        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 3606:    } else {
       33: 3607:        if(delta > value) {
        5: 3608:            value = 0;
        -: 3609:        } else {
       28: 3610:            value -= delta;
        -: 3611:        }
      324: 3612:        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 3613:    }
        -: 3614:
      324: 3615:    pthread_mutex_lock(&c->thread->stats.mutex);
      324: 3616:    if (incr) {
      291: 3617:        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
        -: 3618:    } else {
       33: 3619:        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
        -: 3620:    }
      324: 3621:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3622:
      324: 3623:    snprintf(buf, INCR_MAX_STORAGE_LEN, "%llu", (unsigned long long)value);
      324: 3624:    res = strlen(buf);
        -: 3625:    /* refcount == 2 means we are the only ones holding the item, and it is
        -: 3626:     * linked. We hold the item's lock in this function, so refcount cannot
        -: 3627:     * increase. */
      324: 3628:    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */
        -: 3629:        /* When changing the value without replacing the item, we
        -: 3630:           need to update the CAS on the existing item. */
        -: 3631:        /* We also need to fiddle it in the sizes tracker in case the tracking
        -: 3632:         * was enabled at runtime, since it relies on the CAS value to know
        -: 3633:         * whether to remove an item or not. */
       70: 3634:        item_stats_sizes_remove(it);
       70: 3635:        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
       70: 3636:        item_stats_sizes_add(it);
       70: 3637:        memcpy(ITEM_data(it), buf, res);
       70: 3638:        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
       70: 3639:        do_item_update(it);
      254: 3640:    } else if (it->refcount > 1) {
      254: 3641:        item *new_it;
      254: 3642:        uint32_t flags = (uint32_t) strtoul(ITEM_suffix(it)+1, (char **) NULL, 10);
      254: 3643:        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
      254: 3644:        if (new_it == 0) {
    #####: 3645:            do_item_remove(it);
    #####: 3646:            return EOM;
        -: 3647:        }
      254: 3648:        memcpy(ITEM_data(new_it), buf, res);
      254: 3649:        memcpy(ITEM_data(new_it) + res, "\r\n", 2);
      254: 3650:        item_replace(it, new_it, hv);
        -: 3651:        // Overwrite the older item's CAS with our new CAS since we're
        -: 3652:        // returning the CAS of the old item below.
      254: 3653:        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
      254: 3654:        do_item_remove(new_it);       /* release our reference */
        -: 3655:    } else {
        -: 3656:        /* Should never get here. This means we somehow fetched an unlinked
        -: 3657:         * item. TODO: Add a counter? */
    #####: 3658:        if (settings.verbose) {
    #####: 3659:            fprintf(stderr, "Tried to do incr/decr on invalid item\n");
        -: 3660:        }
    #####: 3661:        if (it->refcount == 1)
    #####: 3662:            do_item_remove(it);
    #####: 3663:        return DELTA_ITEM_NOT_FOUND;
        -: 3664:    }
        -: 3665:
      324: 3666:    if (cas) {
       57: 3667:        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
        -: 3668:    }
      324: 3669:    do_item_remove(it);         /* release our reference */
      324: 3670:    return OK;
        -: 3671:}
        -: 3672:
     2672: 3673:static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
     2672: 3674:    char *key;
     2672: 3675:    size_t nkey;
     2672: 3676:    item *it;
        -: 3677:
    2672*: 3678:    assert(c != NULL);
        -: 3679:
     2672: 3680:    if (ntokens > 3) {
     2507: 3681:        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
     2507: 3682:        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
     2505: 3683:        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
     2508: 3684:            || (ntokens == 5 && hold_is_zero && sets_noreply);
     2507: 3685:        if (!valid) {
        2: 3686:            out_string(c, "CLIENT_ERROR bad command line format.  "
        -: 3687:                       "Usage: delete <key> [noreply]");
        2: 3688:            return;
        -: 3689:        }
        -: 3690:    }
        -: 3691:
        -: 3692:
     2670: 3693:    key = tokens[KEY_TOKEN].value;
     2670: 3694:    nkey = tokens[KEY_TOKEN].length;
        -: 3695:
     2670: 3696:    if(nkey > KEY_MAX_LENGTH) {
    #####: 3697:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3698:        return;
        -: 3699:    }
        -: 3700:
     2670: 3701:    if (settings.detail_enabled) {
        1: 3702:        stats_prefix_record_delete(key, nkey);
        -: 3703:    }
        -: 3704:
     2670: 3705:    it = item_get(key, nkey, c);
     2670: 3706:    if (it) {
     2662: 3707:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 3708:
     2662: 3709:        pthread_mutex_lock(&c->thread->stats.mutex);
     2662: 3710:        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
     2662: 3711:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3712:
     2662: 3713:        item_unlink(it);
     2662: 3714:        item_remove(it);      /* release our reference */
     2662: 3715:        out_string(c, "DELETED");
        -: 3716:    } else {
        8: 3717:        pthread_mutex_lock(&c->thread->stats.mutex);
        8: 3718:        c->thread->stats.delete_misses++;
        8: 3719:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3720:
        8: 3721:        out_string(c, "NOT_FOUND");
        -: 3722:    }
        -: 3723:}
        -: 3724:
        1: 3725:static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
        1: 3726:    unsigned int level;
        -: 3727:
       1*: 3728:    assert(c != NULL);
        -: 3729:
        1: 3730:    set_noreply_maybe(c, tokens, ntokens);
        -: 3731:
        1: 3732:    level = strtoul(tokens[1].value, NULL, 10);
        1: 3733:    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
        1: 3734:    out_string(c, "OK");
        1: 3735:    return;
        -: 3736:}
        -: 3737:
    #####: 3738:static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 3739:    unsigned int level;
        -: 3740:
    #####: 3741:    assert(c != NULL);
        -: 3742:
    #####: 3743:    set_noreply_maybe(c, tokens, ntokens);
        -: 3744:
    #####: 3745:    level = strtoul(tokens[2].value, NULL, 10);
    #####: 3746:    if (level == 0) {
    #####: 3747:        settings.slab_automove = 0;
    #####: 3748:    } else if (level == 1 || level == 2) {
    #####: 3749:        settings.slab_automove = level;
        -: 3750:    } else {
    #####: 3751:        out_string(c, "ERROR");
    #####: 3752:        return;
        -: 3753:    }
    #####: 3754:    out_string(c, "OK");
    #####: 3755:    return;
        -: 3756:}
        -: 3757:
        -: 3758:/* TODO: decide on syntax for sampling? */
        3: 3759:static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
        3: 3760:    uint16_t f = 0;
        3: 3761:    int x;
       3*: 3762:    assert(c != NULL);
        -: 3763:
        3: 3764:    set_noreply_maybe(c, tokens, ntokens);
        3: 3765:    if (ntokens > 2) {
        5: 3766:        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
        3: 3767:            if ((strcmp(tokens[x].value, "rawcmds") == 0)) {
    #####: 3768:                f |= LOG_RAWCMDS;
        3: 3769:            } else if ((strcmp(tokens[x].value, "evictions") == 0)) {
        2: 3770:                f |= LOG_EVICTIONS;
        1: 3771:            } else if ((strcmp(tokens[x].value, "fetchers") == 0)) {
    #####: 3772:                f |= LOG_FETCHERS;
        1: 3773:            } else if ((strcmp(tokens[x].value, "mutations") == 0)) {
        1: 3774:                f |= LOG_MUTATIONS;
    #####: 3775:            } else if ((strcmp(tokens[x].value, "sysevents") == 0)) {
    #####: 3776:                f |= LOG_SYSEVENTS;
        -: 3777:            } else {
    #####: 3778:                out_string(c, "ERROR");
    #####: 3779:                return;
        -: 3780:            }
        -: 3781:        }
        -: 3782:    } else {
        -: 3783:        f |= LOG_FETCHERS;
        -: 3784:    }
        -: 3785:
        3: 3786:    switch(logger_add_watcher(c, c->sfd, f)) {
    #####: 3787:        case LOGGER_ADD_WATCHER_TOO_MANY:
    #####: 3788:            out_string(c, "WATCHER_TOO_MANY log watcher limit reached");
    #####: 3789:            break;
    #####: 3790:        case LOGGER_ADD_WATCHER_FAILED:
    #####: 3791:            out_string(c, "WATCHER_FAILED failed to add log watcher");
    #####: 3792:            break;
        3: 3793:        case LOGGER_ADD_WATCHER_OK:
        3: 3794:            conn_set_state(c, conn_watch);
        3: 3795:            event_del(&c->event);
        3: 3796:            break;
        -: 3797:    }
        3: 3798:}
        -: 3799:
        3: 3800:static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
        3: 3801:    uint32_t memlimit;
       3*: 3802:    assert(c != NULL);
        -: 3803:
        3: 3804:    set_noreply_maybe(c, tokens, ntokens);
        -: 3805:
        3: 3806:    if (!safe_strtoul(tokens[1].value, &memlimit)) {
    #####: 3807:        out_string(c, "ERROR");
        -: 3808:    } else {
        3: 3809:        if (memlimit < 8) {
    #####: 3810:            out_string(c, "MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m");
        -: 3811:        } else {
        3: 3812:            if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
        3: 3813:                if (settings.verbose > 0) {
    #####: 3814:                    fprintf(stderr, "maxbytes adjusted to %llum\n", (unsigned long long)memlimit);
        -: 3815:                }
        -: 3816:
        3: 3817:                out_string(c, "OK");
        -: 3818:            } else {
    #####: 3819:                out_string(c, "MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust");
        -: 3820:            }
        -: 3821:        }
        -: 3822:    }
        3: 3823:}
        -: 3824:
   200116: 3825:static void process_command(conn *c, char *command) {
        -: 3826:
   200116: 3827:    token_t tokens[MAX_TOKENS];
   200116: 3828:    size_t ntokens;
   200116: 3829:    int comm;
        -: 3830:
  200116*: 3831:    assert(c != NULL);
        -: 3832:
   200116: 3833:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
        -: 3834:
   200116: 3835:    if (settings.verbose > 1)
    #####: 3836:        fprintf(stderr, "<%d %s\n", c->sfd, command);
        -: 3837:
        -: 3838:    /*
        -: 3839:     * for commands set/add/replace, we build an item and read the data
        -: 3840:     * directly into it, then continue in nread_complete().
        -: 3841:     */
        -: 3842:
   200116: 3843:    c->msgcurr = 0;
   200116: 3844:    c->msgused = 0;
   200116: 3845:    c->iovused = 0;
   200116: 3846:    if (add_msghdr(c) != 0) {
    #####: 3847:        out_of_memory(c, "SERVER_ERROR out of memory preparing response");
    #####: 3848:        return;
        -: 3849:    }
        -: 3850:
   200116: 3851:    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
   200116: 3852:    if (ntokens >= 3 &&
   197355: 3853:        ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
    85155: 3854:         (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) {
        -: 3855:
   112200: 3856:        process_get_command(c, tokens, ntokens, false);
        -: 3857:
    87916: 3858:    } else if ((ntokens == 6 || ntokens == 7) &&
    82100: 3859:               ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
    82087: 3860:                (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
    16025: 3861:                (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
    16022: 3862:                (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
     8020: 3863:                (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
        -: 3864:
    82082: 3865:        process_update_command(c, tokens, ntokens, comm, false);
        -: 3866:
     5834: 3867:    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
        -: 3868:
       16: 3869:        process_update_command(c, tokens, ntokens, comm, true);
        -: 3870:
     5818: 3871:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
        -: 3872:
      262: 3873:        process_arithmetic_command(c, tokens, ntokens, 1);
        -: 3874:
     5556: 3875:    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
        -: 3876:
       18: 3877:        process_get_command(c, tokens, ntokens, true);
        -: 3878:
     5538: 3879:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
        -: 3880:
       10: 3881:        process_arithmetic_command(c, tokens, ntokens, 0);
        -: 3882:
     5528: 3883:    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
        -: 3884:
     2672: 3885:        process_delete_command(c, tokens, ntokens);
        -: 3886:
     2856: 3887:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
        -: 3888:
        1: 3889:        process_touch_command(c, tokens, ntokens);
        -: 3890:
     2855: 3891:    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
        -: 3892:
     2818: 3893:        process_stat(c, tokens, ntokens);
        -: 3894:
       37: 3895:    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
       11: 3896:        time_t exptime = 0;
       11: 3897:        rel_time_t new_oldest = 0;
        -: 3898:
       11: 3899:        set_noreply_maybe(c, tokens, ntokens);
        -: 3900:
       11: 3901:        pthread_mutex_lock(&c->thread->stats.mutex);
       11: 3902:        c->thread->stats.flush_cmds++;
       11: 3903:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3904:
       11: 3905:        if (!settings.flush_enabled) {
        -: 3906:            // flush_all is not allowed but we log it on stats
        1: 3907:            out_string(c, "CLIENT_ERROR flush_all not allowed");
        1: 3908:            return;
        -: 3909:        }
        -: 3910:
       18: 3911:        if (ntokens != (c->noreply ? 3 : 2)) {
        5: 3912:            exptime = strtol(tokens[1].value, NULL, 10);
        5: 3913:            if(errno == ERANGE) {
    #####: 3914:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3915:                return;
        -: 3916:            }
        -: 3917:        }
        -: 3918:
        -: 3919:        /*
        -: 3920:          If exptime is zero realtime() would return zero too, and
        -: 3921:          realtime(exptime) - 1 would overflow to the max unsigned
        -: 3922:          value.  So we process exptime == 0 the same way we do when
        -: 3923:          no delay is given at all.
        -: 3924:        */
        5: 3925:        if (exptime > 0) {
        2: 3926:            new_oldest = realtime(exptime);
        -: 3927:        } else { /* exptime == 0 */
        8: 3928:            new_oldest = current_time;
        -: 3929:        }
        -: 3930:
       10: 3931:        if (settings.use_cas) {
        9: 3932:            settings.oldest_live = new_oldest - 1;
        9: 3933:            if (settings.oldest_live <= current_time)
        7: 3934:                settings.oldest_cas = get_cas_id();
        -: 3935:        } else {
        1: 3936:            settings.oldest_live = new_oldest;
        -: 3937:        }
       10: 3938:        out_string(c, "OK");
       10: 3939:        return;
        -: 3940:
       26: 3941:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
        -: 3942:
        1: 3943:        out_string(c, "VERSION " VERSION);
        -: 3944:
       25: 3945:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
        -: 3946:
    #####: 3947:        conn_set_state(c, conn_closing);
        -: 3948:
       25: 3949:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
        -: 3950:
        1: 3951:        if (settings.shutdown_command) {
        1: 3952:            conn_set_state(c, conn_closing);
        1: 3953:            raise(SIGINT);
        -: 3954:        } else {
    #####: 3955:            out_string(c, "ERROR: shutdown not enabled");
        -: 3956:        }
        -: 3957:
       24: 3958:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
        6: 3959:        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
        6: 3960:            int src, dst, rv;
        -: 3961:
        6: 3962:            if (settings.slab_reassign == false) {
    #####: 3963:                out_string(c, "CLIENT_ERROR slab reassignment disabled");
    #####: 3964:                return;
        -: 3965:            }
        -: 3966:
        6: 3967:            src = strtol(tokens[2].value, NULL, 10);
        6: 3968:            dst = strtol(tokens[3].value, NULL, 10);
        -: 3969:
        6: 3970:            if (errno == ERANGE) {
    #####: 3971:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3972:                return;
        -: 3973:            }
        -: 3974:
        6: 3975:            rv = slabs_reassign(src, dst);
        6: 3976:            switch (rv) {
        6: 3977:            case REASSIGN_OK:
        6: 3978:                out_string(c, "OK");
        6: 3979:                break;
    #####: 3980:            case REASSIGN_RUNNING:
    #####: 3981:                out_string(c, "BUSY currently processing reassign request");
    #####: 3982:                break;
    #####: 3983:            case REASSIGN_BADCLASS:
    #####: 3984:                out_string(c, "BADCLASS invalid src or dst class id");
    #####: 3985:                break;
    #####: 3986:            case REASSIGN_NOSPARE:
    #####: 3987:                out_string(c, "NOSPARE source class has no spare pages");
    #####: 3988:                break;
    #####: 3989:            case REASSIGN_SRC_DST_SAME:
    #####: 3990:                out_string(c, "SAME src and dst class are identical");
    #####: 3991:                break;
        -: 3992:            }
        6: 3993:            return;
    #####: 3994:        } else if (ntokens == 4 &&
    #####: 3995:            (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
    #####: 3996:            process_slabs_automove_command(c, tokens, ntokens);
        -: 3997:        } else {
    #####: 3998:            out_string(c, "ERROR");
        -: 3999:        }
       18: 4000:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
        4: 4001:        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
        2: 4002:            int rv;
        2: 4003:            if (settings.lru_crawler == false) {
    #####: 4004:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4005:                return;
        -: 4006:            }
        -: 4007:
        2: 4008:            rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0);
        2: 4009:            switch(rv) {
        2: 4010:            case CRAWLER_OK:
        2: 4011:                out_string(c, "OK");
        2: 4012:                break;
    #####: 4013:            case CRAWLER_RUNNING:
    #####: 4014:                out_string(c, "BUSY currently processing crawler request");
    #####: 4015:                break;
    #####: 4016:            case CRAWLER_BADCLASS:
    #####: 4017:                out_string(c, "BADCLASS invalid class id");
    #####: 4018:                break;
    #####: 4019:            case CRAWLER_NOTSTARTED:
    #####: 4020:                out_string(c, "NOTSTARTED no items to crawl");
    #####: 4021:                break;
    #####: 4022:            case CRAWLER_ERROR:
    #####: 4023:                out_string(c, "ERROR an unknown error happened");
    #####: 4024:                break;
        -: 4025:            }
        2: 4026:            return;
       2*: 4027:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
    #####: 4028:            if (settings.lru_crawler == false) {
    #####: 4029:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4030:                return;
        -: 4031:            }
    #####: 4032:            if (!settings.dump_enabled) {
    #####: 4033:                out_string(c, "ERROR metadump not allowed");
    #####: 4034:                return;
        -: 4035:            }
        -: 4036:
    #####: 4037:            int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,
        -: 4038:                    c, c->sfd);
    #####: 4039:            switch(rv) {
    #####: 4040:                case CRAWLER_OK:
    #####: 4041:                    out_string(c, "OK");
        -: 4042:                    // TODO: Don't reuse conn_watch here.
    #####: 4043:                    conn_set_state(c, conn_watch);
    #####: 4044:                    event_del(&c->event);
    #####: 4045:                    break;
    #####: 4046:                case CRAWLER_RUNNING:
    #####: 4047:                    out_string(c, "BUSY currently processing crawler request");
    #####: 4048:                    break;
    #####: 4049:                case CRAWLER_BADCLASS:
    #####: 4050:                    out_string(c, "BADCLASS invalid class id");
    #####: 4051:                    break;
    #####: 4052:                case CRAWLER_NOTSTARTED:
    #####: 4053:                    out_string(c, "NOTSTARTED no items to crawl");
    #####: 4054:                    break;
    #####: 4055:                case CRAWLER_ERROR:
    #####: 4056:                    out_string(c, "ERROR an unknown error happened");
    #####: 4057:                    break;
        -: 4058:            }
    #####: 4059:            return;
       2*: 4060:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
    #####: 4061:            uint32_t tocrawl;
    #####: 4062:             if (!safe_strtoul(tokens[2].value, &tocrawl)) {
    #####: 4063:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4064:                return;
        -: 4065:            }
    #####: 4066:            settings.lru_crawler_tocrawl = tocrawl;
    #####: 4067:            out_string(c, "OK");
    #####: 4068:            return;
       2*: 4069:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
    #####: 4070:            uint32_t tosleep;
    #####: 4071:            if (!safe_strtoul(tokens[2].value, &tosleep)) {
    #####: 4072:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4073:                return;
        -: 4074:            }
    #####: 4075:            if (tosleep > 1000000) {
    #####: 4076:                out_string(c, "CLIENT_ERROR sleep must be one second or less");
    #####: 4077:                return;
        -: 4078:            }
    #####: 4079:            settings.lru_crawler_sleep = tosleep;
    #####: 4080:            out_string(c, "OK");
    #####: 4081:            return;
        2: 4082:        } else if (ntokens == 3) {
        2: 4083:            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
        1: 4084:                if (start_item_crawler_thread() == 0) {
        1: 4085:                    out_string(c, "OK");
        -: 4086:                } else {
    #####: 4087:                    out_string(c, "ERROR failed to start lru crawler thread");
        -: 4088:                }
        1: 4089:            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
        1: 4090:                if (stop_item_crawler_thread() == 0) {
        1: 4091:                    out_string(c, "OK");
        -: 4092:                } else {
    #####: 4093:                    out_string(c, "ERROR failed to stop lru crawler thread");
        -: 4094:                }
        -: 4095:            } else {
    #####: 4096:                out_string(c, "ERROR");
        -: 4097:            }
        2: 4098:            return;
        -: 4099:        } else {
    #####: 4100:            out_string(c, "ERROR");
        -: 4101:        }
       14: 4102:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
        3: 4103:        process_watch_command(c, tokens, ntokens);
       11: 4104:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
        3: 4105:        process_memlimit_command(c, tokens, ntokens);
        8: 4106:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
        1: 4107:        process_verbosity_command(c, tokens, ntokens);
        -: 4108:    } else {
        7: 4109:        out_string(c, "ERROR");
        -: 4110:    }
        -: 4111:    return;
        -: 4112:}
        -: 4113:
        -: 4114:/*
        -: 4115: * if we have a complete line in the buffer, process it.
        -: 4116: */
   278254: 4117:static int try_read_command(conn *c) {
  278254*: 4118:    assert(c != NULL);
  278254*: 4119:    assert(c->rcurr <= (c->rbuf + c->rsize));
  278254*: 4120:    assert(c->rbytes > 0);
        -: 4121:
   278254: 4122:    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {
      102: 4123:        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
       15: 4124:            c->protocol = binary_prot;
        -: 4125:        } else {
       87: 4126:            c->protocol = ascii_prot;
        -: 4127:        }
        -: 4128:
      102: 4129:        if (settings.verbose > 1) {
    #####: 4130:            fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
        -: 4131:                    prot_text(c->protocol));
        -: 4132:        }
        -: 4133:    }
        -: 4134:
   278254: 4135:    if (c->protocol == binary_prot) {
        -: 4136:        /* Do we have the complete packet header? */
    78028: 4137:        if (c->rbytes < sizeof(c->binary_header)) {
        -: 4138:            /* need more data! */
        -: 4139:            return 0;
        -: 4140:        } else {
        -: 4141:#ifdef NEED_ALIGN
        -: 4142:            if (((long)(c->rcurr)) % 8 != 0) {
        -: 4143:                /* must realign input buffer */
        -: 4144:                memmove(c->rbuf, c->rcurr, c->rbytes);
        -: 4145:                c->rcurr = c->rbuf;
        -: 4146:                if (settings.verbose > 1) {
        -: 4147:                    fprintf(stderr, "%d: Realign input buffer\n", c->sfd);
        -: 4148:                }
        -: 4149:            }
        -: 4150:#endif
    77020: 4151:            protocol_binary_request_header* req;
    77020: 4152:            req = (protocol_binary_request_header*)c->rcurr;
        -: 4153:
    77020: 4154:            if (settings.verbose > 1) {
        -: 4155:                /* Dump the packet before we convert it to host order */
    #####: 4156:                int ii;
    #####: 4157:                fprintf(stderr, "<%d Read binary protocol data:", c->sfd);
    #####: 4158:                for (ii = 0; ii < sizeof(req->bytes); ++ii) {
    #####: 4159:                    if (ii % 4 == 0) {
    #####: 4160:                        fprintf(stderr, "\n<%d   ", c->sfd);
        -: 4161:                    }
    #####: 4162:                    fprintf(stderr, " 0x%02x", req->bytes[ii]);
        -: 4163:                }
    #####: 4164:                fprintf(stderr, "\n");
        -: 4165:            }
        -: 4166:
    77020: 4167:            c->binary_header = *req;
    77020: 4168:            c->binary_header.request.keylen = ntohs(req->request.keylen);
    77020: 4169:            c->binary_header.request.bodylen = ntohl(req->request.bodylen);
    77020: 4170:            c->binary_header.request.cas = ntohll(req->request.cas);
        -: 4171:
    77020: 4172:            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
        1: 4173:                if (settings.verbose) {
    #####: 4174:                    fprintf(stderr, "Invalid magic:  %x\n",
        -: 4175:                            c->binary_header.request.magic);
        -: 4176:                }
        1: 4177:                conn_set_state(c, conn_closing);
        1: 4178:                return -1;
        -: 4179:            }
        -: 4180:
    77019: 4181:            c->msgcurr = 0;
    77019: 4182:            c->msgused = 0;
    77019: 4183:            c->iovused = 0;
    77019: 4184:            if (add_msghdr(c) != 0) {
    #####: 4185:                out_of_memory(c,
        -: 4186:                        "SERVER_ERROR Out of memory allocating headers");
    #####: 4187:                return 0;
        -: 4188:            }
        -: 4189:
    77019: 4190:            c->cmd = c->binary_header.request.opcode;
    77019: 4191:            c->keylen = c->binary_header.request.keylen;
    77019: 4192:            c->opaque = c->binary_header.request.opaque;
        -: 4193:            /* clear the returned cas value */
    77019: 4194:            c->cas = 0;
        -: 4195:
    77019: 4196:            dispatch_bin_command(c);
        -: 4197:
    77019: 4198:            c->rbytes -= sizeof(c->binary_header);
    77019: 4199:            c->rcurr += sizeof(c->binary_header);
        -: 4200:        }
        -: 4201:    } else {
   200226: 4202:        char *el, *cont;
        -: 4203:
   200226: 4204:        if (c->rbytes == 0)
        -: 4205:            return 0;
        -: 4206:
   200226: 4207:        el = memchr(c->rcurr, '\n', c->rbytes);
   200226: 4208:        if (!el) {
      110: 4209:            if (c->rbytes > 1024) {
        -: 4210:                /*
        -: 4211:                 * We didn't have a '\n' in the first k. This _has_ to be a
        -: 4212:                 * large multiget, if not we should just nuke the connection.
        -: 4213:                 */
        -: 4214:                char *ptr = c->rcurr;
     4200: 4215:                while (*ptr == ' ') { /* ignore leading whitespaces */
     4196: 4216:                    ++ptr;
        -: 4217:                }
        -: 4218:
        4: 4219:                if (ptr - c->rcurr > 100 ||
        2: 4220:                    (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
        -: 4221:
        2: 4222:                    conn_set_state(c, conn_closing);
        2: 4223:                    return 1;
        -: 4224:                }
        -: 4225:            }
        -: 4226:
        -: 4227:            return 0;
        -: 4228:        }
   200116: 4229:        cont = el + 1;
   200116: 4230:        if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
   120039: 4231:            el--;
        -: 4232:        }
   200116: 4233:        *el = '\0';
        -: 4234:
  200116*: 4235:        assert(cont <= (c->rcurr + c->rbytes));
        -: 4236:
   200116: 4237:        c->last_cmd_time = current_time;
   200116: 4238:        process_command(c, c->rcurr);
        -: 4239:
   200115: 4240:        c->rbytes -= (cont - c->rcurr);
   200115: 4241:        c->rcurr = cont;
        -: 4242:
  200115*: 4243:        assert(c->rcurr <= (c->rbuf + c->rsize));
        -: 4244:    }
        -: 4245:
        -: 4246:    return 1;
        -: 4247:}
        -: 4248:
        -: 4249:/*
        -: 4250: * read a UDP request.
        -: 4251: */
       42: 4252:static enum try_read_result try_read_udp(conn *c) {
       42: 4253:    int res;
        -: 4254:
      42*: 4255:    assert(c != NULL);
        -: 4256:
       42: 4257:    c->request_addr_size = sizeof(c->request_addr);
       84: 4258:    res = recvfrom(c->sfd, c->rbuf, c->rsize,
       42: 4259:                   0, (struct sockaddr *)&c->request_addr,
        -: 4260:                   &c->request_addr_size);
       42: 4261:    if (res > 8) {
       17: 4262:        unsigned char *buf = (unsigned char *)c->rbuf;
       17: 4263:        pthread_mutex_lock(&c->thread->stats.mutex);
       17: 4264:        c->thread->stats.bytes_read += res;
       17: 4265:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4266:
        -: 4267:        /* Beginning of UDP packet is the request ID; save it. */
       17: 4268:        c->request_id = buf[0] * 256 + buf[1];
        -: 4269:
        -: 4270:        /* If this is a multi-packet request, drop it. */
       17: 4271:        if (buf[4] != 0 || buf[5] != 1) {
    #####: 4272:            out_string(c, "SERVER_ERROR multi-packet request not supported");
    #####: 4273:            return READ_NO_DATA_RECEIVED;
        -: 4274:        }
        -: 4275:
        -: 4276:        /* Don't care about any of the rest of the header. */
       17: 4277:        res -= 8;
       17: 4278:        memmove(c->rbuf, c->rbuf + 8, res);
        -: 4279:
       17: 4280:        c->rbytes = res;
       17: 4281:        c->rcurr = c->rbuf;
       17: 4282:        return READ_DATA_RECEIVED;
        -: 4283:    }
        -: 4284:    return READ_NO_DATA_RECEIVED;
        -: 4285:}
        -: 4286:
        -: 4287:/*
        -: 4288: * read from network as much as we can, handle buffer overflow and connection
        -: 4289: * close.
        -: 4290: * before reading, move the remaining incomplete fragment of a command
        -: 4291: * (if any) to the beginning of the buffer.
        -: 4292: *
        -: 4293: * To protect us from someone flooding a connection with bogus data causing
        -: 4294: * the connection to eat up all available memory, break out and start looking
        -: 4295: * at the data I've got after a number of reallocs...
        -: 4296: *
        -: 4297: * @return enum try_read_result
        -: 4298: */
   153613: 4299:static enum try_read_result try_read_network(conn *c) {
   153613: 4300:    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
   153613: 4301:    int res;
   153613: 4302:    int num_allocs = 0;
  153613*: 4303:    assert(c != NULL);
        -: 4304:
   153613: 4305:    if (c->rcurr != c->rbuf) {
   141110: 4306:        if (c->rbytes != 0) /* otherwise there's nothing to copy */
     1092: 4307:            memmove(c->rbuf, c->rcurr, c->rbytes);
   141110: 4308:        c->rcurr = c->rbuf;
        -: 4309:    }
        -: 4310:
   215588: 4311:    while (1) {
   215588: 4312:        if (c->rbytes >= c->rsize) {
    61975: 4313:            if (num_allocs == 4) {
    11780: 4314:                return gotdata;
        -: 4315:            }
    50195: 4316:            ++num_allocs;
    50195: 4317:            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
    50195: 4318:            if (!new_rbuf) {
    #####: 4319:                STATS_LOCK();
    #####: 4320:                stats.malloc_fails++;
    #####: 4321:                STATS_UNLOCK();
    #####: 4322:                if (settings.verbose > 0) {
    #####: 4323:                    fprintf(stderr, "Couldn't realloc input buffer\n");
        -: 4324:                }
    #####: 4325:                c->rbytes = 0; /* ignore what we read */
    #####: 4326:                out_of_memory(c, "SERVER_ERROR out of memory reading request");
    #####: 4327:                c->write_and_go = conn_closing;
    #####: 4328:                return READ_MEMORY_ERROR;
        -: 4329:            }
    50195: 4330:            c->rcurr = c->rbuf = new_rbuf;
    50195: 4331:            c->rsize *= 2;
        -: 4332:        }
        -: 4333:
   203808: 4334:        int avail = c->rsize - c->rbytes;
   203808: 4335:        res = read(c->sfd, c->rbuf + c->rbytes, avail);
   203808: 4336:        if (res > 0) {
   202979: 4337:            pthread_mutex_lock(&c->thread->stats.mutex);
   202979: 4338:            c->thread->stats.bytes_read += res;
   202979: 4339:            pthread_mutex_unlock(&c->thread->stats.mutex);
   202979: 4340:            gotdata = READ_DATA_RECEIVED;
   202979: 4341:            c->rbytes += res;
   202979: 4342:            if (res == avail) {
    61975: 4343:                continue;
        -: 4344:            } else {
        -: 4345:                break;
        -: 4346:            }
        -: 4347:        }
      829: 4348:        if (res == 0) {
        -: 4349:            return READ_ERROR;
        -: 4350:        }
      750: 4351:        if (res == -1) {
      750: 4352:            if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 4353:                break;
        -: 4354:            }
        4: 4355:            return READ_ERROR;
        -: 4356:        }
        -: 4357:    }
        -: 4358:    return gotdata;
        -: 4359:}
        -: 4360:
   166998: 4361:static bool update_event(conn *c, const int new_flags) {
  166998*: 4362:    assert(c != NULL);
        -: 4363:
   166998: 4364:    struct event_base *base = c->event.ev_base;
   166998: 4365:    if (c->ev_flags == new_flags)
        -: 4366:        return true;
      682: 4367:    if (event_del(&c->event) == -1) return false;
      682: 4368:    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
      682: 4369:    event_base_set(base, &c->event);
      682: 4370:    c->ev_flags = new_flags;
     682*: 4371:    if (event_add(&c->event, 0) == -1) return false;
        -: 4372:    return true;
        -: 4373:}
        -: 4374:
        -: 4375:/*
        -: 4376: * Sets whether we are listening for new connections or not.
        -: 4377: */
    #####: 4378:void do_accept_new_conns(const bool do_accept) {
    #####: 4379:    conn *next;
        -: 4380:
    #####: 4381:    for (next = listen_conn; next; next = next->next) {
    #####: 4382:        if (do_accept) {
    #####: 4383:            update_event(next, EV_READ | EV_PERSIST);
    #####: 4384:            if (listen(next->sfd, settings.backlog) != 0) {
    #####: 4385:                perror("listen");
        -: 4386:            }
        -: 4387:        }
        -: 4388:        else {
    #####: 4389:            update_event(next, 0);
    #####: 4390:            if (listen(next->sfd, 0) != 0) {
    #####: 4391:                perror("listen");
        -: 4392:            }
        -: 4393:        }
        -: 4394:    }
        -: 4395:
    #####: 4396:    if (do_accept) {
    #####: 4397:        struct timeval maxconns_exited;
    #####: 4398:        uint64_t elapsed_us;
    #####: 4399:        gettimeofday(&maxconns_exited,NULL);
    #####: 4400:        STATS_LOCK();
    #####: 4401:        elapsed_us =
    #####: 4402:            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
    #####: 4403:            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
    #####: 4404:        stats.time_in_listen_disabled_us += elapsed_us;
    #####: 4405:        stats_state.accepting_conns = true;
    #####: 4406:        STATS_UNLOCK();
        -: 4407:    } else {
    #####: 4408:        STATS_LOCK();
    #####: 4409:        stats_state.accepting_conns = false;
    #####: 4410:        gettimeofday(&stats.maxconns_entered,NULL);
    #####: 4411:        stats.listen_disabled_num++;
    #####: 4412:        STATS_UNLOCK();
    #####: 4413:        allow_new_conns = false;
    #####: 4414:        maxconns_handler(-42, 0, 0);
        -: 4415:    }
    #####: 4416:}
        -: 4417:
        -: 4418:/*
        -: 4419: * Transmit the next chunk of data from our list of msgbuf structures.
        -: 4420: *
        -: 4421: * Returns:
        -: 4422: *   TRANSMIT_COMPLETE   All done writing.
        -: 4423: *   TRANSMIT_INCOMPLETE More data remaining to write.
        -: 4424: *   TRANSMIT_SOFT_ERROR Can't write any more right now.
        -: 4425: *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)
        -: 4426: */
   414930: 4427:static enum transmit_result transmit(conn *c) {
  414930*: 4428:    assert(c != NULL);
        -: 4429:
   414930: 4430:    if (c->msgcurr < c->msgused &&
   414930: 4431:            c->msglist[c->msgcurr].msg_iovlen == 0) {
        -: 4432:        /* Finished writing the current msg; advance to the next. */
   223000: 4433:        c->msgcurr++;
        -: 4434:    }
   414930: 4435:    if (c->msgcurr < c->msgused) {
   223006: 4436:        ssize_t res;
   223006: 4437:        struct msghdr *m = &c->msglist[c->msgcurr];
        -: 4438:
   223006: 4439:        res = sendmsg(c->sfd, m, 0);
   223006: 4440:        if (res > 0) {
   223001: 4441:            pthread_mutex_lock(&c->thread->stats.mutex);
   223001: 4442:            c->thread->stats.bytes_written += res;
   223001: 4443:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4444:
        -: 4445:            /* We've written some of the data. Remove the completed
        -: 4446:               iovec entries from the list of pending writes. */
   706450: 4447:            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {
   483449: 4448:                res -= m->msg_iov->iov_len;
   483449: 4449:                m->msg_iovlen--;
   483449: 4450:                m->msg_iov++;
        -: 4451:            }
        -: 4452:
        -: 4453:            /* Might have written just part of the last iovec entry;
        -: 4454:               adjust it so the next write will do the rest. */
   223001: 4455:            if (res > 0) {
        1: 4456:                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;
        1: 4457:                m->msg_iov->iov_len -= res;
        -: 4458:            }
   223001: 4459:            return TRANSMIT_INCOMPLETE;
        -: 4460:        }
        5: 4461:        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
        1: 4462:            if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 4463:                if (settings.verbose > 0)
    #####: 4464:                    fprintf(stderr, "Couldn't update event\n");
    #####: 4465:                conn_set_state(c, conn_closing);
    #####: 4466:                return TRANSMIT_HARD_ERROR;
        -: 4467:            }
        -: 4468:            return TRANSMIT_SOFT_ERROR;
        -: 4469:        }
        -: 4470:        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 4471:           we have a real error, on which we close the connection */
        4: 4472:        if (settings.verbose > 0)
    #####: 4473:            perror("Failed to write, and not due to blocking");
        -: 4474:
        4: 4475:        if (IS_UDP(c->transport))
    #####: 4476:            conn_set_state(c, conn_read);
        -: 4477:        else
        4: 4478:            conn_set_state(c, conn_closing);
        4: 4479:        return TRANSMIT_HARD_ERROR;
        -: 4480:    } else {
        -: 4481:        return TRANSMIT_COMPLETE;
        -: 4482:    }
        -: 4483:}
        -: 4484:
        -: 4485:/* Does a looped read to fill data chunks */
        -: 4486:/* TODO: restrict number of times this can loop.
        -: 4487: * Also, benchmark using readv's.
        -: 4488: */
     6712: 4489:static int read_into_chunked_item(conn *c) {
     6712: 4490:    int total = 0;
     6712: 4491:    int res;
    6712*: 4492:    assert(c->rcurr != c->ritem);
        -: 4493:
    42533: 4494:    while (c->rlbytes > 0) {
    40314: 4495:        item_chunk *ch = (item_chunk *)c->ritem;
    40314: 4496:        int unused = ch->size - ch->used;
        -: 4497:        /* first check if we have leftovers in the conn_read buffer */
    40314: 4498:        if (c->rbytes > 0) {
    17158: 4499:            total = 0;
    17158: 4500:            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
    17158: 4501:            tocopy = tocopy > unused ? unused : tocopy;
    17158: 4502:            if (c->ritem != c->rcurr) {
    17158: 4503:                memmove(ch->data + ch->used, c->rcurr, tocopy);
        -: 4504:            }
    17158: 4505:            total += tocopy;
    17158: 4506:            c->rlbytes -= tocopy;
    17158: 4507:            c->rcurr += tocopy;
    17158: 4508:            c->rbytes -= tocopy;
    17158: 4509:            ch->used += tocopy;
    17158: 4510:            if (c->rlbytes == 0) {
        -: 4511:                break;
        -: 4512:            }
        -: 4513:        } else {
        -: 4514:            /*  now try reading from the socket */
    46312: 4515:            res = read(c->sfd, ch->data + ch->used,
    23156: 4516:                    (unused > c->rlbytes ? c->rlbytes : unused));
    23156: 4517:            if (res > 0) {
    22265: 4518:                pthread_mutex_lock(&c->thread->stats.mutex);
    22265: 4519:                c->thread->stats.bytes_read += res;
    22265: 4520:                pthread_mutex_unlock(&c->thread->stats.mutex);
    22265: 4521:                ch->used += res;
    22265: 4522:                total += res;
    22265: 4523:                c->rlbytes -= res;
        -: 4524:            } else {
        -: 4525:                /* Reset total to the latest result so caller can handle it */
        -: 4526:                total = res;
        -: 4527:                break;
        -: 4528:            }
        -: 4529:        }
        -: 4530:
   35822*: 4531:        assert(ch->used <= ch->size);
    35822: 4532:        if (ch->size == ch->used) {
    29690: 4533:            if (ch->next) {
    29689: 4534:                c->ritem = (char *) ch->next;
        -: 4535:            } else {
        -: 4536:                /* No space left. */
       1*: 4537:                assert(c->rlbytes == 0);
        -: 4538:                break;
        -: 4539:            }
        -: 4540:        }
        -: 4541:    }
     6712: 4542:    return total;
        -: 4543:}
        -: 4544:
   167216: 4545:static void drive_machine(conn *c) {
   167216: 4546:    bool stop = false;
   167216: 4547:    int sfd;
   167216: 4548:    socklen_t addrlen;
   167216: 4549:    struct sockaddr_storage addr;
   167216: 4550:    int nreqs = settings.reqs_per_event;
   167216: 4551:    int res;
   167216: 4552:    const char *str;
        -: 4553:#ifdef HAVE_ACCEPT4
   167216: 4554:    static int  use_accept4 = 1;
        -: 4555:#else
        -: 4556:    static int  use_accept4 = 0;
        -: 4557:#endif
        -: 4558:
  167216*: 4559:    assert(c != NULL);
        -: 4560:
  1921977: 4561:    while (!stop) {
        -: 4562:
  1754763: 4563:        switch(c->state) {
      109: 4564:        case conn_listening:
      109: 4565:            addrlen = sizeof(addr);
        -: 4566:#ifdef HAVE_ACCEPT4
      109: 4567:            if (use_accept4) {
      109: 4568:                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
        -: 4569:            } else {
    #####: 4570:                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 4571:            }
        -: 4572:#else
        -: 4573:            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 4574:#endif
      109: 4575:            if (sfd == -1) {
    #####: 4576:                if (use_accept4 && errno == ENOSYS) {
    #####: 4577:                    use_accept4 = 0;
    #####: 4578:                    continue;
        -: 4579:                }
    #####: 4580:                perror(use_accept4 ? "accept4()" : "accept()");
    #####: 4581:                if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 4582:                    /* these are transient, so don't log anything */
        -: 4583:                    stop = true;
    #####: 4584:                } else if (errno == EMFILE) {
    #####: 4585:                    if (settings.verbose > 0)
    #####: 4586:                        fprintf(stderr, "Too many open connections\n");
    #####: 4587:                    accept_new_conns(false);
    #####: 4588:                    stop = true;
        -: 4589:                } else {
    #####: 4590:                    perror("accept()");
    #####: 4591:                    stop = true;
        -: 4592:                }
        -: 4593:                break;
        -: 4594:            }
      109: 4595:            if (!use_accept4) {
    #####: 4596:                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
    #####: 4597:                    perror("setting O_NONBLOCK");
    #####: 4598:                    close(sfd);
    #####: 4599:                    break;
        -: 4600:                }
        -: 4601:            }
        -: 4602:
      109: 4603:            if (settings.maxconns_fast &&
        1: 4604:                stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 4605:                str = "ERROR Too many open connections\r\n";
    #####: 4606:                res = write(sfd, str, strlen(str));
    #####: 4607:                close(sfd);
    #####: 4608:                STATS_LOCK();
    #####: 4609:                stats.rejected_conns++;
    #####: 4610:                STATS_UNLOCK();
        -: 4611:            } else {
      109: 4612:                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
        -: 4613:                                     DATA_BUFFER_SIZE, c->transport);
        -: 4614:            }
        -: 4615:
        -: 4616:            stop = true;
        -: 4617:            break;
        -: 4618:
   153662: 4619:        case conn_waiting:
   153662: 4620:            if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 4621:                if (settings.verbose > 0)
    #####: 4622:                    fprintf(stderr, "Couldn't update event\n");
    #####: 4623:                conn_set_state(c, conn_closing);
    #####: 4624:                break;
        -: 4625:            }
        -: 4626:
   153662: 4627:            conn_set_state(c, conn_read);
   153662: 4628:            stop = true;
   153662: 4629:            break;
        -: 4630:
   153655: 4631:        case conn_read:
   153655: 4632:            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);
        -: 4633:
   153655: 4634:            switch (res) {
       25: 4635:            case READ_NO_DATA_RECEIVED:
       25: 4636:                conn_set_state(c, conn_waiting);
       25: 4637:                break;
   153547: 4638:            case READ_DATA_RECEIVED:
   153547: 4639:                conn_set_state(c, conn_parse_cmd);
   153547: 4640:                break;
       83: 4641:            case READ_ERROR:
       83: 4642:                conn_set_state(c, conn_closing);
       83: 4643:                break;
        -: 4644:            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
        -: 4645:                /* State already set by try_read_network */
        -: 4646:                break;
        -: 4647:            }
        -: 4648:            break;
        -: 4649:
   278254: 4650:        case conn_parse_cmd :
   278254: 4651:            if (try_read_command(c) == 0) {
        -: 4652:                /* wee need more data! */
     1116: 4653:                conn_set_state(c, conn_waiting);
        -: 4654:            }
        -: 4655:
        -: 4656:            break;
        -: 4657:
   281276: 4658:        case conn_new_cmd:
        -: 4659:            /* Only process nreqs at a time to avoid starving other
        -: 4660:               connections */
        -: 4661:
   281276: 4662:            --nreqs;
   281276: 4663:            if (nreqs >= 0) {
   277228: 4664:                reset_cmd_handler(c);
        -: 4665:            } else {
     4048: 4666:                pthread_mutex_lock(&c->thread->stats.mutex);
     4048: 4667:                c->thread->stats.conn_yields++;
     4048: 4668:                pthread_mutex_unlock(&c->thread->stats.mutex);
     4048: 4669:                if (c->rbytes > 0) {
        -: 4670:                    /* We have already read in data into the input buffer,
        -: 4671:                       so libevent will most likely not signal read events
        -: 4672:                       on the socket (unless more data is available. As a
        -: 4673:                       hack we should just put in a request to write data,
        -: 4674:                       because that should be possible ;-)
        -: 4675:                    */
     4041: 4676:                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 4677:                        if (settings.verbose > 0)
    #####: 4678:                            fprintf(stderr, "Couldn't update event\n");
    #####: 4679:                        conn_set_state(c, conn_closing);
    #####: 4680:                        break;
        -: 4681:                    }
        -: 4682:                }
        -: 4683:                stop = true;
        -: 4684:            }
        -: 4685:            break;
        -: 4686:
   368013: 4687:        case conn_nread:
   368013: 4688:            if (c->rlbytes == 0) {
   176090: 4689:                complete_nread(c);
   176090: 4690:                break;
        -: 4691:            }
        -: 4692:
        -: 4693:            /* Check if rbytes < 0, to prevent crash */
   191923: 4694:            if (c->rlbytes < 0) {
    #####: 4695:                if (settings.verbose) {
    #####: 4696:                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
        -: 4697:                }
    #####: 4698:                conn_set_state(c, conn_closing);
    #####: 4699:                break;
        -: 4700:            }
        -: 4701:
   191923: 4702:            if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {
        -: 4703:                /* first check if we have leftovers in the conn_read buffer */
   185211: 4704:                if (c->rbytes > 0) {
   168957: 4705:                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
   168957: 4706:                    if (c->ritem != c->rcurr) {
    95373: 4707:                        memmove(c->ritem, c->rcurr, tocopy);
        -: 4708:                    }
   168957: 4709:                    c->ritem += tocopy;
   168957: 4710:                    c->rlbytes -= tocopy;
   168957: 4711:                    c->rcurr += tocopy;
   168957: 4712:                    c->rbytes -= tocopy;
   168957: 4713:                    if (c->rlbytes == 0) {
        -: 4714:                        break;
        -: 4715:                    }
        -: 4716:                }
        -: 4717:
        -: 4718:                /*  now try reading from the socket */
    30811: 4719:                res = read(c->sfd, c->ritem, c->rlbytes);
    30811: 4720:                if (res > 0) {
    22483: 4721:                    pthread_mutex_lock(&c->thread->stats.mutex);
    22483: 4722:                    c->thread->stats.bytes_read += res;
    22483: 4723:                    pthread_mutex_unlock(&c->thread->stats.mutex);
    22483: 4724:                    if (c->rcurr == c->ritem) {
     1161: 4725:                        c->rcurr += res;
        -: 4726:                    }
    22483: 4727:                    c->ritem += res;
    22483: 4728:                    c->rlbytes -= res;
    22483: 4729:                    break;
        -: 4730:                }
        -: 4731:            } else {
     6712: 4732:                res = read_into_chunked_item(c);
     6712: 4733:                if (res > 0)
        -: 4734:                    break;
        -: 4735:            }
        -: 4736:
     9219: 4737:            if (res == 0) { /* end of stream */
        1: 4738:                conn_set_state(c, conn_closing);
        1: 4739:                break;
        -: 4740:            }
        -: 4741:
     9218: 4742:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
     9218: 4743:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 4744:                    if (settings.verbose > 0)
    #####: 4745:                        fprintf(stderr, "Couldn't update event\n");
    #####: 4746:                    conn_set_state(c, conn_closing);
    #####: 4747:                    break;
        -: 4748:                }
        -: 4749:                stop = true;
        -: 4750:                break;
        -: 4751:            }
        -: 4752:            /* otherwise we have a real error, on which we close the connection */
    #####: 4753:            if (settings.verbose > 0) {
    #####: 4754:                fprintf(stderr, "Failed to read, and not due to blocking:\n"
        -: 4755:                        "errno: %d %s \n"
        -: 4756:                        "rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
    #####: 4757:                        errno, strerror(errno),
    #####: 4758:                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,
        -: 4759:                        (int)c->rlbytes, (int)c->rsize);
        -: 4760:            }
    #####: 4761:            conn_set_state(c, conn_closing);
    #####: 4762:            break;
        -: 4763:
   104764: 4764:        case conn_swallow:
        -: 4765:            /* we are reading sbytes and throwing them away */
   104764: 4766:            if (c->sbytes == 0) {
    52194: 4767:                conn_set_state(c, conn_new_cmd);
    52194: 4768:                break;
        -: 4769:            }
        -: 4770:
        -: 4771:            /* first check if we have leftovers in the conn_read buffer */
    52570: 4772:            if (c->rbytes > 0) {
    52194: 4773:                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
    52194: 4774:                c->sbytes -= tocopy;
    52194: 4775:                c->rcurr += tocopy;
    52194: 4776:                c->rbytes -= tocopy;
    52194: 4777:                break;
        -: 4778:            }
        -: 4779:
        -: 4780:            /*  now try reading from the socket */
      376: 4781:            res = read(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
      376: 4782:            if (res > 0) {
      300: 4783:                pthread_mutex_lock(&c->thread->stats.mutex);
      300: 4784:                c->thread->stats.bytes_read += res;
      300: 4785:                pthread_mutex_unlock(&c->thread->stats.mutex);
      300: 4786:                c->sbytes -= res;
      300: 4787:                break;
        -: 4788:            }
       76: 4789:            if (res == 0) { /* end of stream */
    #####: 4790:                conn_set_state(c, conn_closing);
    #####: 4791:                break;
        -: 4792:            }
       76: 4793:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
       76: 4794:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 4795:                    if (settings.verbose > 0)
    #####: 4796:                        fprintf(stderr, "Couldn't update event\n");
    #####: 4797:                    conn_set_state(c, conn_closing);
    #####: 4798:                    break;
        -: 4799:                }
        -: 4800:                stop = true;
        -: 4801:                break;
        -: 4802:            }
        -: 4803:            /* otherwise we have a real error, on which we close the connection */
    #####: 4804:            if (settings.verbose > 0)
    #####: 4805:                fprintf(stderr, "Failed to read, and not due to blocking\n");
    #####: 4806:            conn_set_state(c, conn_closing);
    #####: 4807:            break;
        -: 4808:
    45555: 4809:        case conn_write:
        -: 4810:            /*
        -: 4811:             * We want to write out a simple response. If we haven't already,
        -: 4812:             * assemble it into a msgbuf list (this will be a single-entry
        -: 4813:             * list for TCP or a two-entry list for UDP).
        -: 4814:             */
    45555: 4815:            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
    22757: 4816:                if (add_iov(c, c->wcurr, c->wbytes) != 0) {
    #####: 4817:                    if (settings.verbose > 0)
    #####: 4818:                        fprintf(stderr, "Couldn't build response\n");
    #####: 4819:                    conn_set_state(c, conn_closing);
    #####: 4820:                    break;
        -: 4821:                }
        -: 4822:            }
        -: 4823:
        -: 4824:            /* fall through... */
        -: 4825:
        -: 4826:        case conn_mwrite:
   414930: 4827:          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
    #####: 4828:            if (settings.verbose > 0)
    #####: 4829:              fprintf(stderr, "Failed to build UDP headers\n");
    #####: 4830:            conn_set_state(c, conn_closing);
    #####: 4831:            break;
        -: 4832:          }
   414930: 4833:            switch (transmit(c)) {
   191924: 4834:            case TRANSMIT_COMPLETE:
   191924: 4835:                if (c->state == conn_mwrite) {
   169169: 4836:                    conn_release_items(c);
        -: 4837:                    /* XXX:  I don't know why this wasn't the general case */
   169169: 4838:                    if(c->protocol == binary_prot) {
    56953: 4839:                        conn_set_state(c, c->write_and_go);
        -: 4840:                    } else {
   112216: 4841:                        conn_set_state(c, conn_new_cmd);
        -: 4842:                    }
    22755: 4843:                } else if (c->state == conn_write) {
    22755: 4844:                    if (c->write_and_free) {
     2835: 4845:                        free(c->write_and_free);
     2835: 4846:                        c->write_and_free = 0;
        -: 4847:                    }
    22755: 4848:                    conn_set_state(c, c->write_and_go);
        -: 4849:                } else {
    #####: 4850:                    if (settings.verbose > 0)
    #####: 4851:                        fprintf(stderr, "Unexpected state %d\n", c->state);
    #####: 4852:                    conn_set_state(c, conn_closing);
        -: 4853:                }
        -: 4854:                break;
        -: 4855:
        -: 4856:            case TRANSMIT_INCOMPLETE:
        -: 4857:            case TRANSMIT_HARD_ERROR:
        -: 4858:                break;                   /* Continue in state machine. */
        -: 4859:
        1: 4860:            case TRANSMIT_SOFT_ERROR:
        1: 4861:                stop = true;
        1: 4862:                break;
        -: 4863:            }
        -: 4864:            break;
        -: 4865:
       97: 4866:        case conn_closing:
       97: 4867:            if (IS_UDP(c->transport))
    #####: 4868:                conn_cleanup(c);
        -: 4869:            else
       97: 4870:                conn_close(c);
        -: 4871:            stop = true;
        -: 4872:            break;
        -: 4873:
    #####: 4874:        case conn_closed:
        -: 4875:            /* This only happens if dormando is an idiot. */
    #####: 4876:            abort();
        -: 4877:            break;
        -: 4878:
        -: 4879:        case conn_watch:
        -: 4880:            /* We handed off our connection to the logger thread. */
  1921977: 4881:            stop = true;
        -: 4882:            break;
        -: 4883:        case conn_max_state:
    #####: 4884:            assert(false);
        -: 4885:            break;
        -: 4886:        }
   160221: 4887:    }
        -: 4888:
   167214: 4889:    return;
        -: 4890:}
        -: 4891:
   167215: 4892:void event_handler(const int fd, const short which, void *arg) {
   167215: 4893:    conn *c;
        -: 4894:
   167215: 4895:    c = (conn *)arg;
  167215*: 4896:    assert(c != NULL);
        -: 4897:
   167215: 4898:    c->which = which;
        -: 4899:
        -: 4900:    /* sanity */
   167215: 4901:    if (fd != c->sfd) {
    #####: 4902:        if (settings.verbose > 0)
    #####: 4903:            fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
    #####: 4904:        conn_close(c);
    #####: 4905:        return;
        -: 4906:    }
        -: 4907:
   167215: 4908:    drive_machine(c);
        -: 4909:
        -: 4910:    /* wait for next event */
   167215: 4911:    return;
        -: 4912:}
        -: 4913:
      326: 4914:static int new_socket(struct addrinfo *ai) {
      326: 4915:    int sfd;
      326: 4916:    int flags;
        -: 4917:
      326: 4918:    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        -: 4919:        return -1;
        -: 4920:    }
        -: 4921:
      652: 4922:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
      326: 4923:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 4924:        perror("setting O_NONBLOCK");
    #####: 4925:        close(sfd);
    #####: 4926:        return -1;
        -: 4927:    }
        -: 4928:    return sfd;
        -: 4929:}
        -: 4930:
        -: 4931:
        -: 4932:/*
        -: 4933: * Sets a socket's send buffer size to the maximum allowed by the system.
        -: 4934: */
      159: 4935:static void maximize_sndbuf(const int sfd) {
      159: 4936:    socklen_t intsize = sizeof(int);
      159: 4937:    int last_good = 0;
      159: 4938:    int min, max, avg;
      159: 4939:    int old_size;
        -: 4940:
        -: 4941:    /* Start with the default size. */
      159: 4942:    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
    #####: 4943:        if (settings.verbose > 0)
    #####: 4944:            perror("getsockopt(SO_SNDBUF)");
    #####: 4945:        return;
        -: 4946:    }
        -: 4947:
        -: 4948:    /* Binary-search for the real maximum. */
      159: 4949:    min = old_size;
      159: 4950:    max = MAX_SENDBUF_SIZE;
        -: 4951:
     4611: 4952:    while (min <= max) {
     4452: 4953:        avg = ((unsigned int)(min + max)) / 2;
     4452: 4954:        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
     4452: 4955:            last_good = avg;
     4452: 4956:            min = avg + 1;
        -: 4957:        } else {
    #####: 4958:            max = avg - 1;
        -: 4959:        }
        -: 4960:    }
        -: 4961:
      159: 4962:    if (settings.verbose > 1)
      159: 4963:        fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
        -: 4964:}
        -: 4965:
        -: 4966:/**
        -: 4967: * Create a socket and bind it to a specific port number
        -: 4968: * @param interface the interface to bind to
        -: 4969: * @param port the port number to bind to
        -: 4970: * @param transport the transport protocol (TCP / UDP)
        -: 4971: * @param portnumber_file A filepointer to write the port numbers to
        -: 4972: *        when they are successfully added to the list of ports we
        -: 4973: *        listen on.
        -: 4974: */
      165: 4975:static int server_socket(const char *interface,
        -: 4976:                         int port,
        -: 4977:                         enum network_transport transport,
        -: 4978:                         FILE *portnumber_file) {
      165: 4979:    int sfd;
      165: 4980:    struct linger ling = {0, 0};
      165: 4981:    struct addrinfo *ai;
      165: 4982:    struct addrinfo *next;
      165: 4983:    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
        -: 4984:                              .ai_family = AF_UNSPEC };
      165: 4985:    char port_buf[NI_MAXSERV];
      165: 4986:    int error;
      165: 4987:    int success = 0;
      165: 4988:    int flags =1;
        -: 4989:
      165: 4990:    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;
        -: 4991:
      165: 4992:    if (port == -1) {
       10: 4993:        port = 0;
        -: 4994:    }
      165: 4995:    snprintf(port_buf, sizeof(port_buf), "%d", port);
      165: 4996:    error= getaddrinfo(interface, port_buf, &hints, &ai);
      165: 4997:    if (error != 0) {
        1: 4998:        if (error != EAI_SYSTEM)
        1: 4999:          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
        -: 5000:        else
    #####: 5001:          perror("getaddrinfo()");
        1: 5002:        return 1;
        -: 5003:    }
        -: 5004:
      490: 5005:    for (next= ai; next; next= next->ai_next) {
      326: 5006:        conn *listen_conn_add;
      326: 5007:        if ((sfd = new_socket(next)) == -1) {
        -: 5008:            /* getaddrinfo can return "junk" addresses,
        -: 5009:             * we make sure at least one works before erroring.
        -: 5010:             */
    #####: 5011:            if (errno == EMFILE) {
        -: 5012:                /* ...unless we're out of fds */
    #####: 5013:                perror("server_socket");
    #####: 5014:                exit(EX_OSERR);
        -: 5015:            }
    #####: 5016:            continue;
        -: 5017:        }
        -: 5018:
        -: 5019:#ifdef IPV6_V6ONLY
      326: 5020:        if (next->ai_family == AF_INET6) {
      162: 5021:            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
      162: 5022:            if (error != 0) {
    #####: 5023:                perror("setsockopt");
    #####: 5024:                close(sfd);
    #####: 5025:                continue;
        -: 5026:            }
        -: 5027:        }
        -: 5028:#endif
        -: 5029:
      326: 5030:        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
      326: 5031:        if (IS_UDP(transport)) {
      159: 5032:            maximize_sndbuf(sfd);
        -: 5033:        } else {
      167: 5034:            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
      167: 5035:            if (error != 0)
    #####: 5036:                perror("setsockopt");
        -: 5037:
      167: 5038:            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
      167: 5039:            if (error != 0)
    #####: 5040:                perror("setsockopt");
        -: 5041:
      167: 5042:            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
      167: 5043:            if (error != 0)
    #####: 5044:                perror("setsockopt");
        -: 5045:        }
        -: 5046:
      326: 5047:        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
    #####: 5048:            if (errno != EADDRINUSE) {
    #####: 5049:                perror("bind()");
    #####: 5050:                close(sfd);
    #####: 5051:                freeaddrinfo(ai);
    #####: 5052:                return 1;
        -: 5053:            }
    #####: 5054:            close(sfd);
    #####: 5055:            continue;
        -: 5056:        } else {
      326: 5057:            success++;
      326: 5058:            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
    #####: 5059:                perror("listen()");
    #####: 5060:                close(sfd);
    #####: 5061:                freeaddrinfo(ai);
    #####: 5062:                return 1;
        -: 5063:            }
      326: 5064:            if (portnumber_file != NULL &&
       40: 5065:                (next->ai_addr->sa_family == AF_INET ||
        -: 5066:                 next->ai_addr->sa_family == AF_INET6)) {
       40: 5067:                union {
        -: 5068:                    struct sockaddr_in in;
        -: 5069:                    struct sockaddr_in6 in6;
        -: 5070:                } my_sockaddr;
       40: 5071:                socklen_t len = sizeof(my_sockaddr);
       40: 5072:                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
       40: 5073:                    if (next->ai_addr->sa_family == AF_INET) {
       60: 5074:                        fprintf(portnumber_file, "%s INET: %u\n",
        -: 5075:                                IS_UDP(transport) ? "UDP" : "TCP",
       20: 5076:                                ntohs(my_sockaddr.in.sin_port));
        -: 5077:                    } else {
       40: 5078:                        fprintf(portnumber_file, "%s INET6: %u\n",
        -: 5079:                                IS_UDP(transport) ? "UDP" : "TCP",
       20: 5080:                                ntohs(my_sockaddr.in6.sin6_port));
        -: 5081:                    }
        -: 5082:                }
        -: 5083:            }
        -: 5084:        }
        -: 5085:
      326: 5086:        if (IS_UDP(transport)) {
        -: 5087:            int c;
        -: 5088:
      795: 5089:            for (c = 0; c < settings.num_threads_per_udp; c++) {
        -: 5090:                /* Allocate one UDP file descriptor per worker thread;
        -: 5091:                 * this allows "stats conns" to separately list multiple
        -: 5092:                 * parallel UDP requests in progress.
        -: 5093:                 *
        -: 5094:                 * The dispatch code round-robins new connection requests
        -: 5095:                 * among threads, so this is guaranteed to assign one
        -: 5096:                 * FD to each thread.
        -: 5097:                 */
      636: 5098:                int per_thread_fd = c ? dup(sfd) : sfd;
      636: 5099:                dispatch_conn_new(per_thread_fd, conn_read,
        -: 5100:                                  EV_READ | EV_PERSIST,
        -: 5101:                                  UDP_READ_BUFFER_SIZE, transport);
        -: 5102:            }
        -: 5103:        } else {
      167: 5104:            if (!(listen_conn_add = conn_new(sfd, conn_listening,
        -: 5105:                                             EV_READ | EV_PERSIST, 1,
        -: 5106:                                             transport, main_base))) {
    #####: 5107:                fprintf(stderr, "failed to create listening connection\n");
    #####: 5108:                exit(EXIT_FAILURE);
        -: 5109:            }
      167: 5110:            listen_conn_add->next = listen_conn;
      167: 5111:            listen_conn = listen_conn_add;
        -: 5112:        }
        -: 5113:    }
        -: 5114:
      164: 5115:    freeaddrinfo(ai);
        -: 5116:
        -: 5117:    /* Return zero iff we detected no errors in starting up connections */
      164: 5118:    return success == 0;
        -: 5119:}
        -: 5120:
      165: 5121:static int server_sockets(int port, enum network_transport transport,
        -: 5122:                          FILE *portnumber_file) {
      165: 5123:    if (settings.inter == NULL) {
      162: 5124:        return server_socket(settings.inter, port, transport, portnumber_file);
        -: 5125:    } else {
        -: 5126:        // tokenize them and bind to each one of them..
        3: 5127:        char *b;
        3: 5128:        int ret = 0;
        3: 5129:        char *list = strdup(settings.inter);
        -: 5130:
        3: 5131:        if (list == NULL) {
    #####: 5132:            fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
    #####: 5133:            return 1;
        -: 5134:        }
        3: 5135:        for (char *p = strtok_r(list, ";,", &b);
        6: 5136:             p != NULL;
        3: 5137:             p = strtok_r(NULL, ";,", &b)) {
        3: 5138:            int the_port = port;
        -: 5139:
        3: 5140:            char *h = NULL;
        3: 5141:            if (*p == '[') {
        -: 5142:                // expecting it to be an IPv6 address enclosed in []
        -: 5143:                // i.e. RFC3986 style recommended by RFC5952
    #####: 5144:                char *e = strchr(p, ']');
    #####: 5145:                if (e == NULL) {
    #####: 5146:                    fprintf(stderr, "Invalid IPV6 address: \"%s\"", p);
    #####: 5147:                    return 1;
        -: 5148:                }
    #####: 5149:                h = ++p; // skip the opening '['
    #####: 5150:                *e = '\0';
    #####: 5151:                p = ++e; // skip the closing ']'
        -: 5152:            }
        -: 5153:
        3: 5154:            char *s = strchr(p, ':');
        3: 5155:            if (s != NULL) {
        -: 5156:                // If no more semicolons - attempt to treat as port number.
        -: 5157:                // Otherwise the only valid option is an unenclosed IPv6 without port, until
        -: 5158:                // of course there was an RFC3986 IPv6 address previously specified -
        -: 5159:                // in such a case there is no good option, will just send it to fail as port number.
    #####: 5160:                if (strchr(s + 1, ':') == NULL || h != NULL) {
    #####: 5161:                    *s = '\0';
    #####: 5162:                    ++s;
    #####: 5163:                    if (!safe_strtol(s, &the_port)) {
    #####: 5164:                        fprintf(stderr, "Invalid port number: \"%s\"", s);
    #####: 5165:                        return 1;
        -: 5166:                    }
        -: 5167:                }
        -: 5168:            }
        -: 5169:
        3: 5170:            if (h != NULL)
    #####: 5171:                p = h;
        -: 5172:
        3: 5173:            if (strcmp(p, "*") == 0) {
    #####: 5174:                p = NULL;
        -: 5175:            }
        3: 5176:            ret |= server_socket(p, the_port, transport, portnumber_file);
        -: 5177:        }
        3: 5178:        free(list);
        3: 5179:        return ret;
        -: 5180:    }
        -: 5181:}
        -: 5182:
        2: 5183:static int new_socket_unix(void) {
        2: 5184:    int sfd;
        2: 5185:    int flags;
        -: 5186:
        2: 5187:    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    #####: 5188:        perror("socket()");
    #####: 5189:        return -1;
        -: 5190:    }
        -: 5191:
        4: 5192:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        2: 5193:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 5194:        perror("setting O_NONBLOCK");
    #####: 5195:        close(sfd);
    #####: 5196:        return -1;
        -: 5197:    }
        -: 5198:    return sfd;
        -: 5199:}
        -: 5200:
        2: 5201:static int server_socket_unix(const char *path, int access_mask) {
        2: 5202:    int sfd;
        2: 5203:    struct linger ling = {0, 0};
        2: 5204:    struct sockaddr_un addr;
        2: 5205:    struct stat tstat;
        2: 5206:    int flags =1;
        2: 5207:    int old_umask;
        -: 5208:
        2: 5209:    if (!path) {
        -: 5210:        return 1;
        -: 5211:    }
        -: 5212:
        2: 5213:    if ((sfd = new_socket_unix()) == -1) {
        -: 5214:        return 1;
        -: 5215:    }
        -: 5216:
        -: 5217:    /*
        -: 5218:     * Clean up a previous socket file if we left it around
        -: 5219:     */
        2: 5220:    if (lstat(path, &tstat) == 0) {
    #####: 5221:        if (S_ISSOCK(tstat.st_mode))
    #####: 5222:            unlink(path);
        -: 5223:    }
        -: 5224:
        2: 5225:    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
        2: 5226:    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
        2: 5227:    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        -: 5228:
        -: 5229:    /*
        -: 5230:     * the memset call clears nonstandard fields in some impementations
        -: 5231:     * that otherwise mess things up.
        -: 5232:     */
        2: 5233:    memset(&addr, 0, sizeof(addr));
        -: 5234:
        2: 5235:    addr.sun_family = AF_UNIX;
        2: 5236:    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
       2*: 5237:    assert(strcmp(addr.sun_path, path) == 0);
        2: 5238:    old_umask = umask( ~(access_mask&0777));
        2: 5239:    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    #####: 5240:        perror("bind()");
    #####: 5241:        close(sfd);
    #####: 5242:        umask(old_umask);
    #####: 5243:        return 1;
        -: 5244:    }
        2: 5245:    umask(old_umask);
        2: 5246:    if (listen(sfd, settings.backlog) == -1) {
    #####: 5247:        perror("listen()");
    #####: 5248:        close(sfd);
    #####: 5249:        return 1;
        -: 5250:    }
        2: 5251:    if (!(listen_conn = conn_new(sfd, conn_listening,
        -: 5252:                                 EV_READ | EV_PERSIST, 1,
        -: 5253:                                 local_transport, main_base))) {
    #####: 5254:        fprintf(stderr, "failed to create listening connection\n");
    #####: 5255:        exit(EXIT_FAILURE);
        -: 5256:    }
        -: 5257:
        -: 5258:    return 0;
        -: 5259:}
        -: 5260:
        -: 5261:/*
        -: 5262: * We keep the current time of day in a global variable that's updated by a
        -: 5263: * timer event. This saves us a bunch of time() system calls (we really only
        -: 5264: * need to get the time once a second, whereas there can be tens of thousands
        -: 5265: * of requests a second) and allows us to use server-start-relative timestamps
        -: 5266: * rather than absolute UNIX timestamps, a space savings on systems where
        -: 5267: * sizeof(time_t) > sizeof(unsigned int).
        -: 5268: */
        -: 5269:volatile rel_time_t current_time;
        -: 5270:static struct event clockevent;
        -: 5271:
        -: 5272:/* libevent uses a monotonic clock when available for event scheduling. Aside
        -: 5273: * from jitter, simply ticking our internal timer here is accurate enough.
        -: 5274: * Note that users who are setting explicit dates for expiration times *must*
        -: 5275: * ensure their clocks are correct before starting memcached. */
      193: 5276:static void clock_handler(const int fd, const short which, void *arg) {
      193: 5277:    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
      193: 5278:    static bool initialized = false;
        -: 5279:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
      193: 5280:    static bool monotonic = false;
      193: 5281:    static time_t monotonic_start;
        -: 5282:#endif
        -: 5283:
      193: 5284:    if (initialized) {
        -: 5285:        /* only delete the event if it's actually there. */
      104: 5286:        evtimer_del(&clockevent);
        -: 5287:    } else {
       89: 5288:        initialized = true;
        -: 5289:        /* process_started is initialized to time() - 2. We initialize to 1 so
        -: 5290:         * flush_all won't underflow during tests. */
        -: 5291:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
       89: 5292:        struct timespec ts;
       89: 5293:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
       89: 5294:            monotonic = true;
       89: 5295:            monotonic_start = ts.tv_sec - ITEM_UPDATE_INTERVAL - 2;
        -: 5296:        }
        -: 5297:#endif
        -: 5298:    }
        -: 5299:
      193: 5300:    evtimer_set(&clockevent, clock_handler, 0);
      193: 5301:    event_base_set(main_base, &clockevent);
      193: 5302:    evtimer_add(&clockevent, &t);
        -: 5303:
        -: 5304:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
      193: 5305:    if (monotonic) {
      193: 5306:        struct timespec ts;
      193: 5307:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
        -: 5308:            return;
      193: 5309:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
      193: 5310:        return;
        -: 5311:    }
        -: 5312:#endif
        -: 5313:    {
    #####: 5314:        struct timeval tv;
    #####: 5315:        gettimeofday(&tv, NULL);
    #####: 5316:        current_time = (rel_time_t) (tv.tv_sec - process_started);
        -: 5317:    }
        -: 5318:}
        -: 5319:
       86: 5320:static void usage(void) {
       86: 5321:    printf(PACKAGE " " VERSION "\n");
       86: 5322:    printf("-p <num>      TCP port number to listen on (default: 11211)\n"
        -: 5323:           "-U <num>      UDP port number to listen on (default: 11211, 0 is off)\n"
        -: 5324:           "-s <file>     UNIX socket path to listen on (disables network support)\n"
        -: 5325:           "-A            enable ascii \"shutdown\" command\n"
        -: 5326:           "-a <mask>     access mask for UNIX socket, in octal (default: 0700)\n"
        -: 5327:           "-l <addr>     interface to listen on (default: INADDR_ANY, all addresses)\n"
        -: 5328:           "              <addr> may be specified as host:port. If you don't specify\n"
        -: 5329:           "              a port number, the value you specified with -p or -U is\n"
        -: 5330:           "              used. You may specify multiple addresses separated by comma\n"
        -: 5331:           "              or by using -l multiple times\n"
        -: 5332:
        -: 5333:           "-d            run as a daemon\n"
        -: 5334:           "-r            maximize core file limit\n"
        -: 5335:           "-u <username> assume identity of <username> (only when run as root)\n"
        -: 5336:           "-m <num>      max memory to use for items in megabytes (default: 64 MB)\n"
        -: 5337:           "-M            return error on memory exhausted (rather than removing items)\n"
        -: 5338:           "-c <num>      max simultaneous connections (default: 1024)\n"
        -: 5339:           "-k            lock down all paged memory.  Note that there is a\n"
        -: 5340:           "              limit on how much memory you may lock.  Trying to\n"
        -: 5341:           "              allocate more than that would fail, so be sure you\n"
        -: 5342:           "              set the limit correctly for the user you started\n"
        -: 5343:           "              the daemon with (not for -u <username> user;\n"
        -: 5344:           "              under sh this is done with 'ulimit -S -l NUM_KB').\n"
        -: 5345:           "-v            verbose (print errors/warnings while in event loop)\n"
        -: 5346:           "-vv           very verbose (also print client commands/reponses)\n"
        -: 5347:           "-vvv          extremely verbose (also print internal state transitions)\n"
        -: 5348:           "-h            print this help and exit\n"
        -: 5349:           "-i            print memcached and libevent license\n"
        -: 5350:           "-V            print version and exit\n"
        -: 5351:           "-P <file>     save PID in <file>, only used with -d option\n"
        -: 5352:           "-f <factor>   chunk size growth factor (default: 1.25)\n"
        -: 5353:           "-n <bytes>    minimum space allocated for key+value+flags (default: 48)\n");
       86: 5354:    printf("-L            Try to use large memory pages (if available). Increasing\n"
        -: 5355:           "              the memory page size could reduce the number of TLB misses\n"
        -: 5356:           "              and improve the performance. In order to get large pages\n"
        -: 5357:           "              from the OS, memcached will allocate the total item-cache\n"
        -: 5358:           "              in one large chunk.\n");
       86: 5359:    printf("-D <char>     Use <char> as the delimiter between key prefixes and IDs.\n"
        -: 5360:           "              This is used for per-prefix stats reporting. The default is\n"
        -: 5361:           "              \":\" (colon). If this option is specified, stats collection\n"
        -: 5362:           "              is turned on automatically; if not, then it may be turned on\n"
        -: 5363:           "              by sending the \"stats detail on\" command to the server.\n");
       86: 5364:    printf("-t <num>      number of threads to use (default: 4)\n");
       86: 5365:    printf("-R            Maximum number of requests per event, limits the number of\n"
        -: 5366:           "              requests process for a given connection to prevent \n"
        -: 5367:           "              starvation (default: 20)\n");
       86: 5368:    printf("-C            Disable use of CAS\n");
       86: 5369:    printf("-b <num>      Set the backlog queue limit (default: 1024)\n");
       86: 5370:    printf("-B            Binding protocol - one of ascii, binary, or auto (default)\n");
       86: 5371:    printf("-I            Override the size of each slab page. Adjusts max item size\n"
        -: 5372:           "              (default: 1mb, min: 1k, max: 128m)\n");
        -: 5373:#ifdef ENABLE_SASL
        -: 5374:    printf("-S            Turn on Sasl authentication\n");
        -: 5375:#endif
       86: 5376:    printf("-F            Disable flush_all command\n");
       86: 5377:    printf("-X            Disable stats cachedump and lru_crawler metadump commands\n");
       86: 5378:    printf("-o            Comma separated list of extended or experimental options\n"
        -: 5379:           "              - maxconns_fast: immediately close new\n"
        -: 5380:           "                connections if over maxconns limit\n"
        -: 5381:           "              - hashpower: An integer multiplier for how large the hash\n"
        -: 5382:           "                table should be. Can be grown at runtime if not big enough.\n"
        -: 5383:           "                Set this based on \"STAT hash_power_level\" before a \n"
        -: 5384:           "                restart.\n"
        -: 5385:           "              - tail_repair_time: Time in seconds that indicates how long to wait before\n"
        -: 5386:           "                forcefully taking over the LRU tail item whose refcount has leaked.\n"
        -: 5387:           "                Disabled by default; dangerous option.\n"
        -: 5388:           "              - hash_algorithm: The hash table algorithm\n"
        -: 5389:           "                default is jenkins hash. options: jenkins, murmur3\n"
        -: 5390:           "              - lru_crawler: Enable LRU Crawler background thread\n"
        -: 5391:           "              - lru_crawler_sleep: Microseconds to sleep between items\n"
        -: 5392:           "                default is 100.\n"
        -: 5393:           "              - lru_crawler_tocrawl: Max items to crawl per slab per run\n"
        -: 5394:           "                default is 0 (unlimited)\n"
        -: 5395:           "              - lru_maintainer: Enable new LRU system + background thread\n"
        -: 5396:           "              - hot_lru_pct: Pct of slab memory to reserve for hot lru.\n"
        -: 5397:           "                (requires lru_maintainer)\n"
        -: 5398:           "              - warm_lru_pct: Pct of slab memory to reserve for warm lru.\n"
        -: 5399:           "                (requires lru_maintainer)\n"
        -: 5400:           "              - expirezero_does_not_evict: Items set to not expire, will not evict.\n"
        -: 5401:           "                (requires lru_maintainer)\n"
        -: 5402:           "              - idle_timeout: Timeout for idle connections\n"
        -: 5403:           "              - (EXPERIMENTAL) slab_chunk_max: Maximum slab size. Do not change without extreme care.\n"
        -: 5404:           "              - watcher_logbuf_size: Size in kilobytes of per-watcher write buffer.\n"
        -: 5405:           "              - worker_logbuf_Size: Size in kilobytes of per-worker-thread buffer\n"
        -: 5406:           "                read by background thread. Which is then written to watchers.\n"
        -: 5407:           "              - track_sizes: Enable dynamic reports for 'stats sizes' command.\n"
        -: 5408:           "              - modern: Enables 'modern' defaults. Options that will be default in future.\n"
        -: 5409:           "                enables: slab_chunk_max:512k,slab_reassign,slab_automove=1,maxconns_fast,\n"
        -: 5410:           "                         hash_algorithm=murmur3,lru_crawler,lru_maintainer\n"
        -: 5411:           );
       86: 5412:    return;
        -: 5413:}
        -: 5414:
    #####: 5415:static void usage_license(void) {
    #####: 5416:    printf(PACKAGE " " VERSION "\n\n");
    #####: 5417:    printf(
        -: 5418:    "Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n"
        -: 5419:    "All rights reserved.\n"
        -: 5420:    "\n"
        -: 5421:    "Redistribution and use in source and binary forms, with or without\n"
        -: 5422:    "modification, are permitted provided that the following conditions are\n"
        -: 5423:    "met:\n"
        -: 5424:    "\n"
        -: 5425:    "    * Redistributions of source code must retain the above copyright\n"
        -: 5426:    "notice, this list of conditions and the following disclaimer.\n"
        -: 5427:    "\n"
        -: 5428:    "    * Redistributions in binary form must reproduce the above\n"
        -: 5429:    "copyright notice, this list of conditions and the following disclaimer\n"
        -: 5430:    "in the documentation and/or other materials provided with the\n"
        -: 5431:    "distribution.\n"
        -: 5432:    "\n"
        -: 5433:    "    * Neither the name of the Danga Interactive nor the names of its\n"
        -: 5434:    "contributors may be used to endorse or promote products derived from\n"
        -: 5435:    "this software without specific prior written permission.\n"
        -: 5436:    "\n"
        -: 5437:    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
        -: 5438:    "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
        -: 5439:    "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
        -: 5440:    "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
        -: 5441:    "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
        -: 5442:    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
        -: 5443:    "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 5444:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 5445:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 5446:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
        -: 5447:    "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 5448:    "\n"
        -: 5449:    "\n"
        -: 5450:    "This product includes software developed by Niels Provos.\n"
        -: 5451:    "\n"
        -: 5452:    "[ libevent ]\n"
        -: 5453:    "\n"
        -: 5454:    "Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\n"
        -: 5455:    "All rights reserved.\n"
        -: 5456:    "\n"
        -: 5457:    "Redistribution and use in source and binary forms, with or without\n"
        -: 5458:    "modification, are permitted provided that the following conditions\n"
        -: 5459:    "are met:\n"
        -: 5460:    "1. Redistributions of source code must retain the above copyright\n"
        -: 5461:    "   notice, this list of conditions and the following disclaimer.\n"
        -: 5462:    "2. Redistributions in binary form must reproduce the above copyright\n"
        -: 5463:    "   notice, this list of conditions and the following disclaimer in the\n"
        -: 5464:    "   documentation and/or other materials provided with the distribution.\n"
        -: 5465:    "3. All advertising materials mentioning features or use of this software\n"
        -: 5466:    "   must display the following acknowledgement:\n"
        -: 5467:    "      This product includes software developed by Niels Provos.\n"
        -: 5468:    "4. The name of the author may not be used to endorse or promote products\n"
        -: 5469:    "   derived from this software without specific prior written permission.\n"
        -: 5470:    "\n"
        -: 5471:    "THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
        -: 5472:    "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
        -: 5473:    "OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
        -: 5474:    "IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
        -: 5475:    "INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n"
        -: 5476:    "NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 5477:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 5478:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 5479:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n"
        -: 5480:    "THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 5481:    );
        -: 5482:
    #####: 5483:    return;
        -: 5484:}
        -: 5485:
        1: 5486:static void save_pid(const char *pid_file) {
        1: 5487:    FILE *fp;
        1: 5488:    if (access(pid_file, F_OK) == 0) {
    #####: 5489:        if ((fp = fopen(pid_file, "r")) != NULL) {
    #####: 5490:            char buffer[1024];
    #####: 5491:            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
    #####: 5492:                unsigned int pid;
    #####: 5493:                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
    #####: 5494:                    fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
        -: 5495:                }
        -: 5496:            }
    #####: 5497:            fclose(fp);
        -: 5498:        }
        -: 5499:    }
        -: 5500:
        -: 5501:    /* Create the pid file first with a temporary name, then
        -: 5502:     * atomically move the file to the real name to avoid a race with
        -: 5503:     * another process opening the file to read the pid, but finding
        -: 5504:     * it empty.
        -: 5505:     */
        1: 5506:    char tmp_pid_file[1024];
        1: 5507:    snprintf(tmp_pid_file, sizeof(tmp_pid_file), "%s.tmp", pid_file);
        -: 5508:
        1: 5509:    if ((fp = fopen(tmp_pid_file, "w")) == NULL) {
    #####: 5510:        vperror("Could not open the pid file %s for writing", tmp_pid_file);
    #####: 5511:        return;
        -: 5512:    }
        -: 5513:
        1: 5514:    fprintf(fp,"%ld\n", (long)getpid());
        1: 5515:    if (fclose(fp) == -1) {
    #####: 5516:        vperror("Could not close the pid file %s", tmp_pid_file);
        -: 5517:    }
        -: 5518:
        1: 5519:    if (rename(tmp_pid_file, pid_file) != 0) {
    #####: 5520:        vperror("Could not rename the pid file from %s to %s",
        -: 5521:                tmp_pid_file, pid_file);
        -: 5522:    }
        -: 5523:}
        -: 5524:
    #####: 5525:static void remove_pidfile(const char *pid_file) {
    #####: 5526:  if (pid_file == NULL)
        -: 5527:      return;
        -: 5528:
    #####: 5529:  if (unlink(pid_file) != 0) {
    #####: 5530:      vperror("Could not remove the pid file %s", pid_file);
        -: 5531:  }
        -: 5532:
        -: 5533:}
        -: 5534:
       88: 5535:static void sig_handler(const int sig) {
       88: 5536:    printf("Signal handled: %s.\n", strsignal(sig));
       88: 5537:    exit(EXIT_SUCCESS);
        -: 5538:}
        -: 5539:
        -: 5540:#ifndef HAVE_SIGIGNORE
        -: 5541:static int sigignore(int sig) {
        -: 5542:    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };
        -: 5543:
        -: 5544:    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {
        -: 5545:        return -1;
        -: 5546:    }
        -: 5547:    return 0;
        -: 5548:}
        -: 5549:#endif
        -: 5550:
        -: 5551:
        -: 5552:/*
        -: 5553: * On systems that supports multiple page sizes we may reduce the
        -: 5554: * number of TLB-misses by using the biggest available page size
        -: 5555: */
    #####: 5556:static int enable_large_pages(void) {
        -: 5557:#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
        -: 5558:    int ret = -1;
        -: 5559:    size_t sizes[32];
        -: 5560:    int avail = getpagesizes(sizes, 32);
        -: 5561:    if (avail != -1) {
        -: 5562:        size_t max = sizes[0];
        -: 5563:        struct memcntl_mha arg = {0};
        -: 5564:        int ii;
        -: 5565:
        -: 5566:        for (ii = 1; ii < avail; ++ii) {
        -: 5567:            if (max < sizes[ii]) {
        -: 5568:                max = sizes[ii];
        -: 5569:            }
        -: 5570:        }
        -: 5571:
        -: 5572:        arg.mha_flags   = 0;
        -: 5573:        arg.mha_pagesize = max;
        -: 5574:        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;
        -: 5575:
        -: 5576:        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
        -: 5577:            fprintf(stderr, "Failed to set large pages: %s\n",
        -: 5578:                    strerror(errno));
        -: 5579:            fprintf(stderr, "Will use default page size\n");
        -: 5580:        } else {
        -: 5581:            ret = 0;
        -: 5582:        }
        -: 5583:    } else {
        -: 5584:        fprintf(stderr, "Failed to get supported pagesizes: %s\n",
        -: 5585:                strerror(errno));
        -: 5586:        fprintf(stderr, "Will use default page size\n");
        -: 5587:    }
        -: 5588:
        -: 5589:    return ret;
        -: 5590:#else
    #####: 5591:    return -1;
        -: 5592:#endif
        -: 5593:}
        -: 5594:
        -: 5595:/**
        -: 5596: * Do basic sanity check of the runtime environment
        -: 5597: * @return true if no errors found, false if we can't use this env
        -: 5598: */
      183: 5599:static bool sanitycheck(void) {
        -: 5600:    /* One of our biggest problems is old and bogus libevents */
      183: 5601:    const char *ever = event_get_version();
      183: 5602:    if (ever != NULL) {
      183: 5603:        if (strncmp(ever, "1.", 2) == 0) {
        -: 5604:            /* Require at least 1.3 (that's still a couple of years old) */
    #####: 5605:            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {
    #####: 5606:                fprintf(stderr, "You are using libevent %s.\nPlease upgrade to"
        -: 5607:                        " a more recent version (1.3 or newer)\n",
        -: 5608:                        event_get_version());
    #####: 5609:                return false;
        -: 5610:            }
        -: 5611:        }
        -: 5612:    }
        -: 5613:
        -: 5614:    return true;
        -: 5615:}
        -: 5616:
    #####: 5617:static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    #####: 5618:    char *b = NULL;
    #####: 5619:    uint32_t size = 0;
    #####: 5620:    int i = 0;
    #####: 5621:    uint32_t last_size = 0;
        -: 5622:
    #####: 5623:    if (strlen(s) < 1)
        -: 5624:        return false;
        -: 5625:
    #####: 5626:    for (char *p = strtok_r(s, "-", &b);
    #####: 5627:         p != NULL;
    #####: 5628:         p = strtok_r(NULL, "-", &b)) {
    #####: 5629:        if (!safe_strtoul(p, &size) || size < settings.chunk_size
    #####: 5630:             || size > settings.slab_chunk_size_max) {
    #####: 5631:            fprintf(stderr, "slab size %u is out of valid range\n", size);
    #####: 5632:            return false;
        -: 5633:        }
    #####: 5634:        if (last_size >= size) {
    #####: 5635:            fprintf(stderr, "slab size %u cannot be lower than or equal to a previous class size\n", size);
    #####: 5636:            return false;
        -: 5637:        }
    #####: 5638:        if (size <= last_size + CHUNK_ALIGN_BYTES) {
    #####: 5639:            fprintf(stderr, "slab size %u must be at least %d bytes larger than previous class\n",
        -: 5640:                    size, CHUNK_ALIGN_BYTES);
    #####: 5641:            return false;
        -: 5642:        }
    #####: 5643:        slab_sizes[i++] = size;
    #####: 5644:        last_size = size;
    #####: 5645:        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
    #####: 5646:            fprintf(stderr, "too many slab classes specified\n");
    #####: 5647:            return false;
        -: 5648:        }
        -: 5649:    }
        -: 5650:
    #####: 5651:    slab_sizes[i] = 0;
    #####: 5652:    return true;
        -: 5653:}
        -: 5654:
      183: 5655:int main (int argc, char **argv) {
      183: 5656:    int c;
      183: 5657:    bool lock_memory = false;
      183: 5658:    bool do_daemonize = false;
      183: 5659:    bool preallocate = false;
      183: 5660:    int maxcore = 0;
      183: 5661:    char *username = NULL;
      183: 5662:    char *pid_file = NULL;
      183: 5663:    struct passwd *pw;
      183: 5664:    struct rlimit rlim;
      183: 5665:    char *buf;
      183: 5666:    char unit = '\0';
      183: 5667:    int size_max = 0;
      183: 5668:    int retval = EXIT_SUCCESS;
        -: 5669:    /* listening sockets */
      183: 5670:    static int *l_socket = NULL;
        -: 5671:
        -: 5672:    /* udp socket */
      183: 5673:    static int *u_socket = NULL;
      183: 5674:    bool protocol_specified = false;
      183: 5675:    bool tcp_specified = false;
      183: 5676:    bool udp_specified = false;
      183: 5677:    bool start_lru_maintainer = false;
      183: 5678:    bool start_lru_crawler = false;
      183: 5679:    enum hashfunc_type hash_type = JENKINS_HASH;
      183: 5680:    uint32_t tocrawl;
      183: 5681:    uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];
      183: 5682:    bool use_slab_sizes = false;
      183: 5683:    char *slab_sizes_unparsed = NULL;
      183: 5684:    bool slab_chunk_size_changed = false;
        -: 5685:
      183: 5686:    char *subopts, *subopts_orig;
      183: 5687:    char *subopts_value;
      183: 5688:    enum {
        -: 5689:        MAXCONNS_FAST = 0,
        -: 5690:        HASHPOWER_INIT,
        -: 5691:        SLAB_REASSIGN,
        -: 5692:        SLAB_AUTOMOVE,
        -: 5693:        TAIL_REPAIR_TIME,
        -: 5694:        HASH_ALGORITHM,
        -: 5695:        LRU_CRAWLER,
        -: 5696:        LRU_CRAWLER_SLEEP,
        -: 5697:        LRU_CRAWLER_TOCRAWL,
        -: 5698:        LRU_MAINTAINER,
        -: 5699:        HOT_LRU_PCT,
        -: 5700:        WARM_LRU_PCT,
        -: 5701:        NOEXP_NOEVICT,
        -: 5702:        IDLE_TIMEOUT,
        -: 5703:        WATCHER_LOGBUF_SIZE,
        -: 5704:        WORKER_LOGBUF_SIZE,
        -: 5705:        SLAB_SIZES,
        -: 5706:        SLAB_CHUNK_MAX,
        -: 5707:        TRACK_SIZES,
        -: 5708:        MODERN
        -: 5709:    };
      183: 5710:    char *const subopts_tokens[] = {
        -: 5711:        [MAXCONNS_FAST] = "maxconns_fast",
        -: 5712:        [HASHPOWER_INIT] = "hashpower",
        -: 5713:        [SLAB_REASSIGN] = "slab_reassign",
        -: 5714:        [SLAB_AUTOMOVE] = "slab_automove",
        -: 5715:        [TAIL_REPAIR_TIME] = "tail_repair_time",
        -: 5716:        [HASH_ALGORITHM] = "hash_algorithm",
        -: 5717:        [LRU_CRAWLER] = "lru_crawler",
        -: 5718:        [LRU_CRAWLER_SLEEP] = "lru_crawler_sleep",
        -: 5719:        [LRU_CRAWLER_TOCRAWL] = "lru_crawler_tocrawl",
        -: 5720:        [LRU_MAINTAINER] = "lru_maintainer",
        -: 5721:        [HOT_LRU_PCT] = "hot_lru_pct",
        -: 5722:        [WARM_LRU_PCT] = "warm_lru_pct",
        -: 5723:        [NOEXP_NOEVICT] = "expirezero_does_not_evict",
        -: 5724:        [IDLE_TIMEOUT] = "idle_timeout",
        -: 5725:        [WATCHER_LOGBUF_SIZE] = "watcher_logbuf_size",
        -: 5726:        [WORKER_LOGBUF_SIZE] = "worker_logbuf_size",
        -: 5727:        [SLAB_SIZES] = "slab_sizes",
        -: 5728:        [SLAB_CHUNK_MAX] = "slab_chunk_max",
        -: 5729:        [TRACK_SIZES] = "track_sizes",
        -: 5730:        [MODERN] = "modern",
        -: 5731:        NULL
        -: 5732:    };
        -: 5733:
      183: 5734:    if (!sanitycheck()) {
        -: 5735:        return EX_OSERR;
        -: 5736:    }
        -: 5737:
        -: 5738:    /* handle SIGINT and SIGTERM */
      183: 5739:    signal(SIGINT, sig_handler);
      183: 5740:    signal(SIGTERM, sig_handler);
        -: 5741:
        -: 5742:    /* init settings */
      183: 5743:    settings_init();
        -: 5744:
        -: 5745:    /* Run regardless of initializing it later */
      183: 5746:    init_lru_crawler();
      183: 5747:    init_lru_maintainer();
        -: 5748:
        -: 5749:    /* set stderr non-buffering (for running under, say, daemontools) */
      183: 5750:    setbuf(stderr, NULL);
        -: 5751:
        -: 5752:    /* process arguments */
      605: 5753:    while (-1 != (c = getopt(argc, argv,
        -: 5754:          "a:"  /* access mask for unix socket */
        -: 5755:          "A"  /* enable admin shutdown commannd */
        -: 5756:          "p:"  /* TCP port number to listen on */
        -: 5757:          "s:"  /* unix socket path to listen on */
        -: 5758:          "U:"  /* UDP port number to listen on */
        -: 5759:          "m:"  /* max memory to use for items in megabytes */
        -: 5760:          "M"   /* return error on memory exhausted */
        -: 5761:          "c:"  /* max simultaneous connections */
        -: 5762:          "k"   /* lock down all paged memory */
        -: 5763:          "hiV" /* help, licence info, version */
        -: 5764:          "r"   /* maximize core file limit */
        -: 5765:          "v"   /* verbose */
        -: 5766:          "d"   /* daemon mode */
        -: 5767:          "l:"  /* interface to listen on */
        -: 5768:          "u:"  /* user identity to run as */
        -: 5769:          "P:"  /* save PID in file */
        -: 5770:          "f:"  /* factor? */
        -: 5771:          "n:"  /* minimum space allocated for key+value+flags */
        -: 5772:          "t:"  /* threads */
        -: 5773:          "D:"  /* prefix delimiter? */
        -: 5774:          "L"   /* Large memory pages */
        -: 5775:          "R:"  /* max requests per event */
        -: 5776:          "C"   /* Disable use of CAS */
        -: 5777:          "b:"  /* backlog queue limit */
        -: 5778:          "B:"  /* Binding protocol */
        -: 5779:          "I:"  /* Max item size */
        -: 5780:          "S"   /* Sasl ON */
        -: 5781:          "F"   /* Disable flush_all */
        -: 5782:          "X"   /* Disable dump commands */
        -: 5783:          "o:"  /* Extended generic options */
        -: 5784:        ))) {
      332: 5785:        switch (c) {
        3: 5786:        case 'A':
        -: 5787:            /* enables "shutdown" command */
        3: 5788:            settings.shutdown_command = true;
        3: 5789:            break;
        -: 5790:
    #####: 5791:        case 'a':
        -: 5792:            /* access for unix domain socket, as octal mask (like chmod)*/
    #####: 5793:            settings.access= strtol(optarg,NULL,8);
    #####: 5794:            break;
        -: 5795:
       87: 5796:        case 'U':
       87: 5797:            settings.udpport = atoi(optarg);
       87: 5798:            udp_specified = true;
       87: 5799:            break;
       87: 5800:        case 'p':
       87: 5801:            settings.port = atoi(optarg);
       87: 5802:            tcp_specified = true;
       87: 5803:            break;
        2: 5804:        case 's':
        2: 5805:            settings.socketpath = optarg;
        2: 5806:            break;
       16: 5807:        case 'm':
       16: 5808:            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;
       16: 5809:            break;
        2: 5810:        case 'M':
        2: 5811:            settings.evict_to_free = 0;
        2: 5812:            break;
        3: 5813:        case 'c':
        3: 5814:            settings.maxconns = atoi(optarg);
        3: 5815:            if (settings.maxconns <= 0) {
        2: 5816:                fprintf(stderr, "Maximum connections must be greater than 0\n");
        2: 5817:                return 1;
        -: 5818:            }
        -: 5819:            break;
       86: 5820:        case 'h':
       86: 5821:            usage();
       86: 5822:            exit(EXIT_SUCCESS);
    #####: 5823:        case 'i':
    #####: 5824:            usage_license();
    #####: 5825:            exit(EXIT_SUCCESS);
        -: 5826:        case 'V':
    #####: 5827:            printf(PACKAGE " " VERSION "\n");
    #####: 5828:            exit(EXIT_SUCCESS);
        -: 5829:        case 'k':
        -: 5830:            lock_memory = true;
        -: 5831:            break;
        6: 5832:        case 'v':
        6: 5833:            settings.verbose++;
        6: 5834:            break;
        2: 5835:        case 'l':
        2: 5836:            if (settings.inter != NULL) {
    #####: 5837:                if (strstr(settings.inter, optarg) != NULL) {
        -: 5838:                    break;
        -: 5839:                }
    #####: 5840:                size_t len = strlen(settings.inter) + strlen(optarg) + 2;
    #####: 5841:                char *p = malloc(len);
    #####: 5842:                if (p == NULL) {
    #####: 5843:                    fprintf(stderr, "Failed to allocate memory\n");
    #####: 5844:                    return 1;
        -: 5845:                }
    #####: 5846:                snprintf(p, len, "%s,%s", settings.inter, optarg);
    #####: 5847:                free(settings.inter);
    #####: 5848:                settings.inter = p;
        -: 5849:            } else {
        2: 5850:                settings.inter= strdup(optarg);
        -: 5851:            }
        -: 5852:            break;
        2: 5853:        case 'd':
        2: 5854:            do_daemonize = true;
        2: 5855:            break;
    #####: 5856:        case 'r':
    #####: 5857:            maxcore = 1;
    #####: 5858:            break;
        1: 5859:        case 'R':
        1: 5860:            settings.reqs_per_event = atoi(optarg);
        1: 5861:            if (settings.reqs_per_event == 0) {
    #####: 5862:                fprintf(stderr, "Number of requests per event must be greater than 0\n");
    #####: 5863:                return 1;
        -: 5864:            }
        -: 5865:            break;
    #####: 5866:        case 'u':
    #####: 5867:            username = optarg;
    #####: 5868:            break;
        2: 5869:        case 'P':
        2: 5870:            pid_file = optarg;
        2: 5871:            break;
    #####: 5872:        case 'f':
    #####: 5873:            settings.factor = atof(optarg);
    #####: 5874:            if (settings.factor <= 1.0) {
    #####: 5875:                fprintf(stderr, "Factor must be greater than 1\n");
    #####: 5876:                return 1;
        -: 5877:            }
        -: 5878:            break;
    #####: 5879:        case 'n':
    #####: 5880:            settings.chunk_size = atoi(optarg);
    #####: 5881:            if (settings.chunk_size == 0) {
    #####: 5882:                fprintf(stderr, "Chunk size must be greater than 0\n");
    #####: 5883:                return 1;
        -: 5884:            }
        -: 5885:            break;
        1: 5886:        case 't':
        1: 5887:            settings.num_threads = atoi(optarg);
        1: 5888:            if (settings.num_threads <= 0) {
        1: 5889:                fprintf(stderr, "Number of threads must be greater than 0\n");
        1: 5890:                return 1;
        -: 5891:            }
        -: 5892:            /* There're other problems when you get above 64 threads.
        -: 5893:             * In the future we should portably detect # of cores for the
        -: 5894:             * default.
        -: 5895:             */
    #####: 5896:            if (settings.num_threads > 64) {
     422*: 5897:                fprintf(stderr, "WARNING: Setting a high number of worker"
        -: 5898:                                "threads is not recommended.\n"
        -: 5899:                                " Set this value to the number of cores in"
        -: 5900:                                " your machine or less.\n");
        -: 5901:            }
        -: 5902:            break;
    #####: 5903:        case 'D':
    #####: 5904:            if (! optarg || ! optarg[0]) {
    #####: 5905:                fprintf(stderr, "No delimiter specified\n");
    #####: 5906:                return 1;
        -: 5907:            }
    #####: 5908:            settings.prefix_delimiter = optarg[0];
    #####: 5909:            settings.detail_enabled = 1;
    #####: 5910:            break;
        -: 5911:        case 'L' :
    #####: 5912:            if (enable_large_pages() == 0) {
        -: 5913:                preallocate = true;
        -: 5914:            } else {
    #####: 5915:                fprintf(stderr, "Cannot enable large pages on this system\n"
        -: 5916:                    "(There is no Linux support as of this version)\n");
    #####: 5917:                return 1;
        -: 5918:            }
        -: 5919:            break;
        2: 5920:        case 'C' :
        2: 5921:            settings.use_cas = false;
        2: 5922:            break;
        1: 5923:        case 'b' :
        1: 5924:            settings.backlog = atoi(optarg);
        1: 5925:            break;
        8: 5926:        case 'B':
        8: 5927:            protocol_specified = true;
        8: 5928:            if (strcmp(optarg, "auto") == 0) {
        2: 5929:                settings.binding_protocol = negotiating_prot;
        6: 5930:            } else if (strcmp(optarg, "binary") == 0) {
        3: 5931:                settings.binding_protocol = binary_prot;
        3: 5932:            } else if (strcmp(optarg, "ascii") == 0) {
        2: 5933:                settings.binding_protocol = ascii_prot;
        -: 5934:            } else {
        1: 5935:                fprintf(stderr, "Invalid value for binding protocol: %s\n"
        -: 5936:                        " -- should be one of auto, binary, or ascii\n", optarg);
        1: 5937:                exit(EX_USAGE);
        -: 5938:            }
        -: 5939:            break;
        5: 5940:        case 'I':
        5: 5941:            buf = strdup(optarg);
        5: 5942:            unit = buf[strlen(buf)-1];
        5: 5943:            if (unit == 'k' || unit == 'm' ||
        3: 5944:                unit == 'K' || unit == 'M') {
        2: 5945:                buf[strlen(buf)-1] = '\0';
        2: 5946:                size_max = atoi(buf);
        2: 5947:                if (unit == 'k' || unit == 'K')
        1: 5948:                    size_max *= 1024;
        2: 5949:                if (unit == 'm' || unit == 'M')
        1: 5950:                    size_max *= 1024 * 1024;
        2: 5951:                settings.item_size_max = size_max;
        -: 5952:            } else {
        3: 5953:                settings.item_size_max = atoi(buf);
        -: 5954:            }
        5: 5955:            free(buf);
        5: 5956:            if (settings.item_size_max < 1024) {
        1: 5957:                fprintf(stderr, "Item max size cannot be less than 1024 bytes.\n");
        1: 5958:                return 1;
        -: 5959:            }
        4: 5960:            if (settings.item_size_max > (settings.maxbytes / 4)) {
        1: 5961:                fprintf(stderr, "Cannot set item size limit higher than 1/4 of memory max.\n");
        1: 5962:                return 1;
        -: 5963:            }
        3: 5964:            if (settings.item_size_max > (1024 * 1024 * 1024)) {
    #####: 5965:                fprintf(stderr, "Cannot set item size limit higher than a gigabyte.\n");
    #####: 5966:                return 1;
        -: 5967:            }
        3: 5968:            if (settings.item_size_max > 1024 * 1024) {
        1: 5969:                if (!slab_chunk_size_changed) {
        -: 5970:                    // Ideal new default is 16k, but needs stitching.
        1: 5971:                    settings.slab_chunk_size_max = 524288;
        -: 5972:                }
        -: 5973:            }
        -: 5974:            break;
        1: 5975:        case 'S': /* set Sasl authentication to true. Default is false */
        -: 5976:#ifndef ENABLE_SASL
        1: 5977:            fprintf(stderr, "This server is not built with SASL support.\n");
        1: 5978:            exit(EX_USAGE);
        -: 5979:#endif
        -: 5980:            settings.sasl = true;
        -: 5981:            break;
        1: 5982:       case 'F' :
        1: 5983:            settings.flush_enabled = false;
        1: 5984:            break;
    #####: 5985:       case 'X' :
    #####: 5986:            settings.dump_enabled = false;
    #####: 5987:            break;
       14: 5988:        case 'o': /* It's sub-opts time! */
       14: 5989:            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */
        -: 5990:
       14: 5991:            while (*subopts != '\0') {
        -: 5992:
       25: 5993:            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
    #####: 5994:            case MAXCONNS_FAST:
    #####: 5995:                settings.maxconns_fast = true;
    #####: 5996:                break;
    #####: 5997:            case HASHPOWER_INIT:
    #####: 5998:                if (subopts_value == NULL) {
    #####: 5999:                    fprintf(stderr, "Missing numeric argument for hashpower\n");
    #####: 6000:                    return 1;
        -: 6001:                }
    #####: 6002:                settings.hashpower_init = atoi(subopts_value);
    #####: 6003:                if (settings.hashpower_init < 12) {
    #####: 6004:                    fprintf(stderr, "Initial hashtable multiplier of %d is too low\n",
        -: 6005:                        settings.hashpower_init);
    #####: 6006:                    return 1;
    #####: 6007:                } else if (settings.hashpower_init > 64) {
    #####: 6008:                    fprintf(stderr, "Initial hashtable multiplier of %d is too high\n"
        -: 6009:                        "Choose a value based on \"STAT hash_power_level\" from a running instance\n",
        -: 6010:                        settings.hashpower_init);
    #####: 6011:                    return 1;
        -: 6012:                }
        -: 6013:                break;
        3: 6014:            case SLAB_REASSIGN:
        3: 6015:                settings.slab_reassign = true;
        3: 6016:                break;
        2: 6017:            case SLAB_AUTOMOVE:
        2: 6018:                if (subopts_value == NULL) {
        2: 6019:                    settings.slab_automove = 1;
        2: 6020:                    break;
        -: 6021:                }
    #####: 6022:                settings.slab_automove = atoi(subopts_value);
    #####: 6023:                if (settings.slab_automove < 0 || settings.slab_automove > 2) {
    #####: 6024:                    fprintf(stderr, "slab_automove must be between 0 and 2\n");
    #####: 6025:                    return 1;
        -: 6026:                }
        -: 6027:                break;
    #####: 6028:            case TAIL_REPAIR_TIME:
    #####: 6029:                if (subopts_value == NULL) {
    #####: 6030:                    fprintf(stderr, "Missing numeric argument for tail_repair_time\n");
    #####: 6031:                    return 1;
        -: 6032:                }
    #####: 6033:                settings.tail_repair_time = atoi(subopts_value);
    #####: 6034:                if (settings.tail_repair_time < 10) {
    #####: 6035:                    fprintf(stderr, "Cannot set tail_repair_time to less than 10 seconds\n");
    #####: 6036:                    return 1;
        -: 6037:                }
        -: 6038:                break;
    #####: 6039:            case HASH_ALGORITHM:
    #####: 6040:                if (subopts_value == NULL) {
    #####: 6041:                    fprintf(stderr, "Missing hash_algorithm argument\n");
    #####: 6042:                    return 1;
    #####: 6043:                };
    #####: 6044:                if (strcmp(subopts_value, "jenkins") == 0) {
        -: 6045:                    hash_type = JENKINS_HASH;
    #####: 6046:                } else if (strcmp(subopts_value, "murmur3") == 0) {
        -: 6047:                    hash_type = MURMUR3_HASH;
        -: 6048:                } else {
    #####: 6049:                    fprintf(stderr, "Unknown hash_algorithm option (jenkins, murmur3)\n");
    #####: 6050:                    return 1;
        -: 6051:                }
        -: 6052:                break;
        -: 6053:            case LRU_CRAWLER:
        -: 6054:                start_lru_crawler = true;
        -: 6055:                break;
    #####: 6056:            case LRU_CRAWLER_SLEEP:
    #####: 6057:                if (subopts_value == NULL) {
    #####: 6058:                    fprintf(stderr, "Missing lru_crawler_sleep value\n");
    #####: 6059:                    return 1;
        -: 6060:                }
    #####: 6061:                settings.lru_crawler_sleep = atoi(subopts_value);
    #####: 6062:                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {
    #####: 6063:                    fprintf(stderr, "LRU crawler sleep must be between 0 and 1 second\n");
    #####: 6064:                    return 1;
        -: 6065:                }
        -: 6066:                break;
    #####: 6067:            case LRU_CRAWLER_TOCRAWL:
    #####: 6068:                if (subopts_value == NULL) {
    #####: 6069:                    fprintf(stderr, "Missing lru_crawler_tocrawl value\n");
    #####: 6070:                    return 1;
        -: 6071:                }
    #####: 6072:                if (!safe_strtoul(subopts_value, &tocrawl)) {
    #####: 6073:                    fprintf(stderr, "lru_crawler_tocrawl takes a numeric 32bit value\n");
    #####: 6074:                    return 1;
        -: 6075:                }
    #####: 6076:                settings.lru_crawler_tocrawl = tocrawl;
    #####: 6077:                break;
        5: 6078:            case LRU_MAINTAINER:
        5: 6079:                start_lru_maintainer = true;
        5: 6080:                break;
    #####: 6081:            case HOT_LRU_PCT:
    #####: 6082:                if (subopts_value == NULL) {
    #####: 6083:                    fprintf(stderr, "Missing hot_lru_pct argument\n");
    #####: 6084:                    return 1;
    #####: 6085:                };
    #####: 6086:                settings.hot_lru_pct = atoi(subopts_value);
    #####: 6087:                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {
    #####: 6088:                    fprintf(stderr, "hot_lru_pct must be > 1 and < 80\n");
    #####: 6089:                    return 1;
        -: 6090:                }
        -: 6091:                break;
    #####: 6092:            case WARM_LRU_PCT:
    #####: 6093:                if (subopts_value == NULL) {
    #####: 6094:                    fprintf(stderr, "Missing warm_lru_pct argument\n");
    #####: 6095:                    return 1;
    #####: 6096:                };
    #####: 6097:                settings.warm_lru_pct = atoi(subopts_value);
    #####: 6098:                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {
    #####: 6099:                    fprintf(stderr, "warm_lru_pct must be > 1 and < 80\n");
    #####: 6100:                    return 1;
        -: 6101:                }
        -: 6102:                break;
        1: 6103:            case NOEXP_NOEVICT:
        1: 6104:                settings.expirezero_does_not_evict = true;
        1: 6105:                break;
        1: 6106:            case IDLE_TIMEOUT:
        1: 6107:                settings.idle_timeout = atoi(subopts_value);
        1: 6108:                break;
        1: 6109:            case WATCHER_LOGBUF_SIZE:
        1: 6110:                if (subopts_value == NULL) {
    #####: 6111:                    fprintf(stderr, "Missing watcher_logbuf_size argument\n");
    #####: 6112:                    return 1;
        -: 6113:                }
        1: 6114:                if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {
    #####: 6115:                    fprintf(stderr, "could not parse argument to watcher_logbuf_size\n");
    #####: 6116:                    return 1;
        -: 6117:                }
        1: 6118:                settings.logger_watcher_buf_size *= 1024; /* kilobytes */
        1: 6119:                break;
    #####: 6120:            case WORKER_LOGBUF_SIZE:
    #####: 6121:                if (subopts_value == NULL) {
    #####: 6122:                    fprintf(stderr, "Missing worker_logbuf_size argument\n");
    #####: 6123:                    return 1;
        -: 6124:                }
    #####: 6125:                if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {
    #####: 6126:                    fprintf(stderr, "could not parse argument to worker_logbuf_size\n");
    #####: 6127:                    return 1;
        -: 6128:                }
    #####: 6129:                settings.logger_buf_size *= 1024; /* kilobytes */
    #####: 6130:            case SLAB_SIZES:
    #####: 6131:                slab_sizes_unparsed = subopts_value;
    #####: 6132:                break;
        5: 6133:            case SLAB_CHUNK_MAX:
        5: 6134:                if (subopts_value == NULL) {
    #####: 6135:                    fprintf(stderr, "Missing slab_chunk_max argument\n");
        -: 6136:                }
        5: 6137:                if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {
      39*: 6138:                    fprintf(stderr, "could not parse argument to slab_chunk_max\n");
        -: 6139:                }
        -: 6140:                slab_chunk_size_changed = true;
        -: 6141:                break;
    #####: 6142:            case TRACK_SIZES:
    #####: 6143:                item_stats_sizes_init();
    #####: 6144:                break;
        1: 6145:            case MODERN:
        -: 6146:                /* Modernized defaults. Need to add equivalent no_* flags
        -: 6147:                 * before making truly default. */
        -: 6148:                // chunk default should come after stitching is fixed.
        -: 6149:                //settings.slab_chunk_size_max = 16384;
        -: 6150:
        -: 6151:                // With slab_ressign, pages are always 1MB, so anything larger
        -: 6152:                // than .5m ends up using 1m anyway. With this we at least
        -: 6153:                // avoid having several slab classes that use 1m.
        1: 6154:                if (!slab_chunk_size_changed) {
        1: 6155:                    settings.slab_chunk_size_max = 524288;
        -: 6156:                }
        1: 6157:                settings.slab_reassign = true;
        1: 6158:                settings.slab_automove = 1;
        1: 6159:                settings.maxconns_fast = true;
        1: 6160:                hash_type = MURMUR3_HASH;
        1: 6161:                start_lru_crawler = true;
        1: 6162:                start_lru_maintainer = true;
        1: 6163:                break;
    #####: 6164:            default:
    #####: 6165:                printf("Illegal suboption \"%s\"\n", subopts_value);
    #####: 6166:                return 1;
        -: 6167:            }
        -: 6168:
        -: 6169:            }
       14: 6170:            free(subopts_orig);
       14: 6171:            break;
    #####: 6172:        default:
    #####: 6173:            fprintf(stderr, "Illegal argument \"%c\"\n", c);
    #####: 6174:            return 1;
        -: 6175:        }
    #####: 6176:    }
        -: 6177:
       90: 6178:    if (settings.slab_chunk_size_max > settings.item_size_max) {
    #####: 6179:        fprintf(stderr, "slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\n",
        -: 6180:                settings.slab_chunk_size_max, settings.item_size_max);
    #####: 6181:        exit(EX_USAGE);
        -: 6182:    }
        -: 6183:
       90: 6184:    if (settings.item_size_max % settings.slab_chunk_size_max != 0) {
    #####: 6185:        fprintf(stderr, "-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\n",
        -: 6186:                settings.item_size_max, settings.slab_chunk_size_max);
    #####: 6187:        exit(EX_USAGE);
        -: 6188:    }
        -: 6189:
       90: 6190:    if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {
    #####: 6191:        fprintf(stderr, "slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\n",
        -: 6192:                settings.slab_chunk_size_max, settings.slab_page_size);
    #####: 6193:        exit(EX_USAGE);
        -: 6194:    }
        -: 6195:
        -: 6196:    // Reserve this for the new default. If factor size hasn't changed, use
        -: 6197:    // new default.
        -: 6198:    /*if (settings.slab_chunk_size_max == 16384 && settings.factor == 1.25) {
        -: 6199:        settings.factor = 1.08;
        -: 6200:    }*/
        -: 6201:
       90: 6202:    if (slab_sizes_unparsed != NULL) {
    #####: 6203:        if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {
        -: 6204:            use_slab_sizes = true;
        -: 6205:        } else {
    #####: 6206:            exit(EX_USAGE);
        -: 6207:        }
        -: 6208:    }
        -: 6209:
      90*: 6210:    if (settings.lru_maintainer_thread && settings.hot_lru_pct + settings.warm_lru_pct > 80) {
    #####: 6211:        fprintf(stderr, "hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\n");
    #####: 6212:        exit(EX_USAGE);
        -: 6213:    }
        -: 6214:
       90: 6215:    if (hash_init(hash_type) != 0) {
    #####: 6216:        fprintf(stderr, "Failed to initialize hash_algorithm!\n");
    #####: 6217:        exit(EX_USAGE);
        -: 6218:    }
        -: 6219:
        -: 6220:    /*
        -: 6221:     * Use one workerthread to serve each UDP port if the user specified
        -: 6222:     * multiple ports
        -: 6223:     */
       90: 6224:    if (settings.inter != NULL && strchr(settings.inter, ',')) {
    #####: 6225:        settings.num_threads_per_udp = 1;
        -: 6226:    } else {
       90: 6227:        settings.num_threads_per_udp = settings.num_threads;
        -: 6228:    }
        -: 6229:
       90: 6230:    if (settings.sasl) {
    #####: 6231:        if (!protocol_specified) {
    #####: 6232:            settings.binding_protocol = binary_prot;
        -: 6233:        } else {
    #####: 6234:            if (settings.binding_protocol != binary_prot) {
    #####: 6235:                fprintf(stderr, "ERROR: You cannot allow the ASCII protocol while using SASL.\n");
    #####: 6236:                exit(EX_USAGE);
        -: 6237:            }
        -: 6238:        }
        -: 6239:    }
        -: 6240:
       90: 6241:    if (tcp_specified && !udp_specified) {
        3: 6242:        settings.udpport = settings.port;
       87: 6243:    } else if (udp_specified && !tcp_specified) {
        3: 6244:        settings.port = settings.udpport;
        -: 6245:    }
        -: 6246:
       90: 6247:    if (maxcore != 0) {
    #####: 6248:        struct rlimit rlim_new;
        -: 6249:        /*
        -: 6250:         * First try raising to infinity; if that fails, try bringing
        -: 6251:         * the soft limit to the hard.
        -: 6252:         */
    #####: 6253:        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
    #####: 6254:            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
    #####: 6255:            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {
        -: 6256:                /* failed. try raising just to the old max */
    #####: 6257:                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
    #####: 6258:                (void)setrlimit(RLIMIT_CORE, &rlim_new);
        -: 6259:            }
        -: 6260:        }
        -: 6261:        /*
        -: 6262:         * getrlimit again to see what we ended up with. Only fail if
        -: 6263:         * the soft limit ends up 0, because then no core files will be
        -: 6264:         * created at all.
        -: 6265:         */
        -: 6266:
    #####: 6267:        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {
    #####: 6268:            fprintf(stderr, "failed to ensure corefile creation\n");
    #####: 6269:            exit(EX_OSERR);
        -: 6270:        }
        -: 6271:    }
        -: 6272:
        -: 6273:    /*
        -: 6274:     * If needed, increase rlimits to allow as many connections
        -: 6275:     * as needed.
        -: 6276:     */
        -: 6277:
       90: 6278:    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 6279:        fprintf(stderr, "failed to getrlimit number of files\n");
    #####: 6280:        exit(EX_OSERR);
        -: 6281:    } else {
       90: 6282:        rlim.rlim_cur = settings.maxconns;
       90: 6283:        rlim.rlim_max = settings.maxconns;
       90: 6284:        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 6285:            fprintf(stderr, "failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n");
    #####: 6286:            exit(EX_OSERR);
        -: 6287:        }
        -: 6288:    }
        -: 6289:
        -: 6290:    /* lose root privileges if we have them */
       90: 6291:    if (getuid() == 0 || geteuid() == 0) {
    #####: 6292:        if (username == 0 || *username == '\0') {
    #####: 6293:            fprintf(stderr, "can't run as root without the -u switch\n");
    #####: 6294:            exit(EX_USAGE);
        -: 6295:        }
    #####: 6296:        if ((pw = getpwnam(username)) == 0) {
    #####: 6297:            fprintf(stderr, "can't find the user %s to switch to\n", username);
    #####: 6298:            exit(EX_NOUSER);
        -: 6299:        }
    #####: 6300:        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {
    #####: 6301:            fprintf(stderr, "failed to assume identity of user %s\n", username);
    #####: 6302:            exit(EX_OSERR);
        -: 6303:        }
        -: 6304:    }
        -: 6305:
        -: 6306:    /* Initialize Sasl if -S was specified */
       90: 6307:    if (settings.sasl) {
       90: 6308:        init_sasl();
        -: 6309:    }
        -: 6310:
        -: 6311:    /* daemonize if requested */
        -: 6312:    /* if we want to ensure our ability to dump core, don't chdir to / */
       90: 6313:    if (do_daemonize) {
        2: 6314:        if (sigignore(SIGHUP) == -1) {
    #####: 6315:            perror("Failed to ignore SIGHUP");
        -: 6316:        }
        2: 6317:        if (daemonize(maxcore, settings.verbose) == -1) {
    #####: 6318:            fprintf(stderr, "failed to daemon() in order to daemonize\n");
    #####: 6319:            exit(EXIT_FAILURE);
        -: 6320:        }
        -: 6321:    }
        -: 6322:
        -: 6323:    /* lock paged memory if needed */
       89: 6324:    if (lock_memory) {
        -: 6325:#ifdef HAVE_MLOCKALL
    #####: 6326:        int res = mlockall(MCL_CURRENT | MCL_FUTURE);
    #####: 6327:        if (res != 0) {
    #####: 6328:            fprintf(stderr, "warning: -k invalid, mlockall() failed: %s\n",
    #####: 6329:                    strerror(errno));
        -: 6330:        }
        -: 6331:#else
        -: 6332:        fprintf(stderr, "warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\n");
        -: 6333:#endif
        -: 6334:    }
        -: 6335:
        -: 6336:    /* initialize main thread libevent instance */
       89: 6337:    main_base = event_init();
        -: 6338:
        -: 6339:    /* initialize other stuff */
       89: 6340:    logger_init();
       89: 6341:    stats_init();
       89: 6342:    assoc_init(settings.hashpower_init);
       89: 6343:    conn_init();
      178: 6344:    slabs_init(settings.maxbytes, settings.factor, preallocate,
        -: 6345:            use_slab_sizes ? slab_sizes : NULL);
        -: 6346:
        -: 6347:    /*
        -: 6348:     * ignore SIGPIPE signals; we can use errno == EPIPE if we
        -: 6349:     * need that information
        -: 6350:     */
       89: 6351:    if (sigignore(SIGPIPE) == -1) {
    #####: 6352:        perror("failed to ignore SIGPIPE; sigaction");
    #####: 6353:        exit(EX_OSERR);
        -: 6354:    }
        -: 6355:    /* start up worker threads if MT mode */
       89: 6356:    memcached_thread_init(settings.num_threads);
        -: 6357:
       89: 6358:    if (start_assoc_maintenance_thread() == -1) {
    #####: 6359:        exit(EXIT_FAILURE);
        -: 6360:    }
        -: 6361:
       89: 6362:    if (start_lru_crawler && start_item_crawler_thread() != 0) {
    #####: 6363:        fprintf(stderr, "Failed to enable LRU crawler thread\n");
    #####: 6364:        exit(EXIT_FAILURE);
        -: 6365:    }
        -: 6366:
       89: 6367:    if (start_lru_maintainer && start_lru_maintainer_thread() != 0) {
    #####: 6368:        fprintf(stderr, "Failed to enable LRU maintainer thread\n");
    #####: 6369:        return 1;
        -: 6370:    }
        -: 6371:
       93: 6372:    if (settings.slab_reassign &&
        4: 6373:        start_slab_maintenance_thread() == -1) {
    #####: 6374:        exit(EXIT_FAILURE);
        -: 6375:    }
        -: 6376:
       89: 6377:    if (settings.idle_timeout && start_conn_timeout_thread() == -1) {
    #####: 6378:        exit(EXIT_FAILURE);
        -: 6379:    }
        -: 6380:
        -: 6381:    /* initialise clock event */
       89: 6382:    clock_handler(0, 0, 0);
        -: 6383:
        -: 6384:    /* create unix mode sockets after dropping privileges */
       89: 6385:    if (settings.socketpath != NULL) {
        2: 6386:        errno = 0;
        2: 6387:        if (server_socket_unix(settings.socketpath,settings.access)) {
    #####: 6388:            vperror("failed to listen on UNIX socket: %s", settings.socketpath);
    #####: 6389:            exit(EX_OSERR);
        -: 6390:        }
        -: 6391:    }
        -: 6392:
        -: 6393:    /* create the listening socket, bind it, and init */
       89: 6394:    if (settings.socketpath == NULL) {
       87: 6395:        const char *portnumber_filename = getenv("MEMCACHED_PORT_FILENAME");
       87: 6396:        char *temp_portnumber_filename = NULL;
       87: 6397:        size_t len;
       87: 6398:        FILE *portnumber_file = NULL;
        -: 6399:
       87: 6400:        if (portnumber_filename != NULL) {
       14: 6401:            len = strlen(portnumber_filename)+4+1;
       14: 6402:            temp_portnumber_filename = malloc(len);
       14: 6403:            snprintf(temp_portnumber_filename,
        -: 6404:                     len,
        -: 6405:                     "%s.lck", portnumber_filename);
        -: 6406:
       14: 6407:            portnumber_file = fopen(temp_portnumber_filename, "a");
       14: 6408:            if (portnumber_file == NULL) {
    #####: 6409:                fprintf(stderr, "Failed to open \"%s\": %s\n",
    #####: 6410:                        temp_portnumber_filename, strerror(errno));
        -: 6411:            }
        -: 6412:        }
        -: 6413:
       87: 6414:        errno = 0;
       87: 6415:        if (settings.port && server_sockets(settings.port, tcp_transport,
        -: 6416:                                           portnumber_file)) {
        1: 6417:            vperror("failed to listen on TCP port %d", settings.port);
        1: 6418:            exit(EX_OSERR);
        -: 6419:        }
        -: 6420:
        -: 6421:        /*
        -: 6422:         * initialization order: first create the listening sockets
        -: 6423:         * (may need root on low ports), then drop root if needed,
        -: 6424:         * then daemonise if needed, then init libevent (in some cases
        -: 6425:         * descriptors created by libevent wouldn't survive forking).
        -: 6426:         */
        -: 6427:
        -: 6428:        /* create the UDP listening socket and bind it */
       86: 6429:        errno = 0;
       86: 6430:        if (settings.udpport && server_sockets(settings.udpport, udp_transport,
        -: 6431:                                              portnumber_file)) {
    #####: 6432:            vperror("failed to listen on UDP port %d", settings.udpport);
    #####: 6433:            exit(EX_OSERR);
        -: 6434:        }
        -: 6435:
       86: 6436:        if (portnumber_file) {
       14: 6437:            fclose(portnumber_file);
       14: 6438:            rename(temp_portnumber_filename, portnumber_filename);
       14: 6439:            free(temp_portnumber_filename);
        -: 6440:        }
        -: 6441:    }
        -: 6442:
        -: 6443:    /* Give the sockets a moment to open. I know this is dumb, but the error
        -: 6444:     * is only an advisory.
        -: 6445:     */
       88: 6446:    usleep(1000);
       88: 6447:    if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 6448:        fprintf(stderr, "Maxconns setting is too low, use -c to increase.\n");
    #####: 6449:        exit(EXIT_FAILURE);
        -: 6450:    }
        -: 6451:
       88: 6452:    if (pid_file != NULL) {
        1: 6453:        save_pid(pid_file);
        -: 6454:    }
        -: 6455:
        -: 6456:    /* Drop privileges no longer needed */
       88: 6457:    drop_privileges();
        -: 6458:
        -: 6459:    /* Initialize the uriencode lookup table. */
       88: 6460:    uriencode_init();
        -: 6461:
        -: 6462:    /* enter the event loop */
      88*: 6463:    if (event_base_loop(main_base, 0) != 0) {
    #####: 6464:        retval = EXIT_FAILURE;
        -: 6465:    }
        -: 6466:
    #####: 6467:    stop_assoc_maintenance_thread();
        -: 6468:
        -: 6469:    /* remove the PID file if we're a daemon */
    #####: 6470:    if (do_daemonize)
    #####: 6471:        remove_pidfile(pid_file);
        -: 6472:    /* Clean up strdup() call for bind() address */
    #####: 6473:    if (settings.inter)
    #####: 6474:      free(settings.inter);
    #####: 6475:    if (l_socket)
    #####: 6476:      free(l_socket);
    #####: 6477:    if (u_socket)
    #####: 6478:      free(u_socket);
        -: 6479:
        -: 6480:    return retval;
        -: 6481:}
