        -:    0:Source:logger.c
        -:    0:Graph:logger.gcno
        -:    0:Data:logger.gcda
        -:    0:Runs:184
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:
        -:    3:#include <stdlib.h>
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include <errno.h>
        -:    7:#include <poll.h>
        -:    8:#include <ctype.h>
        -:    9:
        -:   10:#if defined(__sun)
        -:   11:#include <atomic.h>
        -:   12:#endif
        -:   13:
        -:   14:#include "memcached.h"
        -:   15:#include "bipbuffer.h"
        -:   16:
        -:   17:#ifdef LOGGER_DEBUG
        -:   18:#define L_DEBUG(...) \
        -:   19:    do { \
        -:   20:        fprintf(stderr, __VA_ARGS__); \
        -:   21:    } while (0)
        -:   22:#else
        -:   23:#define L_DEBUG(...)
        -:   24:#endif
        -:   25:
        -:   26:
        -:   27:/* TODO: put this in a struct and ditch the global vars. */
        -:   28:static logger *logger_stack_head = NULL;
        -:   29:static logger *logger_stack_tail = NULL;
        -:   30:static unsigned int logger_count = 0;
        -:   31:static volatile int do_run_logger_thread = 1;
        -:   32:static pthread_t logger_tid;
        -:   33:pthread_mutex_t logger_stack_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   34:
        -:   35:pthread_key_t logger_key;
        -:   36:
        -:   37:#if !defined(HAVE_GCC_64ATOMICS) && !defined(__sun)
        -:   38:pthread_mutex_t logger_atomics_mutex = PTHREAD_MUTEX_INITIALIZER;
        -:   39:#endif
        -:   40:
        -:   41:#define WATCHER_LIMIT 20
        -:   42:logger_watcher *watchers[20];
        -:   43:struct pollfd watchers_pollfds[20];
        -:   44:int watcher_count = 0;
        -:   45:
        -:   46:/* Should this go somewhere else? */
        -:   47:static const entry_details default_entries[] = {
        -:   48:    [LOGGER_ASCII_CMD] = {LOGGER_TEXT_ENTRY, 512, LOG_RAWCMDS, "<%d %s"},
        -:   49:    [LOGGER_EVICTION] = {LOGGER_EVICTION_ENTRY, 512, LOG_EVICTIONS, NULL},
        -:   50:    [LOGGER_ITEM_GET] = {LOGGER_ITEM_GET_ENTRY, 512, LOG_FETCHERS, NULL},
        -:   51:    [LOGGER_ITEM_STORE] = {LOGGER_ITEM_STORE_ENTRY, 512, LOG_MUTATIONS, NULL},
        -:   52:    [LOGGER_CRAWLER_STATUS] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   53:        "type=lru_crawler crawler=%d low_mark=%llu next_reclaims=%llu since_run=%u next_run=%d elapsed=%u examined=%llu reclaimed=%llu"
        -:   54:    }
        -:   55:};
        -:   56:
        -:   57:#define WATCHER_ALL -1
        -:   58:static int logger_thread_poll_watchers(int force_poll, int watcher);
        -:   59:
        -:   60:/*************************
        -:   61: * Util functions shared between bg thread and workers
        -:   62: *************************/
        -:   63:
        -:   64:/* Logger GID's can be used by watchers to put logs back into strict order
        -:   65: */
    87580:   66:static uint64_t logger_get_gid(void) {
    87580:   67:    static uint64_t logger_gid = 0;
        -:   68:#ifdef HAVE_GCC_64ATOMICS
        -:   69:    return __sync_add_and_fetch(&logger_gid, 1);
        -:   70:#elif defined(__sun)
        -:   71:    return atomic_inc_64_nv(&logger_gid);
        -:   72:#else
    87580:   73:    mutex_lock(&logger_atomics_mutex);
    87580:   74:    uint64_t res = ++logger_gid;
    87580:   75:    mutex_unlock(&logger_atomics_mutex);
    87580:   76:    return res;
        -:   77:#endif
        -:   78:}
        -:   79:
        -:   80:/* TODO: genericize lists. would be nice to import queue.h if the impact is
        -:   81: * studied... otherwise can just write a local one.
        -:   82: */
        -:   83:/* Add to the list of threads with a logger object */
      366:   84:static void logger_link_q(logger *l) {
      366:   85:    pthread_mutex_lock(&logger_stack_lock);
     366*:   86:    assert(l != logger_stack_head);
        -:   87:
      366:   88:    l->prev = 0;
      366:   89:    l->next = logger_stack_head;
      366:   90:    if (l->next) l->next->prev = l;
      366:   91:    logger_stack_head = l;
      366:   92:    if (logger_stack_tail == 0) logger_stack_tail = l;
      366:   93:    logger_count++;
      366:   94:    pthread_mutex_unlock(&logger_stack_lock);
      366:   95:    return;
        -:   96:}
        -:   97:
        -:   98:/* Remove from the list of threads with a logger object */
        -:   99:/*static void logger_unlink_q(logger *l) {
        -:  100:    pthread_mutex_lock(&logger_stack_lock);
        -:  101:    if (logger_stack_head == l) {
        -:  102:        assert(l->prev == 0);
        -:  103:        logger_stack_head = l->next;
        -:  104:    }
        -:  105:    if (logger_stack_tail == l) {
        -:  106:        assert(l->next == 0);
        -:  107:        logger_stack_tail = l->prev;
        -:  108:    }
        -:  109:    assert(l->next != l);
        -:  110:    assert(l->prev != l);
        -:  111:
        -:  112:    if (l->next) l->next->prev = l->prev;
        -:  113:    if (l->prev) l->prev->next = l->next;
        -:  114:    logger_count--;
        -:  115:    pthread_mutex_unlock(&logger_stack_lock);
        -:  116:    return;
        -:  117:}*/
        -:  118:
        -:  119:/* Called with logger stack locked.
        -:  120: * Iterates over every watcher collecting enabled flags.
        -:  121: */
        6:  122:static void logger_set_flags(void) {
        6:  123:    logger *l = NULL;
        6:  124:    int x = 0;
        6:  125:    uint16_t f = 0; /* logger eflags */
        -:  126:
      126:  127:    for (x = 0; x < WATCHER_LIMIT; x++) {
      120:  128:        logger_watcher *w = watchers[x];
      120:  129:        if (w == NULL)
      115:  130:            continue;
        -:  131:
        5:  132:        f |= w->eflags;
        -:  133:    }
       30:  134:    for (l = logger_stack_head; l != NULL; l=l->next) {
       24:  135:        pthread_mutex_lock(&l->mutex);
       24:  136:        l->eflags = f;
       24:  137:        pthread_mutex_unlock(&l->mutex);
        -:  138:    }
        6:  139:    return;
        -:  140:}
        -:  141:
        -:  142:/*************************
        -:  143: * Logger background thread functions. Aggregates per-worker buffers and
        -:  144: * writes to any watchers.
        -:  145: *************************/
        -:  146:
        -:  147:#define LOGGER_PARSE_SCRATCH 4096
        -:  148:
      150:  149:static int _logger_thread_parse_ise(logentry *e, char *scratch) {
      150:  150:    int total;
      150:  151:    const char *cmd = "na";
      150:  152:    char keybuf[KEY_MAX_LENGTH * 3 + 1];
      150:  153:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
      150:  154:    const char * const status_map[] = {
        -:  155:        "not_stored", "stored", "exists", "not_found", "too_large", "no_memory" };
      150:  156:    const char * const cmd_map[] = {
        -:  157:        "null", "add", "set", "replace", "append", "prepend", "cas" };
        -:  158:
      150:  159:    if (le->cmd <= 5)
      150:  160:        cmd = cmd_map[le->cmd];
        -:  161:
      150:  162:    uriencode(le->key, keybuf, le->nkey, LOGGER_PARSE_SCRATCH);
      150:  163:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  164:            "ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u\n",
      150:  165:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
      150:  166:            keybuf, status_map[le->status], cmd, le->ttl, le->clsid);
      150:  167:    return total;
        -:  168:}
        -:  169:
    87266:  170:static int _logger_thread_parse_ige(logentry *e, char *scratch) {
    87266:  171:    int total;
    87266:  172:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    87266:  173:    char keybuf[KEY_MAX_LENGTH * 3 + 1];
    87266:  174:    const char * const was_found_map[] = {
        -:  175:        "not_found", "found", "flushed", "expired" };
        -:  176:
    87266:  177:    uriencode(le->key, keybuf, le->nkey, LOGGER_PARSE_SCRATCH);
    87266:  178:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  179:            "ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u\n",
    87266:  180:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
    87266:  181:            keybuf, was_found_map[le->was_found], le->clsid);
    87266:  182:    return total;
        -:  183:}
        -:  184:
      150:  185:static int _logger_thread_parse_ee(logentry *e, char *scratch) {
      150:  186:    int total;
      150:  187:    char keybuf[KEY_MAX_LENGTH * 3 + 1];
      150:  188:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
      150:  189:    uriencode(le->key, keybuf, le->nkey, LOGGER_PARSE_SCRATCH);
      300:  190:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  191:            "ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u\n",
      150:  192:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
      150:  193:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
      150:  194:            (long long int)le->exptime, le->latime, le->clsid);
        -:  195:
      150:  196:    return total;
        -:  197:}
        -:  198:
        -:  199:/* Completes rendering of log line. */
        -:  200:static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        -:  201:        char *scratch, int *scratch_len) {
        -:  202:    int total = 0;
        -:  203:
        -:  204:    switch (e->event) {
        -:  205:        case LOGGER_TEXT_ENTRY:
        -:  206:            total = snprintf(scratch, LOGGER_PARSE_SCRATCH, "ts=%d.%d gid=%llu %s\n",
        -:  207:                        (int)e->tv.tv_sec, (int)e->tv.tv_usec,
        -:  208:                        (unsigned long long) e->gid, (char *) e->data);
        -:  209:            break;
        -:  210:        case LOGGER_EVICTION_ENTRY:
        -:  211:            total = _logger_thread_parse_ee(e, scratch);
        -:  212:            break;
        -:  213:        case LOGGER_ITEM_GET_ENTRY:
        -:  214:            total = _logger_thread_parse_ige(e, scratch);
        -:  215:            break;
        -:  216:        case LOGGER_ITEM_STORE_ENTRY:
        -:  217:            total = _logger_thread_parse_ise(e, scratch);
        -:  218:            break;
        -:  219:
        -:  220:    }
        -:  221:
        -:  222:    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
        -:  223:        L_DEBUG("LOGGER: Failed to flatten log entry!\n");
        -:  224:        return LOGGER_PARSE_ENTRY_FAILED;
        -:  225:    } else {
        -:  226:        *scratch_len = total;
        -:  227:    }
        -:  228:
        -:  229:    return LOGGER_PARSE_ENTRY_OK;
        -:  230:}
        -:  231:
        -:  232:/* Writes flattened entry to available watchers */
        -:  233:static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        -:  234:        char *scratch, int scratch_len) {
        -:  235:    int x, total;
        -:  236:    /* Write the line into available watchers with matching flags */
        -:  237:    for (x = 0; x < WATCHER_LIMIT; x++) {
        -:  238:        logger_watcher *w = watchers[x];
        -:  239:        char *skip_scr = NULL;
        -:  240:        if (w == NULL || (e->eflags & w->eflags) == 0)
        -:  241:            continue;
        -:  242:
        -:  243:         /* Avoid poll()'ing constantly when buffer is full by resetting a
        -:  244:         * flag periodically.
        -:  245:         */
        -:  246:        while (!w->failed_flush &&
        -:  247:                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
        -:  248:            if (logger_thread_poll_watchers(0, x) <= 0) {
        -:  249:                L_DEBUG("LOGGER: Watcher had no free space for line of size (%d)\n", scratch_len + 128);
        -:  250:                w->failed_flush = true;
        -:  251:            }
        -:  252:        }
        -:  253:
        -:  254:        if (w->failed_flush) {
        -:  255:            L_DEBUG("LOGGER: Fast skipped for watcher [%d] due to failed_flush\n", w->sfd);
        -:  256:            w->skipped++;
        -:  257:            ls->watcher_skipped++;
        -:  258:            continue;
        -:  259:        }
        -:  260:
        -:  261:        if (w->skipped > 0) {
        -:  262:            total = snprintf(skip_scr, 128, "skipped=%llu\n", (unsigned long long) w->skipped);
        -:  263:            if (total >= 128 || total <= 0) {
        -:  264:                L_DEBUG("LOGGER: Failed to flatten skipped message into watcher [%d]\n", w->sfd);
        -:  265:                w->skipped++;
        -:  266:                ls->watcher_skipped++;
        -:  267:                continue;
        -:  268:            }
        -:  269:            bipbuf_push(w->buf, total);
        -:  270:            w->skipped = 0;
        -:  271:        }
        -:  272:        /* Can't fail because bipbuf_request succeeded. */
        -:  273:        bipbuf_offer(w->buf, (unsigned char *) scratch, scratch_len);
        -:  274:        ls->watcher_sent++;
        -:  275:    }
        -:  276:}
        -:  277:
        -:  278:/* Called with logger stack locked.
        -:  279: * Releases every chunk associated with a watcher and closes the connection.
        -:  280: * We can't presently send a connection back to the worker for further
        -:  281: * processing.
        -:  282: */
        3:  283:static void logger_thread_close_watcher(logger_watcher *w) {
        3:  284:    L_DEBUG("LOGGER: Closing dead watcher\n");
        3:  285:    watchers[w->id] = NULL;
        3:  286:    sidethread_conn_close(w->c);
        3:  287:    watcher_count--;
        3:  288:    bipbuf_free(w->buf);
        3:  289:    free(w);
        3:  290:    logger_set_flags();
        3:  291:}
        -:  292:
        -:  293:/* Reads a particular worker thread's available bipbuf bytes. Parses each log
        -:  294: * entry into the watcher buffers.
        -:  295: */
   246714:  296:static int logger_thread_read(logger *l, struct logger_stats *ls) {
   246714:  297:    unsigned int size;
   246714:  298:    unsigned int pos = 0;
   246714:  299:    unsigned char *data;
   246714:  300:    char scratch[LOGGER_PARSE_SCRATCH];
   246714:  301:    logentry *e;
   246714:  302:    pthread_mutex_lock(&l->mutex);
   246714:  303:    data = bipbuf_peek_all(l->buf, &size);
   246714:  304:    pthread_mutex_unlock(&l->mutex);
        -:  305:
   246714:  306:    if (data == NULL) {
        -:  307:        return 0;
        -:  308:    }
        -:  309:    L_DEBUG("LOGGER: Got %d bytes from bipbuffer\n", size);
        -:  310:
        -:  311:    /* parse buffer */
   117018:  312:    while (pos < size && watcher_count > 0) {
    87566:  313:        enum logger_parse_entry_ret ret;
    87566:  314:        int scratch_len = 0;
    87566:  315:        e = (logentry *) (data + pos);
    87566:  316:        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
    87566:  317:        if (ret != LOGGER_PARSE_ENTRY_OK) {
        -:  318:            /* TODO: stats counter */
    #####:  319:            fprintf(stderr, "LOGGER: Failed to parse log entry\n");
        -:  320:        } else {
    87566:  321:            logger_thread_write_entry(e, ls, scratch, scratch_len);
        -:  322:        }
    87566:  323:        pos += sizeof(logentry) + e->size;
        -:  324:    }
   29452*:  325:    assert(pos <= size);
        -:  326:
    29452:  327:    pthread_mutex_lock(&l->mutex);
    29452:  328:    data = bipbuf_poll(l->buf, size);
    29452:  329:    ls->worker_written += l->written;
    29452:  330:    ls->worker_dropped += l->dropped;
    29452:  331:    l->written = 0;
    29452:  332:    l->dropped = 0;
    29452:  333:    pthread_mutex_unlock(&l->mutex);
    29452:  334:    if (data == NULL) {
    #####:  335:        fprintf(stderr, "LOGGER: unexpectedly couldn't advance buf pointer\n");
    #####:  336:        assert(0);
        -:  337:    }
    29452:  338:    return size; /* maybe the count of objects iterated? */
        -:  339:}
        -:  340:
        -:  341:/* Since the event loop code isn't reusable without a refactor, and we have a
        -:  342: * limited number of potential watchers, we run our own poll loop.
        -:  343: * This calls poll() unnecessarily during write flushes, should be possible to
        -:  344: * micro-optimize later.
        -:  345: *
        -:  346: * This flushes buffers attached to watchers, iterating through the bytes set
        -:  347: * to each worker. Also checks for readability in case client connection was
        -:  348: * closed.
        -:  349: *
        -:  350: * Allows a specific watcher to be flushed (if buf full)
        -:  351: */
    85693:  352:static int logger_thread_poll_watchers(int force_poll, int watcher) {
    85693:  353:    int x;
    85693:  354:    int nfd = 0;
    85693:  355:    unsigned char *data;
    85693:  356:    unsigned int data_size = 0;
    85693:  357:    int flushed = 0;
        -:  358:
  1799553:  359:    for (x = 0; x < WATCHER_LIMIT; x++) {
  1713860:  360:        logger_watcher *w = watchers[x];
  1713860:  361:        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
  1642278:  362:            continue;
        -:  363:
    71582:  364:        data = bipbuf_peek_all(w->buf, &data_size);
    71582:  365:        if (data != NULL) {
    68674:  366:            watchers_pollfds[nfd].fd = w->sfd;
    68674:  367:            watchers_pollfds[nfd].events = POLLOUT;
    68674:  368:            nfd++;
     2908:  369:        } else if (force_poll) {
     2908:  370:            watchers_pollfds[nfd].fd = w->sfd;
     2908:  371:            watchers_pollfds[nfd].events = POLLIN;
     2908:  372:            nfd++;
        -:  373:        }
        -:  374:        /* This gets set after a call to poll, and should be used to gate on
        -:  375:         * calling poll again.
        -:  376:         */
    71582:  377:        w->failed_flush = false;
        -:  378:    }
        -:  379:
    85693:  380:    if (nfd == 0)
        -:  381:        return 0;
        -:  382:
        -:  383:    //L_DEBUG("LOGGER: calling poll() [data_size: %d]\n", data_size);
    71569:  384:    int ret = poll(watchers_pollfds, nfd, 0);
        -:  385:
    71569:  386:    if (ret < 0) {
    #####:  387:        perror("something failed with logger thread watcher fd polling");
    #####:  388:        return -1;
        -:  389:    }
        -:  390:
        -:  391:    nfd = 0;
  1502949:  392:    for (x = 0; x < WATCHER_LIMIT; x++) {
  1431380:  393:        logger_watcher *w = watchers[x];
  1431380:  394:        if (w == NULL)
  1359798:  395:            continue;
        -:  396:
    71582:  397:        data_size = 0;
        -:  398:        /* Early detection of a disconnect. Otherwise we have to wait until
        -:  399:         * the next write
        -:  400:         */
    71582:  401:        if (watchers_pollfds[nfd].revents & POLLIN) {
    #####:  402:            char buf[1];
    #####:  403:            int res = read(w->sfd, buf, 1);
    #####:  404:            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  405:                L_DEBUG("LOGGER: watcher closed remotely\n");
    #####:  406:                logger_thread_close_watcher(w);
    #####:  407:                nfd++;
    #####:  408:                continue;
        -:  409:            }
        -:  410:        }
    71582:  411:        if ((data = bipbuf_peek_all(w->buf, &data_size)) != NULL) {
    68674:  412:            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
        3:  413:                L_DEBUG("LOGGER: watcher closed during poll() call\n");
        3:  414:                logger_thread_close_watcher(w);
    68671:  415:            } else if (watchers_pollfds[nfd].revents & POLLOUT) {
     5354:  416:                int total = 0;
        -:  417:
        -:  418:                /* We can write a bit. */
     5354:  419:                switch (w->t) {
    #####:  420:                    case LOGGER_WATCHER_STDERR:
    #####:  421:                        total = fwrite(data, 1, data_size, stderr);
    #####:  422:                        break;
     5354:  423:                    case LOGGER_WATCHER_CLIENT:
     5354:  424:                        total = write(w->sfd, data, data_size);
     5354:  425:                        break;
        -:  426:                }
        -:  427:
        -:  428:                L_DEBUG("LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n", total, w->sfd,
     5354:  429:                        data_size, bipbuf_used(w->buf));
     5354:  430:                if (total == -1) {
    #####:  431:                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
    #####:  432:                        logger_thread_close_watcher(w);
        -:  433:                    }
        -:  434:                    L_DEBUG("LOGGER: watcher hit EAGAIN\n");
     5354:  435:                } else if (total == 0) {
    #####:  436:                    logger_thread_close_watcher(w);
        -:  437:                } else {
     5354:  438:                    bipbuf_poll(w->buf, total);
     5354:  439:                    flushed += total;
        -:  440:                }
        -:  441:            }
        -:  442:        }
    71582:  443:        nfd++;
        -:  444:    }
        -:  445:    return flushed;
        -:  446:}
        -:  447:
    61602:  448:static void logger_thread_sum_stats(struct logger_stats *ls) {
    61602:  449:    STATS_LOCK();
    61602:  450:    stats.log_worker_dropped  += ls->worker_dropped;
    61602:  451:    stats.log_worker_written  += ls->worker_written;
    61602:  452:    stats.log_watcher_skipped += ls->watcher_skipped;
    61602:  453:    stats.log_watcher_sent    += ls->watcher_sent;
    61602:  454:    STATS_UNLOCK();
    61602:  455:}
        -:  456:
        -:  457:#define MAX_LOGGER_SLEEP 100000
        -:  458:#define MIN_LOGGER_SLEEP 0
        -:  459:
        -:  460:/* Primary logger thread routine */
       90:  461:static void *logger_thread(void *arg) {
       90:  462:    useconds_t to_sleep = MIN_LOGGER_SLEEP;
       90:  463:    L_DEBUG("LOGGER: Starting logger thread\n");
    61692:  464:    while (do_run_logger_thread) {
    61692:  465:        int found_logs = 0;
    61692:  466:        logger *l;
    61692:  467:        struct logger_stats ls;
    61692:  468:        memset(&ls, 0, sizeof(struct logger_stats));
    61692:  469:        if (to_sleep)
    32239:  470:            usleep(to_sleep);
        -:  471:
        -:  472:        /* Call function to iterate each logger. */
    61602:  473:        pthread_mutex_lock(&logger_stack_lock);
   308316:  474:        for (l = logger_stack_head; l != NULL; l=l->next) {
        -:  475:            /* lock logger, call function to manipulate it */
   246714:  476:            found_logs += logger_thread_read(l, &ls);
        -:  477:        }
        -:  478:
    61602:  479:        logger_thread_poll_watchers(1, WATCHER_ALL);
    61602:  480:        pthread_mutex_unlock(&logger_stack_lock);
        -:  481:
        -:  482:        /* TODO: abstract into a function and share with lru_crawler */
    61602:  483:        if (!found_logs) {
    32150:  484:            if (to_sleep < MAX_LOGGER_SLEEP)
    32150:  485:                to_sleep += 50;
        -:  486:        } else {
    29452:  487:            to_sleep /= 2;
    29452:  488:            if (to_sleep < 50)
    29363:  489:                to_sleep = MIN_LOGGER_SLEEP;
        -:  490:        }
    61602:  491:        logger_thread_sum_stats(&ls);
        -:  492:    }
        -:  493:
    #####:  494:    return NULL;
        -:  495:}
        -:  496:
       90:  497:static int start_logger_thread(void) {
       90:  498:    int ret;
       90:  499:    do_run_logger_thread = 1;
       90:  500:    if ((ret = pthread_create(&logger_tid, NULL,
        -:  501:                              logger_thread, NULL)) != 0) {
    #####:  502:        fprintf(stderr, "Can't start logger thread: %s\n", strerror(ret));
    #####:  503:        return -1;
        -:  504:    }
        -:  505:    return 0;
        -:  506:}
        -:  507:
        -:  508:// future.
        -:  509:/*static int stop_logger_thread(void) {
        -:  510:    do_run_logger_thread = 0;
        -:  511:    pthread_join(logger_tid, NULL);
        -:  512:    return 0;
        -:  513:}*/
        -:  514:
        -:  515:/*************************
        -:  516: * Public functions for submitting logs and starting loggers from workers.
        -:  517: *************************/
        -:  518:
        -:  519:/* Global logger thread start/init */
       90:  520:void logger_init(void) {
        -:  521:    /* TODO: auto destructor when threads exit */
        -:  522:    /* TODO: error handling */
        -:  523:
        -:  524:    /* init stack for iterating loggers */
       90:  525:    logger_stack_head = 0;
       90:  526:    logger_stack_tail = 0;
       90:  527:    pthread_key_create(&logger_key, NULL);
        -:  528:
       90:  529:    if (start_logger_thread() != 0) {
    #####:  530:        abort();
        -:  531:    }
        -:  532:
        -:  533:    /* This can be removed once the global stats initializer is improved */
       90:  534:    STATS_LOCK();
       90:  535:    stats.log_worker_dropped = 0;
       90:  536:    stats.log_worker_written = 0;
       90:  537:    stats.log_watcher_skipped = 0;
       90:  538:    stats.log_watcher_sent = 0;
       90:  539:    STATS_UNLOCK();
        -:  540:    /* This is what adding a STDERR watcher looks like. should replace old
        -:  541:     * "verbose" settings. */
        -:  542:    //logger_add_watcher(NULL, 0);
       90:  543:    return;
        -:  544:}
        -:  545:
        -:  546:/* called *from* the thread using a logger.
        -:  547: * initializes the per-thread bipbuf, links it into the list of loggers
        -:  548: */
      366:  549:logger *logger_create(void) {
      366:  550:    L_DEBUG("LOGGER: Creating and linking new logger instance\n");
      366:  551:    logger *l = calloc(1, sizeof(logger));
      366:  552:    if (l == NULL) {
        -:  553:        return NULL;
        -:  554:    }
        -:  555:
      366:  556:    l->buf = bipbuf_new(settings.logger_buf_size);
      366:  557:    if (l->buf == NULL) {
    #####:  558:        free(l);
    #####:  559:        return NULL;
        -:  560:    }
        -:  561:
      366:  562:    l->entry_map = default_entries;
        -:  563:
      366:  564:    pthread_mutex_init(&l->mutex, NULL);
      366:  565:    pthread_setspecific(logger_key, l);
        -:  566:
        -:  567:    /* add to list of loggers */
      366:  568:    logger_link_q(l);
      366:  569:    return l;
        -:  570:}
        -:  571:
        -:  572:/* helpers for logger_log */
        -:  573:
      154:  574:static void _logger_log_evictions(logentry *e, item *it) {
      154:  575:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
     154*:  576:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
      154:  577:    le->latime = current_time - it->time;
      154:  578:    le->it_flags = it->it_flags;
      154:  579:    le->nkey = it->nkey;
      154:  580:    le->clsid = ITEM_clsid(it);
      154:  581:    memcpy(le->key, ITEM_key(it), it->nkey);
      154:  582:    e->size = sizeof(struct logentry_eviction) + le->nkey;
      154:  583:}
        -:  584:
        -:  585:/* 0 == nf, 1 == found. 2 == flushed. 3 == expired.
        -:  586: * might be useful to store/print the flags an item has?
        -:  587: * could also collapse this and above code into an "item status" struct. wait
        -:  588: * for more endpoints to be written before making it generic, though.
        -:  589: * TODO: This and below should track and reprint the client fd.
        -:  590: */
    87273:  591:static void _logger_log_item_get(logentry *e, const int was_found, const char *key,
        -:  592:        const int nkey, const uint8_t clsid) {
    87273:  593:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    87273:  594:    le->was_found = was_found;
    87273:  595:    le->nkey = nkey;
    87273:  596:    le->clsid = clsid;
    87273:  597:    memcpy(le->key, key, nkey);
    87273:  598:    e->size = sizeof(struct logentry_item_get) + nkey;
        -:  599:}
        -:  600:
      153:  601:static void _logger_log_item_store(logentry *e, const enum store_item_type status,
        -:  602:        const int comm, char *key, const int nkey, rel_time_t ttl, const uint8_t clsid) {
      153:  603:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
      153:  604:    le->status = status;
      153:  605:    le->cmd = comm;
      153:  606:    le->nkey = nkey;
      153:  607:    le->clsid = clsid;
      153:  608:    if (ttl != 0) {
    #####:  609:        le->ttl = ttl - current_time;
        -:  610:    } else {
      153:  611:        le->ttl = 0;
        -:  612:    }
      153:  613:    memcpy(le->key, key, nkey);
      153:  614:    e->size = sizeof(struct logentry_item_store) + nkey;
      153:  615:}
        -:  616:
        -:  617:/* Public function for logging an entry.
        -:  618: * Tries to encapsulate as much of the formatting as possible to simplify the
        -:  619: * caller's code.
        -:  620: */
    87580:  621:enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    87580:  622:    bipbuf_t *buf = l->buf;
    87580:  623:    bool nospace = false;
    87580:  624:    va_list ap;
    87580:  625:    int total = 0;
    87580:  626:    logentry *e;
        -:  627:
    87580:  628:    const entry_details *d = &l->entry_map[event];
    87580:  629:    int reqlen = d->reqlen;
        -:  630:
    87580:  631:    pthread_mutex_lock(&l->mutex);
        -:  632:    /* Request a maximum length of data to write to */
    87580:  633:    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    87580:  634:    if (e == NULL) {
    #####:  635:        pthread_mutex_unlock(&l->mutex);
    #####:  636:        l->dropped++;
    #####:  637:        return LOGGER_RET_NOSPACE;
        -:  638:    }
    87580:  639:    e->gid = logger_get_gid();
    87580:  640:    e->event = d->subtype;
        -:  641:    /* TODO: Could pass this down as an argument now that we're using
        -:  642:     * LOGGER_LOG() macro.
        -:  643:     */
    87580:  644:    e->eflags = d->eflags;
        -:  645:    /* Noting time isn't optional. A feature may be added to avoid rendering
        -:  646:     * time and/or gid to a logger.
        -:  647:     */
    87580:  648:    gettimeofday(&e->tv, NULL);
        -:  649:
    87580:  650:    switch (d->subtype) {
    #####:  651:        case LOGGER_TEXT_ENTRY:
    #####:  652:            va_start(ap, entry);
    #####:  653:            total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    #####:  654:            va_end(ap);
    #####:  655:            if (total >= reqlen || total <= 0) {
    #####:  656:                fprintf(stderr, "LOGGER: Failed to vsnprintf a text entry: (total) %d\n", total);
        -:  657:                break;
        -:  658:            }
    #####:  659:            e->size = total + 1; /* null byte */
        -:  660:
    #####:  661:            break;
      154:  662:        case LOGGER_EVICTION_ENTRY:
      154:  663:            _logger_log_evictions(e, (item *)entry);
      154:  664:            break;
    87273:  665:        case LOGGER_ITEM_GET_ENTRY:
    87273:  666:            va_start(ap, entry);
    87273:  667:            int was_found = va_arg(ap, int);
    87273:  668:            char *key = va_arg(ap, char *);
    87273:  669:            size_t nkey = va_arg(ap, size_t);
    87273:  670:            uint8_t gclsid = va_arg(ap, int);
    87273:  671:            _logger_log_item_get(e, was_found, key, nkey, gclsid);
    87273:  672:            va_end(ap);
    87273:  673:            break;
      153:  674:        case LOGGER_ITEM_STORE_ENTRY:
      153:  675:            va_start(ap, entry);
      153:  676:            enum store_item_type status = va_arg(ap, enum store_item_type);
      153:  677:            int comm = va_arg(ap, int);
      153:  678:            char *skey = va_arg(ap, char *);
      153:  679:            size_t snkey = va_arg(ap, size_t);
      153:  680:            rel_time_t sttl = va_arg(ap, rel_time_t);
      153:  681:            uint8_t sclsid = va_arg(ap, int);
      153:  682:            _logger_log_item_store(e, status, comm, skey, snkey, sttl, sclsid);
        -:  683:            break;
        -:  684:    }
        -:  685:
        -:  686:    /* Push pointer forward by the actual amount required */
    87580:  687:    if (bipbuf_push(buf, (sizeof(logentry) + e->size)) == 0) {
    #####:  688:        fprintf(stderr, "LOGGER: Failed to bipbuf push a text entry\n");
    #####:  689:        pthread_mutex_unlock(&l->mutex);
    #####:  690:        return LOGGER_RET_ERR;
        -:  691:    }
    87580:  692:    l->written++;
        -:  693:    L_DEBUG("LOGGER: Requested %d bytes, wrote %lu bytes\n", reqlen,
    87580:  694:            (sizeof(logentry) + e->size));
        -:  695:
    87580:  696:    pthread_mutex_unlock(&l->mutex);
        -:  697:
    87580:  698:    if (nospace) {
        -:  699:        return LOGGER_RET_NOSPACE;
        -:  700:    } else {
    87580:  701:        return LOGGER_RET_OK;
        -:  702:    }
        -:  703:}
        -:  704:
        -:  705:/* Passes a client connection socket from a primary worker thread to the
        -:  706: * logger thread. Caller *must* event_del() the client before handing it over.
        -:  707: * Presently there's no way to hand the client back to the worker thread.
        -:  708: */
        3:  709:enum logger_add_watcher_ret logger_add_watcher(void *c, const int sfd, uint16_t f) {
        3:  710:    int x;
        3:  711:    logger_watcher *w = NULL;
        3:  712:    pthread_mutex_lock(&logger_stack_lock);
        3:  713:    if (watcher_count >= WATCHER_LIMIT) {
        -:  714:        return LOGGER_ADD_WATCHER_TOO_MANY;
        -:  715:    }
        -:  716:
        4:  717:    for (x = 0; x < WATCHER_LIMIT; x++) {
        4:  718:        if (watchers[x] == NULL)
        -:  719:            break;
        -:  720:    }
        -:  721:
        3:  722:    w = calloc(1, sizeof(logger_watcher));
        3:  723:    if (w == NULL) {
    #####:  724:        pthread_mutex_unlock(&logger_stack_lock);
    #####:  725:        return LOGGER_ADD_WATCHER_FAILED;
        -:  726:    }
        3:  727:    w->c = c;
        3:  728:    w->sfd = sfd;
        3:  729:    if (sfd == 0 && c == NULL) {
    #####:  730:        w->t = LOGGER_WATCHER_STDERR;
        -:  731:    } else {
        3:  732:        w->t = LOGGER_WATCHER_CLIENT;
        -:  733:    }
        3:  734:    w->id = x;
        3:  735:    w->eflags = f;
        3:  736:    w->buf = bipbuf_new(settings.logger_watcher_buf_size);
        3:  737:    if (w->buf == NULL) {
    #####:  738:        free(w);
    #####:  739:        pthread_mutex_unlock(&logger_stack_lock);
    #####:  740:        return LOGGER_ADD_WATCHER_FAILED;
        -:  741:    }
        3:  742:    bipbuf_offer(w->buf, (unsigned char *) "OK\r\n", 4);
        -:  743:
        3:  744:    watchers[x] = w;
        3:  745:    watcher_count++;
        -:  746:    /* Update what flags the global logs will watch */
        3:  747:    logger_set_flags();
        -:  748:
        3:  749:    pthread_mutex_unlock(&logger_stack_lock);
        3:  750:    return LOGGER_ADD_WATCHER_OK;
        -:  751:}
