        -:    0:Source:util.c
        -:    0:Graph:util.gcno
        -:    0:Data:util.gcda
        -:    0:Runs:183
        -:    1:#include <stdio.h>
        -:    2:#include <assert.h>
        -:    3:#include <ctype.h>
        -:    4:#include <errno.h>
        -:    5:#include <string.h>
        -:    6:#include <stdlib.h>
        -:    7:#include <stdarg.h>
        -:    8:
        -:    9:#include "memcached.h"
        -:   10:
        -:   11:static char *uriencode_map[256];
        -:   12:static char uriencode_str[768];
        -:   13:
       88:   14:void uriencode_init(void) {
       88:   15:    int x;
       88:   16:    char *str = uriencode_str;
    22616:   17:    for (x = 0; x < 256; x++) {
    22528:   18:        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
     5808:   19:            uriencode_map[x] = NULL;
        -:   20:        } else {
    16720:   21:            snprintf(str, 4, "%%%02X", x);
    16720:   22:            uriencode_map[x] = str;
    16720:   23:            str += 3; /* lobbing off the \0 is fine */
        -:   24:        }
        -:   25:    }
       88:   26:}
        -:   27:
    87566:   28:bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {
    87566:   29:    int x;
    87566:   30:    size_t d = 0;
 15183028:   31:    for (x = 0; x < srclen; x++) {
 15095462:   32:        if (d + 4 >= dstlen)
        -:   33:            return false;
 15095462:   34:        if (uriencode_map[(unsigned char) src[x]] != NULL) {
     7496:   35:            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
     7496:   36:            d += 3;
        -:   37:        } else {
 15087966:   38:            dst[d] = src[x];
 15087966:   39:            d++;
        -:   40:        }
        -:   41:    }
    87566:   42:    dst[d] = '\0';
    87566:   43:    return true;
        -:   44:}
        -:   45:
        -:   46:/* Avoid warnings on solaris, where isspace() is an index into an array, and gcc uses signed chars */
        -:   47:#define xisspace(c) isspace((unsigned char)c)
        -:   48:
      612:   49:bool safe_strtoull(const char *str, uint64_t *out) {
     612*:   50:    assert(out != NULL);
      612:   51:    errno = 0;
      612:   52:    *out = 0;
      612:   53:    char *endptr;
      612:   54:    unsigned long long ull = strtoull(str, &endptr, 10);
      612:   55:    if ((errno == ERANGE) || (str == endptr)) {
        -:   56:        return false;
        -:   57:    }
        -:   58:
      608:   59:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
      608:   60:        if ((long long) ull < 0) {
        -:   61:            /* only check for negative signs in the uncommon case when
        -:   62:             * the unsigned number is so big that it's negative as a
        -:   63:             * signed number. */
        6:   64:            if (strchr(str, '-') != NULL) {
        -:   65:                return false;
        -:   66:            }
        -:   67:        }
      608:   68:        *out = ull;
      608:   69:        return true;
        -:   70:    }
        -:   71:    return false;
        -:   72:}
        -:   73:
    #####:   74:bool safe_strtoll(const char *str, int64_t *out) {
    #####:   75:    assert(out != NULL);
    #####:   76:    errno = 0;
    #####:   77:    *out = 0;
    #####:   78:    char *endptr;
    #####:   79:    long long ll = strtoll(str, &endptr, 10);
    #####:   80:    if ((errno == ERANGE) || (str == endptr)) {
        -:   81:        return false;
        -:   82:    }
        -:   83:
    #####:   84:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   85:        *out = ll;
    #####:   86:        return true;
        -:   87:    }
        -:   88:    return false;
        -:   89:}
        -:   90:
    82068:   91:bool safe_strtoul(const char *str, uint32_t *out) {
    82068:   92:    char *endptr = NULL;
    82068:   93:    unsigned long l = 0;
   82068*:   94:    assert(out);
   82068*:   95:    assert(str);
    82068:   96:    *out = 0;
    82068:   97:    errno = 0;
        -:   98:
    82068:   99:    l = strtoul(str, &endptr, 10);
    82068:  100:    if ((errno == ERANGE) || (str == endptr)) {
        -:  101:        return false;
        -:  102:    }
        -:  103:
    82067:  104:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    82067:  105:        if ((long) l < 0) {
        -:  106:            /* only check for negative signs in the uncommon case when
        -:  107:             * the unsigned number is so big that it's negative as a
        -:  108:             * signed number. */
    #####:  109:            if (strchr(str, '-') != NULL) {
        -:  110:                return false;
        -:  111:            }
        -:  112:        }
    82067:  113:        *out = l;
    82067:  114:        return true;
        -:  115:    }
        -:  116:
        -:  117:    return false;
        -:  118:}
        -:  119:
   164115:  120:bool safe_strtol(const char *str, int32_t *out) {
  164115*:  121:    assert(out != NULL);
   164115:  122:    errno = 0;
   164115:  123:    *out = 0;
   164115:  124:    char *endptr;
   164115:  125:    long l = strtol(str, &endptr, 10);
   164115:  126:    if ((errno == ERANGE) || (str == endptr)) {
        -:  127:        return false;
        -:  128:    }
        -:  129:
   164113:  130:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
   164113:  131:        *out = l;
   164113:  132:        return true;
        -:  133:    }
        -:  134:    return false;
        -:  135:}
        -:  136:
        1:  137:void vperror(const char *fmt, ...) {
        1:  138:    int old_errno = errno;
        1:  139:    char buf[1024];
        1:  140:    va_list ap;
        -:  141:
        1:  142:    va_start(ap, fmt);
        1:  143:    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
    #####:  144:        buf[sizeof(buf) - 1] = '\0';
        -:  145:    }
        1:  146:    va_end(ap);
        -:  147:
        1:  148:    errno = old_errno;
        -:  149:
        1:  150:    perror(buf);
        1:  151:}
        -:  152:
        -:  153:#ifndef HAVE_HTONLL
   135145:  154:static uint64_t mc_swap64(uint64_t in) {
        -:  155:#ifdef ENDIAN_LITTLE
        -:  156:    /* Little endian, flip the bytes around until someone makes a faster/better
        -:  157:    * way to do this. */
   135145:  158:    int64_t rv = 0;
   135145:  159:    int i = 0;
  1216305:  160:     for(i = 0; i<8; i++) {
  1081160:  161:        rv = (rv << 8) | (in & 0xff);
  1081160:  162:        in >>= 8;
        -:  163:     }
   135145:  164:    return rv;
        -:  165:#else
        -:  166:    /* big-endian machines don't need byte swapping */
        -:  167:    return in;
        -:  168:#endif
        -:  169:}
        -:  170:
    77277:  171:uint64_t ntohll(uint64_t val) {
    77277:  172:   return mc_swap64(val);
        -:  173:}
        -:  174:
    57868:  175:uint64_t htonll(uint64_t val) {
    57868:  176:   return mc_swap64(val);
        -:  177:}
        -:  178:#endif
        -:  179:
